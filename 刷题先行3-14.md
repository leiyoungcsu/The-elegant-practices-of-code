**刷题**

----------
![](TY/61.PNG)
----------
1、返回字符串中的元音字母，元音字母为a、e、i、o、u，输入参数只包含小写字母 空格 和“/”（斜杠）

```
public class Vowels {

  public static int getCount(String str) {
    int vowelsCount = 0;
    // your code here
    char []key =str.toCharArray();
    for (int i=0;i<key.length;i++){
    if (key[i]=='a' | key[i]=='e' | key[i]=='i' |key[i]=='o' |key[i]=='u'){
    vowelsCount++;
    }
  }
 return vowelsCount;
}
}
```

----------
2、
a = "xyaabbbccccdefww"
b = "xxxxyyyyabklmopq"
longest(a, b) -> "abcdefklmopqwxy"

a = "abcdefghijklmnopqrstuvwxyz"
longest(a, a) -> "abcdefghijklmnopqrstuvwxyz"

想的思路是将字符串合并为一个，然后依次判断加入到一个新的列表中，然后得到没有重复字符的列表，对其排序转换输出即可。代码如下

```
package com.csu;

import java.util.TreeSet;

public class TwoToOne {
    
    public static String longest (String s1, String s2) {
        // your code
    	        s1 = s1+s2;
    	        char[] chars =  s1.toCharArray();
    	        TreeSet<Character> set = new TreeSet<>();

    	        for(char i : chars)
    	            set.add(i);
    	            s1 = "";
    	        for(char i : set)
    	            s1 += i;
    	            return s1;   
    	            }
    	
}

```

----------

3、
Simple, given a string of words, return the length of the shortest word(s).

String will never be empty and you do not need to account for different data types

```

public class Kata {
    public static int findShort(String s) {
    String [] z= s.split(" ")  ;
    int size =z[0].length();
    for (int i=1;i<z.length;i++){
      if (z[i].length()<size){
      
      size=z[i].length();
      }
      }
      return size;
    
    }
}
```

----------
4、
Complete the method/function so that it converts dash/underscore delimited words into camel casing. The first word within the output should be capitalized only if the original word was capitalized.

问题描述：就是将给定字符串变为：第一个单词不变。之后的每个单词的首字母大写。类似于驼峰命名

```
class Solution{

  static String toCamelCase(String s){
	  String [] aa;
	  String bb;
	  String cc="";
	  
	  if (s.contains("-")) {
		  aa=s.split("-");
		  cc=aa[0];
		  
		  for (int i=1;i<aa.length;i++) {
			  bb=aa[i].substring(0,1).toUpperCase()+aa[i].substring(1);
			  cc=cc+bb;
		  }
	  }
	  if (s.contains("_")) {
		  aa=s.split("_");
		  cc=aa[0];
		  
		  for (int i=1;i<aa.length;i++) {
			  bb=aa[i].substring(0,1).toUpperCase()+aa[i].substring(1);
			  cc=cc+bb;
		  }
	  }
	  
  
    return cc;
  }
}
```

----------
5、
You are given an array (which will have a length of at least 3, but could be very large) containing integers. The array is either entirely comprised of odd integers or entirely comprised of even integers except for a single integer N. Write a method that takes the array as an argument and returns this "outlier" N.

这题的意思是从一堆奇数里挑偶数，一堆偶数里挑奇数，还算简单

```
public class FindOutlier{
	  static int find(int[] integers){
	  
		  int evencount=0,oddcount=0;
		  int evennum=0,oddnum=0;
		 
		  
		 for (int i:integers) {
			 
			 if (Math.abs(i)%2==0) {
				 evennum=i;
				 evencount++;
			 }else {
				 oddnum=i;
				 oddcount++;
				 
			 }
		 if (evencount>0 && oddcount>0) {
			 if (evencount>1) {
				return oddnum;
			 }
			 else if (oddcount>1) {
				return evennum;
			 }
		 }
	 }

	  return evencount>1 ? oddnum:evennum;
		
}
}
```

----------
6、
Deoxyribonucleic acid (DNA) is a chemical found in the nucleus of cells and carries the "instructions" for the development and functioning of living organisms.

If you want to know more http://en.wikipedia.org/wiki/DNA

In DNA strings, symbols "A" and "T" are complements of each other, as "C" and "G". You have function with one side of the DNA (string, except for Haskell); you need to get the other complementary side. DNA strand is never empty or there is no DNA at all (again, except for Haskell).

DnaStrand.makeComplement("ATTGC") // return "TAACG"

DnaStrand.makeComplement("GTAT") // return "CATA"

```
public class DnaStrand {
  public static String makeComplement(String dna) {
    //Your code
    char[] chars=dna.toCharArray();
    for (int i=0;i<dna.length();i++){
    chars[i]=getComplement(chars[i]);
    
    }
    return new String(chars);
  }
  private static char getComplement(char c){
  switch(c){
  case  'A':return 'T';
  case  'T':return 'A';
  case  'C':return 'G';
  case  'G':return 'C';
  
  }
  return c;
  
  
  }
}
```

----------
7、
This time no story, no theory. The examples below show you how to write function accum:
accum("abcd") -> "A-Bb-Ccc-Dddd"
accum("RqaEzty") -> "R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy"
accum("cwAt") -> "C-Ww-Aaa-Tttt"

```
public class Accumul {
    
    public static String accum(String s) {
     // your code
    s=s.toLowerCase();
    StringBuffer sb=new StringBuffer();
    for (int i=0;i<s.length();i++) {
    	char ch=s.charAt(i);
    	sb.append(Character.toUpperCase(ch));
    	for (int j=0;j<i;j++) {
    		sb.append(ch);
    	}
    	

    	sb.append("-");
    	
    }
    return sb.deleteCharAt(sb.lastIndexOf("-")).toString();
    
}
}
```

----------

----------
8、


Not Jaden-Cased: "How can mirrors be real if our eyes aren't real"
Jaden-Cased:     "How Can Mirrors Be Real If Our Eyes Aren't Real"

```

public class JadenCase {

	public static  String toJadenCase(String phrase) {
		// TODO put your code below this comment
		
		
		if(phrase==null || "" .equals(phrase)) {
		return null;
	}
		String[] str=phrase.split(" ");
		for (int i=0;i<str.length;i++) {
			char [] array=str[i].toCharArray();
			array[0]=String.valueOf(array[0]).toUpperCase().charAt(0);
			str[i]=String.valueOf(array);
		
		}
 		StringBuffer sb=new StringBuffer();
 		for (String i:str) {
 			sb.append(i+" ");
 		}
 			return sb.substring(0, sb.toString().length()-1).toString();
 		}
      }
```


----------
9、

digital_root(16)
=> 1 + 6
=> 7

digital_root(942)
=> 9 + 4 + 2
=> 15 ...
=> 1 + 5
=> 6

digital_root(132189)
=> 1 + 3 + 2 + 1 + 8 + 9
=> 24 ...
=> 2 + 4
=> 6

digital_root(493193)
=> 4 + 9 + 3 + 1 + 9 + 3
=> 29 ...
=> 2 + 9
=> 11 ...
=> 1 + 1
=> 2

```
package kata

func DigitalRoot(n int) (total int) {
  for n >= 10 { 
    total += n % 10
    n = n / 10
  } 
  total += n
      
  if total >= 10 {
    total = DigitalRoot(total)
  }
  return
}
```

----------
10、

isIsogram "Dermatoglyphics" == true
isIsogram "aba" == false
isIsogram "moOse" == false -- ignore letter case

找出字符串中的重复字母，不区分大小写。

```
import java.util.HashSet;
import java.util.Set;


public class isogram {
    public static boolean  isIsogram(String str) {
    	   Set<Character> letter =new HashSet<Character>(); 
    		   for(int i=0;i<str.length();i++) {
    			   if (letter.contains(str.toLowerCase().charAt(i))) {
    				  return false;
    			  }
    			   letter.add(str.charAt(i));
    			   
    		  }
    		   return true;
    }
}
```
----------
11、

Check to see if a string has the same amount of 'x's and 'o's. The method must return a boolean and be case insensitive. The string can contain any char.
XO("ooxx") => true
XO("xooxx") => false
XO("ooxXm") => true
XO("zpzpzpp") => true // when no 'x' and 'o' is present should return true
XO("zzoo") => false

```
public class XO {
	  
	  public static boolean getXO (String str) {
	    
	    // Good Luck!!
		  int j=0,k=0;
		char[]arr1=new char[str.length()];
		char[]arr2=new char[str.length()];
	      char[] ch=str.toLowerCase().toCharArray();
	      for (int i=0;i<str.length();i++) {
	    	  if (ch[i]=='o'){
	    		  arr2[j]=ch[i];
    			  j++;
	    	  }
	    	  else if  (ch[i]=='x') {

    			  arr2[k]=ch[i];
    			  k++;
	    	  }
	      }
	    	  if (k==j) {
	    		  return true;
	    	  }
	    	  return false;
	      }
        }
```

----------
12、

The number 89 is the first integer with more than one digit that fulfills the property partially introduced in the title of this kata. What's the use of saying "Eureka"? Because this sum gives the same number.

In effect: 89 = 8^1 + 9^2

The next number in having this property is 135.

See this property again: 135 = 1^1 + 3^2 + 5^3

We need a function to collect these numbers, that may receive two integers a, b that defines the range [a, b] (inclusive) and outputs a list of the sorted numbers in the range that fulfills the property described above.

Let's see some cases:

sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9]

sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89]
If there are no numbers of this kind in the range [a, b] the function should output an empty list.

sum_dig_pow(90, 100) == []

```
import java.util.ArrayList;
import java.util.List;

public class SumDigPower {
    
    public static List<Long> sumDigPow(long a, long b) {
        // your code
    	final List<Long> ret=new ArrayList<>() ;
    	 
    	for (long k=a;k<=b;k++) {
    		long v=0;
    		int exe=1;
    		for (char c:(""+k).toCharArray()) {
    			v+=Math.pow(c-'0', exe);
    			exe++;
    			
    		if (v>k) {
    			break;
    		}
    		}
    		if (v==k) {
    			ret.add(k);
    		}
    	}
		return ret;
}
```

----------
16、
reverses each word in the string.

Examples
"This is an example!" ==> "sihT si na !elpmaxe"
"double  spaces"      ==> "elbuod  secaps"

```
public class Kata{
  public static String reverseWords(final String original){
    // Have at it
	  String [] array=original.split(" ");
	  if (array.length==0) {
		  return original;
	  }
	  int i=0;
	  for (String str :array) {
		  array[i]=new StringBuffer(str).reverse().toString();
		  i++;
	  }
	  return String.join(" ", array);
  }
}
```

----------

----------
17、
You are given an array strarr of strings and an integer k. Your task is to return the first longest string consisting of k consecutive strings taken in the array.

Example:
longest_consec(["zone", "abigail", "theta", "form", "libe", "zas", "theta", "abigail"], 2) --> "abigailtheta"

n being the length of the string array, if n = 0 or k > n or k <= 0 return "".

题目意思就是找 k 个字符串加起来的总字符串最长的那个，然后返回这个

```
class LongestConsec {
    public static String longestConsec(String[] strarr, int k) {
        if (strarr.length == 0 || k > strarr.length || k <= 0)
            return "";

        String longestStr = "";
        for (int index = 0; index < strarr.length - k + 1; index++) {
            StringBuilder sb = new StringBuilder();
            for (int i = index; i < index + k; i++) {
                sb.append(strarr[i]);
            }
            if (sb.toString().length() > longestStr.length()) {
                longestStr = sb.toString();
            }
        }
        return longestStr;
    }
}
```

----------


----------
18、
You are given an odd-length array of integers, in which all of them are the same, except for one single number.

Complete the method which accepts such an array, and returns that single different number.

The input array will always be valid! (odd-length >= 3)

Examples
[1, 1, 2] ==> 2
[17, 17, 3, 17, 17, 17, 17] ==> 3

题目大意：给出一个长度为奇数且大于3的数组，找出其中不同的那一个数字。

解题思路：直接进行数组的排序，再进行比较，第一个元素跟第二个元素如果相等就直接返回最后一个元素，否则就是第一个元素，因为数组的元素已经排好序了，不同的那一个数要么是最大的，要么是最小的。

```
import java.util.Arrays;

public class Solution {
	  static int stray(int[] numbers) {
		
		 Arrays.sort(numbers);
		 
	    return numbers[0]==numbers[1]?numbers[numbers.length-1]:numbers[0];
	  }
	}
```

----------
19、


Examples
Maskify.Maskify("4556364607935616"); // should return "############5616"
Maskify.Maskify("64607935616");      // should return "#######5616"
Maskify.Maskify("1");                // should return "1"
Maskify.Maskify("");                 // should return ""

// "What was the name of your first pet?"
Maskify.Maskify("Skippy");                                   // should return "##ippy"
Maskify.Maskify("Nananananananananananananananana Batman!"); // should return "####################################man!"

大意：写一个遮罩函数，把除了末尾4个字符之外的其他都改成“#

```
public class Maskify {
    public static String maskify(String str) {
    

  if (str.length()<=4) {
	  return str;
  }
  String result="";
  for (int i=0;i<str.length()-4;i++) {
	  result+="#";
  }
  return result+str.substring(str.length()-4);
}
```

----------
22

In this little assignment you are given a string of space separated numbers, and have to return the highest and lowest number.

Example:

highAndLow("1 2 3 4 5");  // return "5 1"
highAndLow("1 2 -3 4 5"); // return "5 -3"
highAndLow("1 9 3 4 -5"); // return "9 -5"

```
import java.util.Arrays;

public class Kata {

    public static String HighAndLow(String numbers) {
        numbers=numbers.replaceAll(" ",",");
        String[] a=numbers.split(",");
        int[] arr=new int[a.length];
        for(int i=0;i<a.length;i++){
            arr[i]=Integer.parseInt(a[i]);
        }
        Arrays.sort(arr);
        numbers=arr[arr.length-1]+" "+arr[0];
        return numbers;
    }
```
----------
30

Sort binary tree by levels

You are given a binary tree:
```
public class Node {
  public Node left;
  public Node right;
  public int value;

  public Node(Node l, Node r, int v) {
    left = l;
    right = r;
    value = v;
  }
}
```
Your task is to return the list with elements from tree sorted by levels, which means the root element goes first, then root children (from left to right) are second and third, and so on.

Return empty list is root is 'null'.

Example 1 - following tree:

                 2
            8        9
          1  3     4   5
Should return following list:

[2,8,9,1,3,4,5]
Example 2 - following tree:

                 1
            8        4
              3        5
                         7
Should return following list:

[1,8,4,3,5,7]


pollFirst()删除第一个元素，并返回删除元素的值，如果元素为null，将返回null
```
public class Kata {
  public static List<Integer> treeByLevels(Node node) {
    
	List<Integer> out =new ArrayList<>();
	ArrayDeque<Node> q=new ArrayDeque<Node>();
	
	if (node!=null) {
		q.add(node);
	}
	while(!q.isEmpty()) {
		node=q.pollFirst();

		out.add(node.value);
		if (node.left!=null) {
			q.add(node.left);
		}
		if (node.right!=null) {
			q.add(node.right);
		
	}
	}
	return out;
    
  }
  
}
```
----------
35

In mathematics, the factorial of integer n is written as n!. It is equal to the product of n and every integer preceding it. For example: 5! = 1 x 2 x 3 x 4 x 5 = 120

注意是数据溢出问题

```

import java.math.BigInteger;

public class Kata{

	  public static String Factorial(int n) {
		  BigInteger sum=new BigInteger("1");
		  BigInteger flat=new BigInteger("1");
		  if(n<0){
			  return "-1";//传入的数据不合法
			         }
			           if(n==0){
			               return "1";
			           }
			           for (int i=1;i<=n;i++) {
			        	   flat=flat.multiply(sum);
			        	   sum=sum.add(new BigInteger("1"));
			          }
	    return ""+flat;
	  }
}
```
----------
40

Pyramids are amazing! Both in architectural and mathematical sense. If you have a computer, you can mess with pyramids even if you are not in Egypt at the time. For example, let's consider the following problem. Imagine that you have a pyramid built of numbers, like this one here:

  /3/
  \7\ 4 
 2 \4\ 6 
8 5 \9\ 3

slide down' is 3 + 7 + 4 + 9 = 23

这里我简单解释一下动态规划方法，从底部开始，把倒数第二层每个元素，分别加上下一层的相邻元素（可以选的下一步）,，把最大的一个（最优的下一步）作为这层（倒数第二层）的新元素。
比如：
   3
  7 4
 2 4 6 
8 5 9 3 

最底下的一层是8 5 9 3，倒数第二层是2 4 6
2可以选择下一层的8或者5作为下一步，而2+8>2+5，故把2+8=10，取代2,
4可以选择下一层的5和9作为下一步，而4+9>4+5，故把4+9=13，取代4的位置
同理6+9>6+3，倒数第二层变成了10 13 15，去掉（无视）最后一层，把倒数第二层最为新的最后一层。
金字塔变成
     3
   7  4
 10 13 15 


然后，金字塔变成
   3 
  20 19

到最后只剩下一层，就是23，这个就是最优解了


```
public class LongestSlideDown {

    public static int longestSlideDown(int[][] pyramid) {
       
       for (int r = pyramid.length - 1; r > 0; r--)
            for (int c = 0; c < pyramid[r].length - 1; c++)
                pyramid[r - 1][c] += Math.max(pyramid[r][c], pyramid[r][c + 1]);
       return pyramid[0][0];
    }
}
```
----------
45

"one" => 1
"twenty" => 20
"two hundred forty-six" => 246
"seven hundred eighty-three thousand nine hundred and nineteen" => 783919

```
import java.util.HashMap;
import java.util.Map;

public class Parser {
    
    public static int parseInt(String numStr) {
        String[] numArray = numStr.split("[ |-]");
        int number = 0;
        Map<String, Integer> map = new HashMap<String, Integer>();
        map.put("zero", 0);
        map.put("one", 1);
        map.put("two", 2);
        map.put("three", 3);
        map.put("four", 4);
        map.put("five", 5);
        map.put("six", 6);
        map.put("seven", 7);
        map.put("eight", 8);
        map.put("nine", 9);
        map.put("ten", 10);
        map.put("eleven", 11);
        map.put("twelve", 12);
        map.put("thirteen", 13);
        map.put("fourteen", 14);
        map.put("fifteen", 15);
        map.put("sixteen", 16);
        map.put("seventeen", 17);
        map.put("eighteen", 18);
        map.put("nineteen", 19);
        map.put("twenty", 20);
        map.put("thirty", 30);
        map.put("forty", 40);
        map.put("fifty", 50);
        map.put("sixty", 60);
        map.put("seventy", 70);
        map.put("eighty", 80);
        map.put("ninety", 90);
        map.put("hundred", 100);
        map.put("thousand", 1000);
        map.put("million", 1000000);
        
        for (int i = 0; i < numArray.length; i++) {
            for (String key : map.keySet()) {
                if (numArray[i].toLowerCase().equals(key)) {
                    if (map.get(key) == 100) {
                        int temp = number % 100;
                        number -= temp;
                        number += temp * (map.get(key));
                    }
                    else if (map.get(key) > 100)
                        number *= (map.get(key));
                    else
                        number += map.get(key);
                      break;
                }
            }
        }
        return number;
    }
}
```

----------
46

┌───┬───┬───┐
│ 1 │ 2 │ 3 │
├───┼───┼───┤
│ 4 │ 5 │ 6 │
├───┼───┼───┤
│ 7 │ 8 │ 9 │
└───┼───┼───┘
    │ 0 │
    └───┘

"8", {"5", "7", "8", "9", "0"});
"11",{"11", "21", "41", "12", "22", "42", "14", "24", "44"});
"369",{"236", "238", "239", "256", "258", "259", "266", "268", "269", "296"},

```
import java.util.*;

public class ObservedPin {

    private static final Map<Character,String> ADJACENTS = new HashMap<Character,String>() {{
        put('1', "124");
        put('2', "2135");
        put('3', "326");
        put('4', "4157");
        put('5', "54268");
        put('6', "6953");
        put('7', "748");
        put('8', "87590");
        put('9', "986");
        put('0', "08");
    }};

    public static List<String> getPINs(String observed) {
        
        List<String> ans = Arrays.asList("");
        
        for (char c: observed.toCharArray()) {
            
            List<String> tmp = new ArrayList<String>();
            for (char cc: ADJACENTS.get(c).toCharArray()) {
                for (String s: ans) tmp.add(s+cc);
            }
            ans = tmp; 
        }
        return ans;
    }

}
```

----------
47

You have to create a function that takes a positive integer number and returns the next bigger number formed by the same digits:

12 ==> 21
513 ==> 531
2017 ==> 2071
If no bigger number can be composed using those digits, return -1:

9 ==> -1
111 ==> -1
531 ==> -1

观察后发现：如果要满足题意条件，需从最右边开始逐个数字遍历，当发现最右边的数字大于遍历到的数字的时候，从该数字往后到数字结束，升序排序，交换两个数字。即可得结果。若无满足条件，则输出no possilbe.

例如218765，最右边第一个数字是5，当遍历到1时发现1<5。从1往后升序排列剩下的数字，对调两数位置。即可得251678.


```

import java.util.Arrays;
public class Kata
{
    public static long nextBiggerNumber(long n)
    {
      char [] s = String.valueOf(n).toCharArray();
      for(int i = s.length - 2; i >= 0; i--){
         for (int j = s.length-1; j > i; j--){
           if(s[i] < s[j]){
             char tmp = s[i];
             s[i] = s[j];
             s[j] = tmp;
             Arrays.sort(s, i+1, s.length);
             return Long.valueOf(String.valueOf(s));
           }
         }
      }
      return -1;
    }
}
```
----------
60

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

示例 1:

输入: [3,2,3]
输出: 3
示例 2:

输入: [2,2,1,1,1,2,2]
输出: 2

```
import java.util.HashMap;
import java.util.Map;
class Solution {
    public int majorityElement(int[] nums) {
        double n = Math.ceil(nums.length / 2.0);
        Map<Integer, Integer> dict = new HashMap<>(10);
        for (int num : nums) {
            if (dict.get(num) == null) {
                dict.put(num, 1);
            } else {
                dict.put(num, dict.get(num) + 1);
            }
        }
        for (Integer key : dict.keySet()) {
            if (dict.get(key)>= n) {
                return key;
            }
        }
        return -1;
    }
}
```

----------
61

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]

```
class Solution {
    public int[] twoSum(int[] nums, int target) {
    	
    int changeNum;

    int[] result = new int[2];
    	for (int i = 0; i < nums.length - 1; i++) {
    		       changeNum = target - nums[i];
    		          for (int j = i + 1; j < nums.length; j++) {
    		              if (changeNum == nums[j]) {
    		                  result[0]=i;
    		                  result[1]=j;
    		             }
    		        }
    }
		return result;
}
}
```
----------
63

无重复字符的最长子串
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。


```
//滑动窗口法. 定义两个指针，start和end，代表当前窗口的开始和结束位置，同样使用hashset,当窗口中出现重复的字符时，start++,没有重复时，end++,每次更新长度的最大值

public class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        int res = 0;
        int end=0,start=0;
        Set<Character> set=new HashSet<>();
        while(start<n && end<n){
           if(set.contains(s.charAt(end))){
               set.remove(s.charAt(start++));
           }else{
               set.add(s.charAt(end++));
               res=Math.max(res,end-start);
           }
            
        }
        return res;
    }
 
   
}
```
----------
67

**整数反转**

输入: 123
输出: 321

```
    public static int reverse(int x) {
     int INT_MAX =Integer.MAX_VALUE;          //获取int的最大值2147483647
        int INT_MIN =Integer.MIN_VALUE;            //获取int的最小值-2147483648
        if(x>INT_MAX) return 0;
        if(x<INT_MIN) return 0;
        if(x==0) return 0;
     	long newnum=0;
   	while(x!=0){
          newnum=newnum*10+x%10;
          x=x/10;
         }
      if(newnum>INT_MAX||newnum<INT_MIN) return 0;
      return (int) newnum;
    }
```
----------
69

回文数

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

示例 1:

输入: 121
输出: true

利用正则表达式reverse（）方法可以实现判断，即反转后的数字与原先的数字对比，得出结果

```
class Solution {
    public boolean isPalindrome(int x) {
        String res = new StringBuffer(String.valueOf(x)).reverse().toString();
        return res.equals(String.valueOf(x));
    }
}
```
----------
71

整数转罗马数字

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000

```
class Solution {
    public String intToRoman(int num) {
        int[] numArray=new int[]{1000,900,500,400,100,90,50,40,10,9,5,4,1};
        String[] romaArray=new String[]{"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
        StringBuffer sb=new StringBuffer();
        
        if(num<0||num>3999)
            return null;
       for(int i=0;i<numArray.length;i++)
       {
           int temp=num/numArray[i];

           while(temp>0)
           {
               sb.append(romaArray[i]);
               temp--;
           }
            num=num%numArray[i];
       }
          return sb.toString();     
    }
}
```

----------
72

罗马数字转整形
```
public int romanToInt(String s) {
    Map<Character, Integer> lookup = new LinkedHashMap<>();
    lookup.put('M', 1000);
    lookup.put('D', 500);
    lookup.put('C', 100);
    lookup.put('L', 50);
    lookup.put('X', 10);
    lookup.put('V', 5);
    lookup.put('I', 1);
    
    int result = 0;
    int current = 0;
    int next = 0;
    
    for (int i = 0; i < s.length() - 1; i++) {
        current = lookup.get(s.charAt(i));
        next = lookup.get(s.charAt(i + 1));

        if (next > current) {
            result -= current;
        } else {
            result += current;
        }
    }
    result += lookup.get(s.charAt(s.length() - 1));
    return result;
}
```

----------
73

最长公共前缀

输入: ["flower","flow","flight"]
输出: "fl"

```
/*
 *  最开始我的想法是利用双重for循环，对于相邻字符串的每个字符进行比较。例如"flower"和"flow"，
 *  最长公共前缀就是'flo'，利用一个计数器保存公共前缀的长度3；然后比较"flow"和"flight"的最长公共前缀，
 *  长度为2，也用计数器保存。最后在这个计数器数组中找到最小值，就是整个String数组中所有元素的最长公共前缀的长度。
 */
class Solution{
public String longestCommonPrefix(String[] strs) {
    if(strs.length == 0)
        return "";
    if(strs == null ) {
        return null;
    }
    if(strs.length == 1) {
        return strs[0];
    }

    int minLength = Integer.MAX_VALUE;
    for (int i = 0; i < strs.length; i++) {
        if(minLength > strs[i].length()) {
            minLength = strs[i].length();
        }
    }
    if(minLength == 0)
        return "";

    int[] commons = new int[strs.length-1];
    for (int i = 0; i < strs.length-1; i++) {
        for (int j = 0; j < minLength; j++) {
            if(strs[i].charAt(j) == strs[i+1].charAt(j)) {
                commons[i]++;
            }else
                break;
        }
    }

    int longestCommonPrefix = Integer.MAX_VALUE;
    for(int i=0; i<commons.length; i++) {
        if(longestCommonPrefix > commons[i]) {
            longestCommonPrefix = commons[i];
        }
    }

    return strs[0].substring(0, longestCommonPrefix);
}
}
```

----------
74

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组

给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]

我们可以先将原数组从小到大排序，固定其中两个元素 i 和 j，i从前往后走，j从后往前走，i 每往后一个，将 j 重置为数组末尾的下标，在 i 和 j 之间找使nums[i] + nums[j] + nums[k] == 0成立的k。

那么如何去重呢？
每次得出nums[i] + nums[j] + nums[k] == 0成立的i、j、k之后，令 i 往后走，直到nums[i] != nums[i + 1],并令 j 向前走，直到nums[j] != nums[j - 1]。这样就能保证得到的三个数字不会有重复。

双指针法

```
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        //对数组进行排序
        if (nums == null) {
            return null;
        }
        if (nums.length < 3) {
            return new ArrayList<>();
        }
        //对数组nums进行排序
        Arrays.sort(nums);
        HashSet<List<Integer>> set = new HashSet<>();
        for (int i = 0; i < nums.length; i++) {
            int j = i + 1;
            int k = nums.length - 1;
            //数字k要从最大的数字（最后一个向前跑）
            while (j < k) {
                if (nums[i] + nums[j] + nums[k] == 0) {
                    List<Integer> result = new ArrayList<Integer>();
                    result.add(nums[i]);
                    result.add(nums[j]);
                    result.add(nums[k]);
                    set.add(result);
                    while (j < k && nums[j] == nums[j + 1]) {
                        j++;
                    }
                    while (j < k && nums[k] == nums[k-1]) {
                        k--;
                    }
                    j++;
                    k--;
                } else if (nums[i] + nums[j] + nums[k] < 0) {
                    j++;
                } else {
                    k--;
                }
 
            }
 
        }
 
        return new ArrayList<>(set);
 
    }

```

----------
75

最接近的三数之和

(给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数， 使得它们的和与 target 最接近。返回这三个数的和)
例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.
与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).

思路：首先对数组进行排序     Arrays.sort(arr);

将前三个数相加赋给closeNum，表示初始化     int closeNum = arr[0] + arr[1] + arr[2];

在第一层循环中for(int i = 0;i<arr.length;i++)，我们定义双指针就j和k，j指向当前i的下一个元素，k指向末尾元素，计算三数之和并且赋给tmp，int tmp = arr[i]+arr[j]+arr[k];    判断Math.abs(tmp - t) 和 Math.abs(closeNum - t)的大小，前者小，将前者赋给初始变量closeNum；之后判断tmp和目标值t的大小，大于 k--；小于j++，等于 直接返回tmp

```
public static int threeSumClosest(int[] arr,int t) {
        Arrays.sort(arr);
        int closeNum = arr[0] + arr[1] + arr[2];
        for(int i = 0;i<arr.length - 2;i++) {
            int j = i+1;
            int k = arr.length - 1;
            while(j<k) {
                int tmp = arr[i]+arr[j]+arr[k];
                if(Math.abs(tmp - t) < Math.abs(closeNum - t)) {
                    closeNum = tmp;
                }
                if(tmp < t) {
                    j++;
                }else if(tmp > t) {
                    k--;
                }else {
                    return tmp;
                }
            }
        }
        return closeNum;
    }
```
----------

78

有效的括号

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。



1）选择map保存括号之间的对应关系：使用到put,get,containsKey

2）选择stack来匹配对应关系:使用到push,pop,peek,empty方法

```
class Solution {
    public boolean isValid(String s) {
        if(s.length()%2!=0) return false;
        if(s.equals("")) return true;
        Map<Character,Character> map = new HashMap<Character,Character>();
        map.put('(',')');
        map.put('{','}');
        map.put('[',']');
        Stack<Character> stack = new Stack<Character>();
        for(int i=0;i<s.length();i++)
        {
            char c=s.charAt(i);
            if(map.containsKey(c))
            {    
                stack.push(c);
            }
            else
            {
                if(!stack.empty()&&map.get(stack.peek())==c)
                    stack.pop();
                else
                    return false;                
            }
        }
        return stack.empty();
    }
}
```

----------
79

合并两个有序链表

输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4

两个有序链表的排序，实际上可以看成一个单链表使用归并排序的最后一个环节：“将两个排好序的子序列合并为一个子序列：每次都是从未比较的两个子序列的最小值中选出一个更小值”

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;//当前节点的值
 *     ListNode next;//下一个节点的引用值
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode temp=new ListNode(0);
        ListNode head=temp;//保留头节点的引用
        while(l1!=null&&l2!=null){
           if(l1.val<l2.val) 
           {
               temp.next=l1;
               l1=l1.next;
           }   
           else
           {
               temp.next=l2;
               l2=l2.next;
           }
           temp=temp.next;
        }
        if(l1==null)  temp.next=l2;//l1子序列为空，则直接拼届l2
        if(l2==null)  temp.next=l1;
        return head.next;//返回头节点指向的序列
    }
}
```


----------
80

给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。

例如，给出 n = 3，生成结果为：

[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]


递归具体过程：

1.判断剩余左右括号数是否都为0，如果left==0&&right==0，则说明所有括号都放置好了，这时只要把上层递归传递来的已经保存好的括号字符串str添加到list中。即表明一个括号序列已经排好。
    
2.若left>0，即表明还有剩余的左括号能排，这个过程要在原有排好的序列上的添加‘（’，再递归。也是一样。

3.这个过程要做的事其实和2过程差不多，即再原有排好的序列上添加‘）’，再递归。但是有一点区别，即剩余未添加的右括号不能数目必须比剩余左括号的多，所以才要加个判断left>right.

```
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> list=new ArrayList();
        String str=new String();
        generate(list,str,n,n);
        return list;
    }
//list的改动是全局性的，但是str每次传递时并不是将本身传给下面，而是str+‘（’或者str+')'传递，所以下一层的改动并不会影响上一层。
    public void generate(List<String> list,String str,int left,int right){
        if(left==0&&right==0){
            list.add(str);
            return;
        }
        if(left>0){
            generate(list,str+'(',left-1,right);
        }
        if(right>left){
            generate(list,str+')',left,right-1);
        }   
    }
}
```

----------
81

合并 k 个排序链表，返回合并后的排序链表

输入:
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6

所有的数据先读到ArrayList中然后转到数组中，然后排序，然后构建新链表

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ArrayList<Integer> arr=new ArrayList<>();
        for(int i=0;i<lists.length;i++) {
        	ListNode list=lists[i];
        	while(list!=null) {
        		int val=list.val;
        		arr.add(val);
        		list=list.next;
        	}
        	
        }
        int size=arr.size();
        int[] data=new int[size];
        for(int i=0;i<size;i++) {
        	data[i]=arr.get(i);
        }
        Arrays.sort(data);
        ListNode list1=new ListNode(0);
        ListNode list2=list1;
        for(int i=0;i<size;i++) {
        	int m=data[i];
        	ListNode k=new ListNode(1);
        	k.val=m;
        	list1.next=k;
        	list1=list1.next;
        }
        return list2.next;
    }
}
```



----------
82

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

 

示例:

给定 1->2->3->4, 你应该返回 2->1->4->3.



![](TY/62.PNG)
```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode pre=new ListNode(0);
        pre.next=head;
        ListNode temp=pre;
        //考虑链表长度为奇数的情况
        while(temp.next!=null&&temp.next.next!=null){
            ListNode start=temp.next;
            ListNode end=temp.next.next;
            temp.next=end;
            start.next=end.next;
            end.next=start;
            temp=start;
        }
        //返回链表
        return pre.next;
    }
}
```

----------
83

删除排序数组中的重复项

给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2

由于数组是排好序的，如果出现重复元素的话，不需要把这个元素删了，只需要用后面的元素把它覆盖就好了。

可以用两个指针front和back来实现：

如果back与front正好重复了，拉动front，直到back和front不重复为止；

![](TY/36.png)

反之，进行覆盖操作（back + 1就正好是要覆盖的位置）

![](TY/37.png)

```
class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int back = 0;
        for (int front = 1; front < nums.length; front++) {
            if (nums[back] != nums[front]) {
                back++;
                nums[back] = nums[front];
            }
        }
        return back + 1;
    }
}
```

----------
84

给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。

给定 nums = [3,2,2,3], val = 3,

函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2


思路：

使用双指针，一个遍历该数组，一个迭代 !=val 的位置的索引
每次遇到 != val，则将该位置放入j索引，并+1

```
class Solution {
    public int removeElement(int[] nums, int val) {
        int j = 0;
        for(int i = 0; i < nums.length; i++)
        {
            if(nums[i] != val)
                nums[j++] = nums[i];
        }
        return j;
    }
}
```

----------
85

实现 strStr() 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

示例 1:

输入: haystack = "hello", needle = "ll"
输出: 2

这道题最巧妙的就是通过substring和equals来做。我们循环从0到haystack.length()-needle.length()+1，截取haystack里面和needle来做比较

```
class Solution {
    public int strStr(String haystack, String needle) {
        if(needle == null){
            return -1;
        }
        if(needle.length() == 0){
            return 0;
        }
        if(haystack.length()<needle.length()){
           return -1;
        }
        for(int i = 0; i < haystack.length()-needle.length()+1 ; i++){
           String hayStackNeed = haystack.substring(i,i+needle.length());
           if(hayStackNeed.equals(needle)){
               return i;
           }
        }
        return -1;
    }
}
```

----------
86

下一个排列
如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1

```
class Solution {
    //理解题意：即这几个数字所能组成的比当前大的数字的最小的那个
    //从后往前遍历，若遇到第一个下降的数字，该数字的位置记为x,应当和其后面最小的大于它的数进行交换
    //此时x位置后面的数字做升序排列
    //in:132  231 expect:213
    //in:52431   53421 out:53124
    public void nextPermutation(int[] nums) {
        boolean flag = false;
        for(int i=nums.length-2; i >=0; i--){
            if(nums[i] < nums[i+1]){
                int j;
                for(j = nums.length-1; j>i; j--){
                    if(nums[j] > nums[i])
                        break;
                }
                
                int tmp = nums[j];
                nums[j] = nums[i];
                nums[i] = tmp;
                
                Arrays.sort(nums,i+1,nums.length);
                
                flag = true;
                break;
            }
        }
        if(!flag)
            Arrays.sort(nums);
    }
}
```

----------
87

在排序数组中查找元素的第一个和最后一个位置
给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

你的算法时间复杂度必须是 O(log n) 级别。

如果数组中不存在目标值，返回 [-1, -1]。

示例 1:

输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]

思路：看到数组及有序，就应该要想到用二分查找算法。要找一个数的开始位置和结束位置，可以分为两步：

找一个数的开始位置

先用二分查找找到对应的数，将下标先保存着（因为这有可能就是要找的最左边的下标），然后利用right = mid - 1将下标不断的象左边靠近，直到找到那个数的最左边

找一个数的结束位置

先用二分查找找到对应的数，将下标先保存着（因为这有可能就是要找的最右边的下标），然后利用left = mid + 1将下标不断的象右边靠近，直到找到那个数的最右边


```
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] result = {-1, -1};
        result[0] = leftIndex(nums, target);
        result[1] = rightIndex(nums, target);
        return result;
    }
    public static int rightIndex(int[] num, int target)
    {
        int rightPos = -1;
        int left = 0;
        int right = num.length - 1;
        while (left <= right)
        {
            int mid = left+(right-left)/2;
            if (num[mid] > target)
            {
                right = mid - 1;
            }
            else if (num[mid] < target)
            {
                left = mid + 1;
            }
            else
            {
                rightPos = mid;  // 保存下标
                left = mid + 1;  // 往右边靠近
            }
        }
        return rightPos;
    }
    public static int leftIndex(int[] num, int target)
    {
        int leftPos = -1;
        int left = 0;
        int right = num.length-1;
        while (left <= right)
        {
            int mid = left+(right-left)/2; //用来代替mid = (left+right)/2
            if (num[mid] > target)
            {
                right = mid - 1;
            }
            else if (num[mid] < target)
            {
                left = mid + 1;
            }
            else
            {
                leftPos = mid;  // 保存下标
                right = mid-1;  // 往左边靠近
            }
        }
        return leftPos;
    }
}
```

----------
88

搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

示例 1:

输入: [1,3,5,6], 5
输出: 2
示例 2:

输入: [1,3,5,6], 2
输出: 1
示例 3:

输入: [1,3,5,6], 7
输出: 4

比target小就继续向后找，大于或者等于，返回当前下标。

二分查找法

```
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left=0,right=nums.length-1;
	        int mid=-1;
	        while(left<=right){
	            mid=left+(right-left)/2;
	            if(nums[mid]<target){
	                left=mid+1;
	            }else if(nums[mid]>target){
	                right=mid-1;
	            }else{
	                return mid;//找到了则返回下标
	            }
	        }
	        return left;//没找到则返回其位置左边的下标,即为它按顺序插入的位置
	        }
 }
```

----------
95

最大子序和

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6


我对分治法的理解是：每一步找出局部最优解，然后在这些局部最优解中找出一个全局最优解，这个全局最优解就是我们想要的结果。
![](TY/63.PNG)
```
//分冶法
public int maxSubArray(int[] nums) {
        if(nums == null || nums.length == 0){
            return 0;
        }
        int local = nums[0];
        int global = nums[0];
        for(int i=1; i<nums.length; i++){
            local = Math.max(nums[i], local+nums[i]);
            global = Math.max(local, global);
        }
        return global;
    }
```

----------
96

最后一个单词的长度


示例:

输入: "Hello World"
输出: 5

```
class Solution {
    public int lengthOfLastWord(String s) {
        if(s=="")
            return 0;   
        if(s.trim().length()==0)
            return 0;
        String[] a=s.split(" ");
        return a[a.length-1].length();
    }
}
```
----------
98

不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

```
//动态规划
class Solution {
    public int uniquePaths(int m, int n) {
/**

     * 动态规划：我们可以定义二维数组arr，横坐标为m，纵坐标为n
     * 根据题意，我们令arr[0][0] = 1,arr[0][j] = 1,arr[i][0] = 1,其中0<i<m,0<j<n
     * arr[i][j] = arr[i-1][j] + arr[i][j - 1]
     * 最后直接返回二维数组最后一个数组
     */
    //动态规划方法
        if(m == 1 || n == 1) return 1;
        int[][] arr = new int[m][n];
        arr[0][0] = 1;
        for(int i = 1;i<m;i++) {
            for(int j = 1;j<n;j++) {
                if(i - 1 == 0 ) {
                    arr[i - 1][j] = 1;
                }
                if(j - 1 == 0) {
                    arr[i][j - 1] = 1;
                }
                arr[i][j] = arr[i - 1][j] + arr[i][j - 1];
            }
        }
        return arr[m-1][n-1];
    }
    }
```

----------
99

最小路径和

给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

示例:

输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。

使用动态规划的思想解决本题：
	关键是求出递推关系式。对于本题，从原点到达（i, j）的最小路径
	等于 ：原点到达（i-1, j）最小路径与到达（i, j-1）最小路径中
	的最小值。即 dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]。
```
public int minPathSum(int[][] grid) {
        for (int i = 1; i < grid.length; i++){
            grid[i][0] += grid[i - 1][0];
        }
        for (int j = 1; j < grid[0].length; j++){
            grid[0][j] += grid[0][j - 1];
        }

        for (int i = 1; i < grid.length; i++) {
            for (int j = 1; j < grid[i].length; j++) {
                grid[i][j] = Math.min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j];
            }
        }

        return grid[grid.length - 1][grid[0].length - 1];
    }
```

----------
100

给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

示例 1:

输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。

如果digits数组最后一位小于9，则只需要将digits数组最后一个数+1，返回digits数组即可；如果最后一位等于9，则需要设置一个循环进行加法模拟，即对每一位进行判断，小于10退出循环，如果等于10，进位，这种情况则需创建一个新数组，长度为digits长度加一，将数据保存进去即可


```
class Solution {
    public int[] plusOne(int[] digits) {
        int l=digits.length;
        digits[l-1]+=1;
        for(int i=l-1;i>0;i--){
            if(digits[i]==10){
                digits[i]=0;
                digits[i-1]+=1;
            }
            else
                break;
        }
        if(digits[0]==10){
            int[] a=new int[l+1];
            a[0]=1;
            digits[0]=0;
            for(int i=1;i<l+1;i++)
                a[i]=digits[i-1];
            return a;
        }
        return digits;
    }
}
```

----------
101

求平方根

二分法

```
class Solution {
    public int mySqrt(int x) {
        int l=1,r=x;
        int mid=(l+r)/2;
        while(l<=r){
            if(mid==x/mid)
                return mid;
            else if(mid>x/mid)
                r=mid-1;
            else
                l=mid+1;
            mid=(l+r)/2;
        }
        return mid;
    }
}
```

----------
102

爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶

要爬上第n阶台阶，在前一阶时，要么再爬两阶，要么再爬一阶。
把整个爬楼过程直接拆分为爬上第n-1阶和爬上第n-2阶的方法之和，即num[i] = num[i-1]+num[i-2];。
```
//动态规划
class Solution {
   public int climbStairs (int n) {
   int[] num = new int[n+1];
   num[0] = 1;
   num[1] = 1;
   for(int i = 2;i<=n;i++){
    num[i] = num[i-1]+num[i-2];
   }
   return num[n];
   }
}
```

----------
103

编辑距离

给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符
示例 1:

输入: word1 = "horse", word2 = "ros"
输出: 3
解释: 
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')


思路：用 dp[i][j] 表示从 word[0...i] 转换到 word[0...j] 的最小操作，使用动态规划求解

![](TY/38.png)

```

class Solution {
    public int minDistance(String word1, String word2) {
       
        int row = word1.length();
        int col = word2.length();
        
        int[][] dp = new int[row+1][col+1];
        
        //初始化:当word1为空字符串“”时，row=0
        for(int j = 0; j <= col; j++){
            dp[0][j] = j; //操作为：插入字符
        }
        
         //初始化:当word2为空字符串“”时,col=0
        for(int i = 0; i <= row; i++){
            dp[i][0] = i; //操作为：删除字符
        }
        
        for(int i = 1; i <= row ; i++){
            for(int j = 1; j <= col; j++){
                //末尾字符相同，不需要编辑.(对应字符相等，不操作.)(注意下标，dp[][]下标为从1开始，字符串下标从0开始)
                if(word1.charAt(i-1) == word2.charAt(j-1)){//所以要减去1
                     dp[i][j] = dp[i-1][j-1];
                }else{
                    // 末尾字符不同，三种编辑情况，取最小值
                    //需要操作，对应操作分别为：替换，删除，插入
                     dp[i][j] = 1 + Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1]));
                }
               
            }
        }
        
        return dp[row][col];
    }
}
```

----------
104

矩阵置零

给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。

示例 1:

输入: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]


先遍历原矩阵，找出所有值为 0 的元素，记录其行列的值，分别存入对应的 HashSet 中，之后遍历两个HashSet，将记录下来的行和列分别置零。

```

class Solution {
    public void setZeroes(int[][] matrix) {
        HashSet<Integer> rows = new HashSet<>();
        HashSet<Integer> cols = new HashSet<>();
        for(int i = 0; i < matrix.length; i++){
            for(int j = 0; j < matrix[0].length; j++){
                if(matrix[i][j] == 0){
                    rows.add(i);
                    cols.add(j);
                }
            }
        }
        for(int row : rows){
            for(int col = 0; col < matrix[0].length; col++){
                matrix[row][col] = 0;
            }
        }
        for(int col : cols){
            for(int row = 0; row < matrix.length; row++){
                matrix[row][col] = 0;
            }
        }
    }
}

```

----------
105

编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：

每行中的整数从左到右按升序排列。
每行的第一个整数大于前一行的最后一个整数。
示例 1:

输入:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
输出: true

思路：首先应该找到target所在行，通过一行的首尾元素与target的大小关系，确定其所在行数
```
if((matrix[i][0] <= target) && (matrix[i][n - 1] >= target))

```

在确定好行数后，就在一行内采用二分查找算法寻找target

```
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
         if(null == matrix || 0 == matrix.length || 0 == matrix[0].length)
            return false;
        int m = matrix.length;
        int n = matrix[0].length;
        int i;
        for(i = 0; i < m; i++)
        {
            if((matrix[i][0] <= target) && (matrix[i][n - 1] >= target))
                break;
        }
        if(i == m)
            return false;
        if(matrix[i][0] == target || matrix[i][n - 1] == target)
            return true;
        int left = 0;
        int right = n -1;
        int mid = (left + right) / 2;
        while(left <= right)
        {
            if(target == matrix[i][mid])
                return true;
            else if(target < matrix[i][mid])
            {
                right = mid - 1;
                mid = (left + right) / 2;
            }
            else
            {
                left= mid + 1;
                mid = (left + right) / 2;
            }
        }
        return false;    
    }
}
```

----------
106

颜色分类

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

注意:
不能使用代码库中的排序函数来解决这道题。

示例:

输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]

就是荷兰国旗问题，小于1的放在数组左边，等于1的放中间，大于1的放数组右边
三指针

```
class Solution {
    public void sortColors(int[] nums) {
        int p1 = 0;
        int p2 = nums.length-1;
        int i = 0;
        while(i <= p2) {
            if(nums[i] == 0){
                int tmp = nums[p1];
                nums[p1++] = nums[i];
                nums[i++] = tmp;
            }
            else if(nums[i] == 2){
                int tmp = nums[p2];
                nums[p2--] = nums[i];
                nums[i] = tmp;                
            }
            else i++;
        }
    }
}

```

----------
107

组合

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

示例:

输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]

![](TY/39.png)

DFS+回溯法

```
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        List<Integer> tmp = new ArrayList<Integer>();
        dfs(res,tmp,n,k,1);
        return res;
    }
    public void dfs(List<List<Integer>> res, List<Integer> tmp, int n, int k, int m){
        if(k==0){
            res.add(new ArrayList<Integer>(tmp));
            return;
        }
        for(int i=m;i<=n;i++){
            tmp.add(i);
            dfs(res, tmp, n, k-1, i+1);
            tmp.remove(tmp.size()-1);
        }
    }
}
```

----------
108

子集
给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例:

输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

![](TY/64.JPG)
递归+回溯
![](TY/41.png)
注意：输出并不是按照上面那样一层一层输出的，而是深度遍历输出，即：先是null -> 1 -> 1, 2 -> 1, 2, 3 -> 1, 3 2 -> 2, 3 3
这样就很明确了，圈圈圈起来的部分都是有效解，都需要被add进最终的result集合里。

![](TY/40.png)

```
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        if(nums.length==0){
            return result;
        }
        Arrays.sort(nums);
        helper(list, nums, 0, result);
        return result;
    }
    
    public void helper(List<Integer> list, int[] nums, int pos, List<List<Integer>> result) {
        result.add(new ArrayList<Integer>(list));
        //因为java传的是引用，如果直接把list add进去，之后list变化后add进去的对象也会发生变化，这里相当于拍个快照add进去
        for(int i = pos; i < nums.length; i++){
            list.add(nums[i]);
            helper(list, nums, i+1, result);
            list.remove(list.size()-1);
        }
    }
}
```
----------
110

删除排序数组中的重复项 II

给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

示例 1:

给定 nums = [1,1,1,2,2,3],

函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。

```
class Solution {
    public int removeDuplicates(int[] nums) {
        int i = 0;
        for(int n : nums) {
            if (i < 2 || n > nums[i - 2]) {
                nums[i] = n;
                i++;
            }
        }
        return i;
    }
}
```

----------
111

删除排序链表中的重复元素 II

输入: 1->2->3->3->4->4->5
输出: 1->2->5

```
  public static ListNode deleteDuplicates(ListNode head) {
        //baseCase
        if (head == null || head.next == null) {
            return head;
        }

        ListNode next = head.next;
        //如果是这种情况
        //      1 --> 1 --> 1 --> 2 --> 3
        //     head  next
        //1.则需要移动next直到出现与当前head.value不相等的情况（含null）
        //2.并且此时的head已经不能要了，因为已经head是重复的节点
        //--------------else-------------
        //      1 --> 2 --> 3
        //     head  next
        //3.如果没有出现1的情况，则递归返回的节点就作为head的子节点
        if (head.value == next.value) {
            //1
            while (next != null && head.value == next.value) {
                next = next.next;
            }
            //2
            head = deleteDuplicates(next);
        } else {
            //3
            head.next = deleteDuplicates(next);
        }
        return head;
    }
```

----------
112

删除排序链表中的重复元素

示例 1:

输入: 1->1->2
输出: 1->2

```
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode p = head;
        while(p != null && p.next != null){
            if(p.val == p.next.val){
                ListNode q = p.next;
                p.next = p.next.next;
                q = null;
            }
            else p = p.next;
        }
        return head;
    }
}
```

----------
113

分隔链表

给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。

你应当保留两个分区中每个节点的初始相对位置。

示例:

输入: head = 1->4->3->2->5->2, x = 3
输出: 1->2->2->4->3->5

解题思路
1:创建两个临时头结点，我这里命名为 less_head 和 more_head,再创建两个节点,less_ptr和more_ptr，分别指向less_head和more_head，用于在链表上移动
2:遍历链表，使用判断条件,如何链表中数据域数值小于x，则把该节点链接到less_head的后面，同理如果大于或等于，则链接到more_head后面
3:就是一些，节点的移动，比如说，(1)原链表的head 要指向head的下一个节点，(2)less_ptr 和 more_ptr指向链接后的节点。
————————————————
![](TY/42.png)

```

public ListNode partition(ListNode head, int x) {
        ListNode less_head = new ListNode(0);    // 创建一个less_head 节点
        ListNode more_head = new ListNode(0);    // 创建一个more_head 节点
        ListNode less_ptr = less_head;    // less_ptr 节点指向 less_head
        ListNode more_ptr = more_head;    // 同理
        while (head != null){// 遍历原链表
            if (head.val < x){ // 判断 原链表的值与x值得大小
                less_ptr.next = head;//将 节点链接在less_ptr 后面
                less_ptr = head;// less_ptr指向链接后的节点
            }
            else {
                more_ptr.next = head;
                more_ptr = head;
            }
            head = head.next; // head向后移动
        }
        // 将 分段后的链表串联起来
        less_ptr.next = more_head.next;
        more_ptr.next = null; // 最后一个节点的next至为空
        return less_head.next;
    }
```

----------
114

合并两个有序数组

给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 num1 成为一个有序数组。

 

说明:

初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
 

示例:

输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]

首先需要创建一个新的数组res，同时遍历nums1和nums2两个数组，将两个数组中较小的元素赋给res，直至某个数组遍历完，接着将另一个未遍历完数组的剩余元素依次赋给res
```
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int []res = new int[m+n];
        int i=0,j=0,cnt=0;
        //遍历两个数组，将较小的值依次赋给res数组
        while(i<m&&j<n){
            if(nums1[i]<nums2[j])
                res[cnt++] = nums1[i++];
            else
                res[cnt++] = nums2[j++];
         }
         //将未遍历完的数组的剩余元素赋给res数组
        if(i>=m)
            while(j<n) res[cnt++] = nums2[j++];    
        if(j>=n)
            while(i<m) res[cnt++] = nums1[i++];    
         //由于要返回的是nums1数组，所以需要将res数组的值赋给nums1 
        for(i=0;i<res.length;i++){         
            nums1[i] = res[i];
        }
    }
}
```
----------
115

子集 II

输入: [1,2,2]
输出:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]

回溯

和I不同的是，本题的数组，可以有重复元素。我们可以用下面两行代码过滤重复元素。

while(i+1<nums.length && nums[i] == nums[i+1])
                i++;

这就要求我们重复元素是连续出现的，即数组是有序的。所以在第一次调用helper()时，我们要先将数组排序。

```
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<List<Integer>> res = new ArrayList<List<Integer> >();
        List<Integer> tmp = new ArrayList<Integer>();
        //空集是任意集合的子集
        res.add(tmp);
        if(nums.length == 0)
            return res;
        Arrays.sort(nums);//[4,4,4,1,4]
        helper(nums, 0, tmp, res);
        return res;
    }
    public void helper(int[] nums, int start, List<Integer> tmp, List<List<Integer>> res){
        for(int i=start; i<nums.length; i++){
            tmp.add(nums[i]);
            helper(nums, i+1, tmp, res);
            res.add(new ArrayList<Integer>(tmp));
            tmp.remove(tmp.size()-1 );
            while(i+1<nums.length && nums[i] == nums[i+1])
                i++;
        }
    }
}
```

----------
117

二叉树的中序遍历


```
class Solution {
     public static List<Integer> res;
 
    public List<Integer> inorderTraversal(TreeNode root) {
        res = new ArrayList<>();
        dfs(root);
        return res;
    }
 
    public void dfs(TreeNode root) {
        if (root == null) return;
        dfs(root.left);
        res.add(root.val);
        dfs(root.right);
    }
}
```

----------
118

相同的树

给定两个二叉树，编写一个函数来检验它们是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

示例 1:

输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true
示例 2:

输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: fals


用队列的方法

```
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        Queue<TreeNode> queue=new LinkedList<>();
        queue.add(p);
        queue.add(q);//两个树的节点进队列
        while(!queue.isEmpty()){
            TreeNode f=queue.poll();//出队列，如果队列头为空，返回null
            TreeNode s=queue.poll();
            if(f==null&&s==null) continue;
            else if(f == null || s == null || f.val != s.val) return false;
            queue.add(f.left);
            queue.add(s.left);
            queue.add(f.right);
            queue.add(s.right);
        }
        return true;
    }
}
```

----------
119

对称二叉树

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3

```
class Solution {
      public boolean isSymmetric(TreeNode root) {
        if (root == null) return true;
        return dfs(root.left, root.right);
    }
 
    public boolean dfs(TreeNode l, TreeNode r) {
        if (l == null && r == null) return true;
        if (l != null && r != null && l.val == r.val) {
            return dfs(l.left, r.right) && dfs(l.right, r.left);
        }
        return false;
    }
}
```

----------
120

二叉树的层次遍历

给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。

例如:
给定二叉树: [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]

利用队列先进先出。
```
public List<List<Integer>> levelOrder(TreeNode root) {
    if(root == null)
        return new ArrayList<>();
    List<List<Integer>> res = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.add(root);
    while(!queue.isEmpty()){
        int count = queue.size();
        List<Integer> list = new ArrayList<Integer>();
        while(count > 0){
            TreeNode node = queue.poll();
            list.add(node.val);
            if(node.left != null)
                queue.add(node.left);
            if(node.right != null)
                queue.add(node.right);
            count--;
        }
        res.add(list);
    }
    return res;
}
```

----------
121

二叉树的最大深度

递归

```
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        return Integer.max(maxDepth(root.left),maxDepth(root.right)) + 1;
    }
}
```

----------
123

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

例如：
给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其自底向上的层次遍历为：

[
  [15,7],
  [9,20],
  [3]
]

result List 由ArrayList改为LinkedList
这样可以使用添加到头部的方法

```
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        
        List<List<Integer>> result = new LinkedList<List<Integer>>();
        List<Integer> temList = new ArrayList<Integer>();
        if (root == null) {
            return result;
        }
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        ((LinkedList<TreeNode>) queue).add(root);
        int num = 1;
        int next = 0;
        while (!queue.isEmpty()) {
            TreeNode now = queue.poll();
            temList.add(now.val);
            num--;
            if (now.left != null) {
                ((LinkedList<TreeNode>) queue).add(now.left);
                next++;
            }
            if (now.right != null) {
                ((LinkedList<TreeNode>) queue).add(now.right);
                next++;
            }
            if (num == 0) {
                num = next;
                next = 0;
                ((LinkedList<List<Integer>>) result).addFirst(temList);
                temList = new ArrayList<Integer>();
            }
        }
        return result;
    
    }
}
```

----------
125

平衡二叉树

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7
返回 true 。


二叉树深度
----------
```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        if(root==null) return true;
        if(Math.abs(Depth(root.left)-Depth(root.right))>1) return false;
        else return isBalanced(root.left)&&isBalanced(root.right);
    } 
    private int Depth(TreeNode root){//求深度
        if(root==null) return 0;
        return Math.max(Depth(root.left),Depth(root.right))+1;
    }
}
```

----------
126

二叉树的最小深度

给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回它的最小深度  2.

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {
        if(root==null) return 0;
        if(root.left==null) return minDepth(root.right)+1;//如果没有左子树，那么整个树的最小深度就是右子树的最小深度加1
        if(root.right==null) return minDepth(root.left)+1;//如果没有右子树，那么整个树的最小深度就是左子树的最小深度加1
        return Math.min(minDepth(root.right),minDepth(root.left))+1;//当左右子树都有时，就取左右子数最小深度值较小的那个加1
    }
}

```

----------
127

路径总和


给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。

```
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root==null){
            return false;
        }
        if(root.left==null&&root.right==null){
            if(root.val==sum)
                return true;
            return false;
        
        }
        boolean result = true;
        result = hasPathSum(root.left,sum-root.val);
        if(result==true){
            return result;
        }
        result = hasPathSum(root.right,sum-root.val);
        if(result==true){
            return result;
        }
        return false;
        
    }
}
```

----------
128
二叉树展开为链表

例如，给定二叉树

    1
   / \
  2   5
 / \   \
3   4   6
将其展开为：

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6

```
 public void flatten(TreeNode root) {
        if (root == null) return;
        if (root.left == null && root.right == null) return;
        //如果右子树为空左子树不为空
        if (root.left != null && root.right == null) {
            root.right = root.left;
            root.left = null;
        }
        //如果右子树不为空左子树为空对右子树进行递归
        if (root.left == null && root.right != null) {
            flatten(root.right);
            return;
        }
        //如果左右子树都不为空左右子树分别递归 递归完把左子树加进到右子树中
        if (root.left != null && root.right != null) {
            flatten(root.left);
            flatten(root.right);
            TreeNode left = root.left;
            TreeNode right = root.right;
            root.right = left;
            while (left.right != null) {
                left = left.right;
            }
            left.right = right;
            root.left = null;
        }
 
    }
```
----------
130

买卖股票的最佳时机
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

示例 1:

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。


求后面的数减前面的数的最大差值，顺序遍历数组，如果遇到更小的数，就更新最小值minn，依次判断prices[i]-minn的值，更新maxx。

贪心算法

```
class Solution {
    public int maxProfit(int[] prices) {
        int len=prices.length;
        if(len==0) return 0;
        int minn=prices[0];
        int maxx=0;
        for(int i=1;i<len;i++){
            if(prices[i]>minn&&prices[i]-minn>maxx){
                maxx=prices[i]-minn;
            }
            if(prices[i]<=minn){
                minn=prices[i];
            }
        }
        return maxx;
    }
}
```

----------
133

定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。

例如，从根到叶子节点路径 1->2->3 代表数字 123。

计算从根到叶子节点生成的所有数字之和。

说明: 叶子节点是指没有子节点的节点。

示例 1:

输入: [1,2,3]
    1
   / \
  2   3
输出: 25
解释:
从根到叶子节点路径 1->2 代表数字 12.
从根到叶子节点路径 1->3 代表数字 13.
因此，数字总和 = 12 + 13 = 25.

其实就是个 前序遍历题 而已。

要点如下：

在到达叶子结点时，才将此路径积累成的数字返回。
到达非叶子节点时，加上当前非叶子结点的值之后递归左右子树。

```
class Solution {
    
    int res = 0;
    public int sumNumbers(TreeNode root) {
        sumNumbers(root, 0);
        return res;
    }
    
    private void sumNumbers(TreeNode node, int num) {
        if(node == null) return;
        
        num = num * 10 + node.val;
        if(node.left == null && node.right == null) {
            res += num;
        }
        
        sumNumbers(node.left, num);
        sumNumbers(node.right, num);
    }
}
```

----------
134

给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。

返回 s 所有可能的分割方案。

示例:

输入: "aab"
输出:
[
  ["aa","b"],
  ["a","a","b"]
]

用回溯法，进行dfs，即可。

```
​
class Solution {
    public List<List<String>> partition(String s) {
        List<List<String>> res = new ArrayList<>();
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= i; j++) {
                if (s.charAt(i) == s.charAt(j) && (i - j < 2 || dp[j + 1][i - 1])) dp[j][i] = true;
            }
        }
        dfs(res, dp, 0, n, s, new ArrayList<String>());
        return res;
 
    }
 
    private void dfs(List<List<String>> res, boolean[][] dp, int i, int n, String s, ArrayList<String> tmp) {
        if (i == n) res.add(new ArrayList<>(tmp));
        for (int j = i; j < n; j++) {
            if (dp[i][j]) {
                tmp.add(s.substring(i, j + 1));
                dfs(res, dp, j + 1, n, s, tmp);
                tmp.remove(tmp.size() - 1);
            }
        }
    }
}
 
```

----------
135

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1

二进制算法
```
class Solution {
    public static int singleNumber(int[] nums) {
        int num = 0;
        for (int i = 0; i < nums.length; i++) {
            num = num ^ nums[i];
        }
        return num;
    }
}
```

----------
136

给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。
示例 1：

输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。

```
public class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        int n=s.length();
        boolean[] dp=new boolean[n+1];
        dp[0]=true;
        for (int i=1;i<=n;i++){
            for (int j = 0; j <i ; j++) {
                if (dp[j]&&wordDict.contains(s.substring(j,i))){
                    dp[i]=true;
                    break;
                }
            }
        }
        return dp[n];
 
    }
}
```

----------
137

给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

 

示例 1：

输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。


双指针

```
 
//一快一慢指针，若有环，必然在某个地方相遇
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast=head;
        ListNode slow=head;
        while(fast!=null &&  fast.next!=null ){
             slow=slow.next;
             fast=fast.next.next; 
            if(slow==fast)return true;
        }
        return false;
    }
}
```

----------
139

二叉树的前序遍历

输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [1,2,3]


```
//递归算法
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list=new ArrayList<>();
        if(root==null) return list;
        recursion(root,list);
        return list;
    }   
    public void recursion(TreeNode root,List<Integer> list){
        if(root==null) return;
        else{
            list.add(root.val);
            recursion(root.left,list);
            recursion(root.right,list);
        }
    }
}
```
----------
139

在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。

示例 1:

输入: 4->2->1->3
输出: 1->2->3->4
示例 2:

输入: -1->5->3->4->0
输出: -1->0->3->4->5


```
class Solution {
    public ListNode sortList(ListNode head) {
        if(head == null || head.next == null) {
            return head;
        }
        ListNode mid = getMiddle(head);
        ListNode node = mid.next;
        //将链表分成两半，那么第一个链表的尾部就应该指向null
        mid.next = null;
        return mergeTwoLists(sortList(head), sortList(node));
    }
    
    //利用快慢指针来找到中间节点
    public ListNode getMiddle(ListNode head) {
        ListNode slow = head, fast = head;
        while(fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
    
    //合并两个有序链表
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode node = dummy;
        if(l1 == null) {
            return l2;
        } else if(l2 == null) {
            return l1;
        } else if(l1 == null && l2 == null) {
            return null;
        }
        
        while(l1 != null && l2 != null) {
            if(l1.val > l2.val) {
                node.next = l2;
                node=l2;
                l2 = l2.next;
            } else {
                node.next = l1;
                node = l1;
                l1 = l1.next;
            }
        }
        
        if(l1 != null) {
            node.next = l1;
        }
        if(l2 != null) {
            node.next = l2;
        }
        
        return dummy.next;
    }
}
```

----------
140

逆波兰表达式求值

示例 1：

输入: ["2", "1", "+", "3", "*"]
输出: 9
解释: ((2 + 1) * 3) = 9

```
class Solution {
    public int evalRPN(String[] tokens) {
        
        Stack<Integer> stack=new Stack<Integer>();
        int num1=0,num2=0;
        for (int i = 0; i < tokens.length; i++) {
			String s=tokens[i];
        	if(s.equals("+")){
        		num1=stack.pop();
        		num2=stack.pop();
        		stack.push(num2+num1);
        	}else if(s.equals("-")){
        		num1=stack.pop();
        		num2=stack.pop();
        		stack.push(num2-num1);
        	}else if(s.equals("*")){
        		num1=stack.pop();
        		num2=stack.pop();
        		stack.push(num2*num1);
        	}else if(s.equals("/")){
        		num1=stack.pop();
        		num2=stack.pop();
        		stack.push(num2/num1);
        	}else{
        		stack.push(Integer.parseInt(s));
        	}
		}
        return stack.pop();
    
    }
}
```

----------
141

乘积最大子序列

给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。

示例 1:

输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。

本题是求最大乘积，是最大子段和的变种。最大乘积可以由正数*正数和负数*负数得到，因此，需要同时记录下最大值和最小值。

状态转移方程：

dp[i] = max(maxm*nums[i],minm*nums[i],dp[i-1])

maxm = max(maxm*nums[i],minm*nums[i],nums[i])

minm = min(maxm*nums[i],minm*nums[i],nums[i])

其中，dp[i]表示前i个数中的最大乘积，maxm表示以第i-1个字符结尾的最大乘积,minm表示以第i-1个字符结尾的最小乘积,nums[i]即为第i个数。


```
class Solution {
    public int maxProduct(int[] nums) {
        if (nums == null || nums.length == 0) return 0;
        int maxP = nums[0], minN = nums[0], dp = nums[0];
        for (int i = 1; i < nums.length; i++) {
            int locMax = nums[i] * maxP, locMin = nums[i] * minN;
            maxP = Math.max(nums[i], Math.max(locMax, locMin));
            minN = Math.min(nums[i], Math.min(locMax, locMin));
            dp = Math.max(dp, maxP);
        }
        return dp;
    }
}
```

----------
142

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

请找出其中最小的元素。

你可以假设数组中不存在重复元素。

示例 1:

输入: [3,4,5,1,2]
输出: 1


```
//二分法
class Solution {
    public int findMin(int[] nums) {
        int len = nums.length;
        return findMin1(nums, 0, len - 1);
        
    }
    public int findMin1(int[] nums,int start,int end) {
        if(nums[start] <= nums[end]) //如果没有乱序，则第一个即为最小值
            return nums[start];
        if(start == end - 1) //只有两个数的时候
            return Math.min(nums[start], nums[end]);
        int mid = (start + end)/2;
        if(nums[mid] > nums[start]) //因为分为两部分，一部分有序，一部分无序，最小值在无序部分
        {
            return findMin1(nums, mid,end);
        }
        else{
            return findMin1(nums, start, mid);
        }
    }
}
```

----------
143

寻找峰值

示例 1:

输入: nums = [1,2,3,1]
输出: 2
解释: 3 是峰值元素，你的函数应该返回其索引 2。

```
//二分法

class Solution {
    public int findPeakElement(int[] nums) {
        if (nums.length == 1)
            return 0;
        if (nums[0] > nums[1])
            return 0; // 因为nums[-1]为负无穷，此时nums[0]满足
        if (nums[nums.length - 1] > nums[nums.length - 2])
            return nums.length - 1; // 因为nums[nums.length]为负无穷，此时nums[length-1]满足
        int l = 1, r = nums.length - 2; //因为已经判断了nums[0]和nums[length-1]是否满足，所以缩小范围防止溢出
        return find(nums, l, r);
    }

    public int find(int[] nums, int l, int r) {
        if(l >= r)
            return r;
        int mid = (l + r)/ 2;
        if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1])
            return mid;
        if (nums[mid] < nums[mid - 1])
            return find(nums, l, mid - 1);
        else
            return find(nums, mid + 1, r);
    }
}
```

----------
145

两数之和 II - 输入有序数组

给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

说明:

返回的下标值（index1 和 index2）不是从零开始的。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
示例:

输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 

```
public int[] twoSum(int[] numbers, int target) {
    int i = 0;
    int j = numbers.length - 1;
    while(i < j){//在两头判断，效率更高
        if(numbers[i] + numbers[j] > target){
            j--;
        }else if(numbers[i] + numbers[j] < target){
            i++;
        }else{
            return new int[]{i+1 , j + 1};
        }
    }
    return new int [] {-1,-1};
}
```

----------
146

多数元素

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

示例 1:

输入: [3,2,3]
输出: 3
示例 2:

输入: [2,2,1,1,1,2,2]
输出: 2

同样先排序，若存在多数元素，则至少有连续n/2+1这么多元素值相等
即nums[i] == nums[i+nums.length/2]

Java数组长度方法variate.length返回的是int类型
```
class Solution {
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        for(int i = 0; i <= nums.length/2; i++){
            if(nums[i] == nums[i+nums.length/2]){
                return nums[i];
            }
        }
        return 0;
    }
}
```

----------
148

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]

思路：
将数组前部1，2，3，4反转为4，3，2，1
将数组后部5，6，7反转为7，6，5
将数组整体反转
这个思路好处就是切割了，如果采用最傻的方法无非就是把数组看成一个循环数组，然后进行循环移动，这样如果做优化的话比较复杂，考虑情况比较多，那么此方法将数组进行分割，相当于去除了“循环”的复杂性。


```
class Solution {
    public void rotate(int[] nums, int k) {
        if(nums==null||nums.length<=1||k<=0){
            return;
        }

        int n = nums.length;
        k %= n;
        reverse(nums,0,n-k-1);
        reverse(nums,n-k,nums.length-1);
        reverse(nums,0,nums.length-1);

    }

    public void reverse(int[] nums,int start, int end){
        int temp;
        int len = (end-start+1)/2;
        for(int i = 0;i < len;i++){
            temp = nums[end-i];
            nums[end-i] = nums[start+i];
            nums[start+i] = temp;
        }
    }
}
```

----------
149

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:

输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

很简单的一个动态规划的问题，假设dp[i]是截止到nums[i]为止能抢到的最多的钱，那么它要么是抢nums[i]，要么不抢。如果抢，那就是dp[i-2] + nums[i]，如果不抢，那就是dp[i-1]，二者取最大值。观察到dp[i]只和前两个状态有关，所以空间上可以优化成常数。

```
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) return 0;    
        if (nums.length == 1) return nums[0];
        int dp1 = nums[0];
        int dp2 = Math.max(dp1, nums[1]);
        int dp = dp2;
        for (int i = 2; i < nums.length; i++) {
            dp = Math.max(dp1 + nums[i], dp2);
            dp1 = dp2;
            dp2 = dp;
        }
        return dp;
    }
}
```

----------
150

二叉树的右视图

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

示例:

输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---



```
//这道题的本质就是获取每层最右边的元素，可以用当前遍历深度和结果集的大小作为限定条件，当当前深度还没有添加元素时，优先遍历最右的元素并添加，添加后遍历本层其他元素也不影响结果集中的值
class Solution {
    
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        getRightNode(root,res,0);
        return res;
    }
    
    //每层取最右边的元素
    private void getRightNode(TreeNode root,List<Integer> res,int depth){
        if(root == null) return;
        if(depth == res.size()){
            res.add(root.val);
        }
        //优先遍历右边
        getRightNode(root.right,res,depth+1);
        getRightNode(root.left,res,depth+1);
    }
}
```

----------

152

删除链表中等于给定值 val 的所有节点。

示例:

输入: 1->2->6->3->4->5->6, val = 6
输出: 1->2->3->4->5

思路：

此处要将给定元素val全部删除

1.链表判空

2.定义虚拟头结点root，用于存储删除元素后的链表，最终返回root.next即可

3.定义指针cur，从root开始用于遍历root所存储的链表，cur其实也算是root的尾指针

4.head后移，直到head为空为止

5.在4循环中，如果head当前节点的值不等于指定值val，将该节点尾插法到root下；否则跳过该节点

6.为了避免cur与原链表还有关联，将cur的下一跳制空

7.返回root.next即为删除元素后的链表

```

class Solution {
    public ListNode removeElements(ListNode head, int val) {
  
        if(head==null){
            return null;
        }
      
        ListNode root=new ListNode(0);
        ListNode cur=root;
      
        while(head!=null){
            //5.
            if(head.val!=val){
                cur.next=head;
                cur=cur.next;
            }
            head=head.next;
        }
        //6.
        cur.next=null;
        //7.
        return root.next;
    }
}
```

----------
153

统计所有小于非负整数 n 的质数的数量。

示例:

输入: 10
输出: 4
解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。

筛法
```
//筛子的核心是for循环里的continue.
class Solution {
    public int countPrimes(int n) { 
        boolean[] isPrime = new boolean[n];
        int result = 0;
        
        for (int i = 2; i < n; i++) {
            isPrime[i] = true; //先初始化为true   
        }
        
        for (int i = 2; i * i < n; i++) { //这一次for循环找出所有不是素数的数（也就是说被筛掉了）
            if (!isPrime[i]) {
                //既然已经被筛掉了就不用管了
                continue;
            }
            else {
                for (int j = i * i; j < n; j += i) {
                    //由于i现在是一个质数, 那么i的平方一定不是质数，i^2 + i; i^2 + 2i也一定不是素数
                    isPrime[j] = false;
                }                
            }
        } //所有不是质数的数已经全部筛掉
       
        //计算剩余的质数个数
        for (int i = 2; i < n; i++) {
            if (isPrime[i] == true) {
                result++;
            }
        }
        return result;
    }
   
}
```

----------
154


反转一个单链表。

示例:

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL

```
//递归
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) return head; //处理最小输入的情况，即空链表和单节点链表
        ListNode second = head.next; //将即将被调用的下一个节点分离，即将下一个调用的输入存在second里
        ListNode reverseHead = reverseList(second); //将调用后的结果存储，这个结果就是最终结果。之后利用递归，调用刚才存好的输入
        second.next = head; //上面一步的调用已经完成以second为首的链表的反转，所以现在second变成了反转完成后的尾节点
                            //把这个尾节点的next指向一开始输入的前驱，即head，完成整个链表反转
        head.next = null; //最开始的头节点要变成尾节点，即在后面补null使链表终结
        return reverseHead; 
    }
}
```

----------
156
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:

输入: [2,3,2]
输出: 3
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。


temp + nums[i] //temp为前i-2项的最大项

temp = max //max为前i-1项的最大项

max = Math.max(temp + nums[i],temp = max);//即从（前i-2项最大值与第i项的和）与（前i-1项最大值）中取最大值

```
class Solution {
    public int rob(int[] nums) {
        int temp = 0;
        int max = 0;
        int temp1 = 0;
        int max1 = 0;
        int firstIsGet;
        if(nums.length == 1)
            return nums[0];
        for(int i = 0;i < nums.length - 1;i++)
        {
            max = Math.max(temp + nums[i],temp = max);
        }
        for(int i = 1;i < nums.length;i++)
        {
            max1 = Math.max(temp1 + nums[i],temp1 = max1);
        }
        return Math.max(max,max1);
    }
}
```

----------
157

在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

示例 1:

输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
示例 2:

输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4

```
public int findKthLargest(int[] nums, int k) {
    Arrays.sort(nums);
    return nums[nums.length - k];
}
```

----------
158

给定一个整数数组，判断是否存在重复元素。

如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。

示例 1:

输入: [1,2,3,1]
输出: true


```
class Solution {
    public boolean containsDuplicate(int[] nums) {
        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();
        for(int i=0;i<nums.length;i++){
            if(map.containsKey(nums[i])){//这个数已经出现过一次
                return true;
            }
            else{
               map.put(nums[i],i); 
            }           
        }
        return false;
    }
}
```


----------
159

存在重复元素 II

给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。

示例 1:

输入: nums = [1,2,3,1], k = 3
输出: true

```
class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();
        for(int i=0;i<nums.length;i++){
            if(map.containsKey(nums[i])){
                if(i-map.get(nums[i])<=k){//获取map中键值为“key”的value
                    return true;
                }
            }
            map.put(nums[i],i);
        }
        return false;        
    }
}
```

----------
161

翻转二叉树

翻转一棵二叉树。

示例：

输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9
输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1


这道题算是一道递归的基础题目，其实就是3个步骤：

等于null的时候的返回；
左右交换。
递归调用左树和右树

```
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null){
            return root;
        }
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
}
```

----------
162

给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。

说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。

示例 1:

输入: [3,2,3]
输出: [3]

题目没有说是否空数组 因此可以返回空数组
同（求众数的思路）题的思路使用map< Integer，Interger > = （ 元素， 出现次数）
出现 n/3 次也算

```
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        int len = nums.length;
        List<Integer> list = new ArrayList<>();
        if(len<1) {
            return list;
        }
        Map<Integer,Integer> map = new HashMap<>();
        Integer size = 0;
        for(int i = 0; i < len; i++){
            size = map.get(nums[i]);
            if(size==null){
                map.put(nums[i],1);
            }else{
                map.put(nums[i],size+1);
            }
        }
        int flag = len/3;
        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<Integer, Integer> entry = it.next();
            if(entry.getValue()> flag){
                list.add(entry.getKey());
            }
        }

        return list;
    }
}
```

----------
164

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”


思路：利用二叉搜索树的特性，如果当前节点的值比p和q的值都大，那么需要找的节点在左儿子的分支里面，相反当前节点的值比p和q的值都小，则在右分支，其他情况则当前节点的值遇到相等或者在p和q之间，则返回当前节点。

```
	public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //当前节点的值比p和q的值都大
        if(root.val>p.val&&root.val>q.val) return lowestCommonAncestor(root.left, p, q);
        if(root.val<p.val&&root.val<q.val) return lowestCommonAncestor(root.right, p, q);
        //其他情况  root.val在p和q之间的时候
        return root;
    }
```

----------
165

删除链表中的节点

示例 1:

输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.

```

class Solution {
    public void deleteNode(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }
}
```

----------
166

给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。

 

示例:

输入: [1,2,3,4]
输出: [24,12,8,6]


思路：每一个数除了它本身所有数的乘积都是他左边数的乘积乘以右边数的乘积。

```
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[] res = new int[nums.length];
        int k = 1;
        for(int i = 0; i < res.length; i++){
            res[i] = k;
            k = k * nums[i]; // 此时数组存储的是除去当前元素左边的元素乘积
        }
        k = 1;
        for(int i = res.length - 1; i >= 0; i--){
            res[i] *= k; // k为该数右边的乘积。
            k *= nums[i]; // 此时数组等于左边的 * 该数右边的。
        }
        return res;
    }
}

```

----------
168

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1:

输入: s = "anagram", t = "nagaram"
输出: true
示例 2:

输入: s = "rat", t = "car"
输出: false

```
//线排序
    public boolean isAnagram(String s, String t) {
        char[] sChar = s.toCharArray();
        char[] tChar = t.toCharArray();
        Arrays.sort(sChar);
        Arrays.sort(tChar);
        if(sChar.length != tChar.length){
            return false;
        }
        for (int i = 0; i < sChar.length; i++) {
            if(sChar[i] == tChar[i]){
                continue;
            }else {
                return false;
            }
        }
        return true;
    }
```

----------

171

编写一个程序判断给定的数是否为丑数。

丑数就是只包含质因数 2, 3, 5 的正整数。

示例 1:

输入: 6
输出: true
解释: 6 = 2 × 3
示例 2:

输入: 8
输出: true
解释: 8 = 2 × 2 × 2

这个数如果能被2整除，就一直除；如果能被3整除，就一直除；如果能被5整除，就一直除，得到最后的值如果等于1就是丑数。

```
class Solution {
    public boolean isUgly(int num) {
        if(num < 1){
            return false;
        while(num%2 == 0){
            num = num/2;
        }
        while(num%3 == 0){
            num = num/3;
        }
        while(num%5 == 0){
            num = num/5;
        }
        return num==1;
    }
}
```

----------
172

编写一个程序，找出第 n 个丑数。

丑数就是只包含质因数 2, 3, 5 的正整数。

示例:

输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。

```
//三指针法
class Solution {
    public int nthUglyNumber(int n) {
        List<Integer> list=new ArrayList<>();
        list.add(1);
        int p2=0,p3=0,p5=0;
        while(list.size()<n){
            int num2=list.get(p2)*2;
            int num3=list.get(p3)*3;
            int num5=list.get(p5)*5;
            int min=Math.min(Math.min(num2,num3),num5);
            if(num2==min)
                p2++;
            if(num3==min)
                p3++;
            if(num5==min)
                p5++;
            list.add(min);
        }
        return list.get(n-1);
    }
}

```

----------
173

给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。

h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）至多有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）”

 

示例:

输入: citations = [3,0,6,1,5]
输出: 3 
解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。
     由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。
 

说明: 如果 h 有多种可能的值，h 指数是其中最大的那个。

```
class Solution {
    public int hIndex(int[] citations) {
        int l=citations.length;
        Arrays.sort(citations);//对数组排序
        int count=0;
        for(int i=l-1;i>=0;i--){//从后向前找
            if(citations[i]<=count) return count;
            count++;           
        }
    return count;
    }
}
```

----------
175

你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

示例:

给定 n = 5，并且 version = 4 是第一个错误的版本。

调用 isBadVersion(3) -> false
调用 isBadVersion(5) -> true
调用 isBadVersion(4) -> true

所以，4 是第一个错误的版本

```

public class Solution extends VersionControl {//二分查找
    public int firstBadVersion(int n) {
        int tag=1;//当前位置
        if(n==0){
            return 0;
        }
        while (tag<=n){
            int mid=tag+(n-tag)/2;
            if(isBadVersion(mid)){//是错误的版本（true）
                n=mid-1;
            }else{                
                tag=mid+1;
            }    
        }
        return tag;
    }   
}
```

----------
177

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

输入: [0,1,0,3,12]
输出: [1,3,12,0,0]

count来记录不为0的数字的个数，遍历数组，每找到一个不为0 的数字，就把该数字放在数组最前面，用下标 j 来接收。当遍历完成后，把数组从下标count开始的数字全部设为0
```
class Solution {
    public void moveZeroes(int[] nums) {
        int count = 0;
        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            if(nums[i] != 0 ){
                nums[j++] = nums[i];
                count++;
            }
        }
        for (int i = count; i < nums.length; i++) {
            nums[i] = 0;
        }
    }
}
```

----------
178

给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

示例 1:

输入: [1,3,4,2,2]
输出: 2
示例 2:

输入: [3,1,3,4,2]
输出: 3

```
//双指针
class Solution {
    public int findDuplicate(int[] nums) {
        if(nums.length==0) return 0;
        Arrays.sort(nums);
        int i=0,j=nums.length-1;       
        int result=0;
        while(i<j){
            if(nums[i]==nums[i+1]){
                result=nums[i];
                break;
            } 
            else i++;
            if(nums[j]==nums[j-1]){
                result=nums[j];
                break;
            }
            else j--;
        }
        return result;
    }
}
```

----------
179

给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:

输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。


dp[i]表示以i为结尾的最长上升序列的长度 ，要和dp[i]+1进行比较，j在0-（i-1）的范围

![](TY/46.png)

```
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length==0||nums.length==1){
            return nums.length;
        }
        int[]dp=new int[nums.length];
        int LIS=1;
        dp[0]=1;
        for(int i=1;i<dp.length;i++){
            dp[i]=1;
            for(int j=0;j<i;j++){
                if(nums[i]>nums[j]&& dp[i]<dp[j]+1){
                    dp[i]=dp[j]+1;
                }
                if(dp[i]>LIS)
                    LIS=dp[i];
            }
        }
        return LIS;
    }
}
```
----------

184

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

示例 1:

输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1


![](TY/47.png)


![](TY/48.png)


![](TY/49.png)
```
class Solution {

    public static int coinChange(int[] coins, int amount) {
        int max = 100000000;    // 一亿
        int dp[] = new int[amount + 1];
        for (int i = 0; i < dp.length; i++) {
            dp[i] = max;
        }
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int j = 0; j < coins.length; j++) {
                if (coins[j] <= i) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        if (dp[amount] > amount) {
            return -1;
        } else {
            return dp[amount];
        }
    }
}
```

----------