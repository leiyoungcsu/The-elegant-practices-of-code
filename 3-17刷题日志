331

唯一摩尔斯密码词
国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: "a" 对应 ".-", "b" 对应 "-...", "c" 对应 "-.-.", 等等。

为了方便，所有26个英文字母对应摩尔斯密码表如下：

[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，"cab" 可以写成 "-.-..--..."，(即 "-.-." + "-..." + ".-"字符串的结合)。我们将这样一个连接过程称作单词翻译。

返回我们可以获得所有词不同单词翻译的数量。

例如:
输入: words = ["gin", "zen", "gig", "msg"]
输出: 2
解释: 
各单词翻译如下:
"gin" -> "--...-."
"zen" -> "--...-."
"gig" -> "--...--."
"msg" -> "--...--."

共有 2 种不同翻译, "--...-." 和 "--...--.".

```
class Solution {
    public int uniqueMorseRepresentations(String[] words) {
String[] codes={".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};
		HashSet<String> set=new HashSet<String>();
		for (String word : words) {
			StringBuilder sb=new StringBuilder("");
			for(int i=0;i<word.length();i++){
				sb.append(codes[word.charAt(i)-97]);
			}
			set.add(sb.toString());
		}
		return set.size();
    }
}
```
----------
336

最常见的单词
给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。题目保证至少有一个词不在禁用列表中，而且答案唯一。

禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。

 

示例：

输入: 
paragraph = "Bob hit a ball, the hit BALL flew far after it was hit."
banned = ["hit"]
输出: "ball"
解释: 
"hit" 出现了3次，但它是一个禁用的单词。
"ball" 出现了2次 (同时没有其他单词出现2次)，所以它是段落里出现次数最多的，且不在禁用列表中的单词。 
注意，所有这些单词在段落里不区分大小写，标点符号需要忽略（即使是紧挨着单词也忽略， 比如 "ball,"）， 
"hit"不是最终的答案，虽然它出现次数更多，但它在禁用单词列表中。

```
class Solution {
    public String mostCommonWord(String paragraph, String[] banned) {
        Map<String,Integer> map=new HashMap<>();
        Set<String> set=new HashSet<>();
        List<String> list=split(paragraph);//把paragraph中的每个单词分割出来，放入List容器
        String max_word=new String();
        int max_count=0;
        for(String s:banned){//将banned单词都放入集合中，便于查找paragraph中是否包含banned单词
            set.add(s);
        }
        for(String s:list){
            String temp=s.toLowerCase();//记得转小写
            if(!set.contains(temp)){
                int count=map.getOrDefault(temp,0)+1;
                map.put(temp,count);
                if(count>max_count){
                    max_count=count;
                    max_word=temp;
                }
            }
        }
        return max_word;
    }
    public List<String> split(String str){//分割单词
        Set<Character> set=new HashSet<>();
        List<String> list=new ArrayList<>();
        set.add(' ');
        set.add('!');
        set.add('?');
        set.add('\'');
        set.add(',' );
        set.add(';');
        set.add('.');
        int len=str.length();
        int i=0,j=0;
        while(i<len){
            while(i<len&&set.contains(str.charAt(i)))i++;
            j=i;
            StringBuilder sb=new StringBuilder();
            while(j<len&&!set.contains(str.charAt(j))){
                sb.append(str.charAt(j));
                j++;
            }
            i=j;
            if(sb.length()!=0)
                list.add(sb.toString());
        }
        return list;
    }
}
```

----------
338

山羊拉丁文
给定一个由空格分割单词的句子 S。每个单词只包含大写或小写字母。

我们要将句子转换为 “Goat Latin”（一种类似于 猪拉丁文 - Pig Latin 的虚构语言）。

山羊拉丁文的规则如下：

如果单词以元音开头（a, e, i, o, u），在单词后添加"ma"。
例如，单词"apple"变为"applema"。

如果单词以辅音字母开头（即非元音字母），移除第一个字符并将它放到末尾，之后再添加"ma"。
例如，单词"goat"变为"oatgma"。

根据单词在句子中的索引，在单词最后添加与索引相同数量的字母'a'，索引从1开始。
例如，在第一个单词后添加"a"，在第二个单词后添加"aa"，以此类推。
返回将 S 转换为山羊拉丁文后的句子。

示例 1:

输入: "I speak Goat Latin"
输出: "Imaa peaksmaaa oatGmaaaa atinLmaaaaa"

```
class Solution {
    public String toGoatLatin(String S) {
        Set<Character> vowel = new HashSet();
        for (char c: new char[]{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'})
            vowel.add(c);

        int t = 1;
        StringBuilder ans = new StringBuilder();
        for (String word: S.split(" ")) {
            char first = word.charAt(0);
            if (vowel.contains(first)) {
                ans.append(word);
            } else {
                ans.append(word.substring(1));
                ans.append(word.substring(0, 1));
            }
            ans.append("ma");
            for (int i = 0; i < t; i++)
                ans.append("a");
            t++;
            ans.append(" ");
        }

        ans.deleteCharAt(ans.length() - 1);
        return ans.toString();
    }
```
----------
342

比较含退格的字符串
给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。

 

示例 1：

输入：S = "ab#c", T = "ad#c"
输出：true
解释：S 和 T 都会变成 “ac”。
示例 2：

输入：S = "ab##", T = "c#d#"
输出：true
解释：S 和 T 都会变成 “”。

分析：
1）字符串string S转换为字符串数组char[]后再存入栈中，若存入栈的过程中 遇到‘#'，则弹出栈顶元素，最后返回，得到栈stackA；同理，可得到栈stackB。

2）比较两个栈的size，相等则可能存在栈内元素一致；

然后出栈，若每次出栈的元素一样，一直出栈直到都为空，则两个栈完全一致。从而判断为true。

```
class Solution {
    public boolean backspaceCompare(String S, String T) {
         Stack<Character> stackA = getStack(S.toCharArray());
         Stack<Character> stackB = getStack(T.toCharArray());
 
         if(stackA.size() != stackB.size())
             return false;
 
         while(!stackA.isEmpty() && !stackB.isEmpty())
             if(stackA.pop() != stackB.pop())//一次pop一个出来
                 return false;
 
 
         return stackA.isEmpty() && stackB.isEmpty();//最后两个都为空的话，就为real；
     }
 
      static private Stack<Character> getStack(char[] S)
     {
         Stack<Character> stack = new Stack<>();
 
         for(int i = 0 ; i < S.length ;i++)
         {
             Character letter = S[i];
 
             if(letter != '#')//如果letter != '#'，则压栈
                 stack.push(letter);
             else if(!stack.isEmpty())
                 stack.pop();//pop栈顶元素
         }
 
         return stack;
     }
 
}
 ```

----------
343

山脉数组的峰顶索引
我们把符合下列属性的数组 A 称作山脉：

A.length >= 3
存在 0 < i < A.length - 1 使得A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]
给定一个确定为山脉的数组，返回任何满足 A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1] 的 i 的值。

 

示例 1：

输入：[0,1,0]
输出：1
示例 2：

输入：[0,2,1,0]
输出：1
```
//二分查找

class Solution {
    public int peakIndexInMountainArray(int[] A) {
        int left=0;
        int right=A.length-1;
        while(left<=right)
        {
            int mid=(left+right)/2;
            if(A[mid]>A[mid-1]&&A[mid]>A[mid+1])
            {
                return mid;
            }else if(A[mid]>A[mid-1]&&A[mid]<A[mid+1])
            {
                left=mid+1;
            }else
            {
                right=mid-1;
            }
        }
        return -1;
    }
}
```

----------
344

括号的分数
给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：

() 得 1 分。
AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。
(A) 得 2 * A 分，其中 A 是平衡括号字符串。
 

示例 1：

输入： "()"
输出： 1
示例 2：

输入： "(())"
输出： 2
示例 3：

输入： "()()"
输出： 2

用栈的思想来做，还是非常快的，思想是这样的，你根据题目的意思每次都算出一个结果，然后压入栈，这样栈里就有了2种情况的字符串，“（”、数字的结果；注意，我们不会吧“）”压入栈的，因为直接计算数据结果就好那么你就可以根据这2种情况进行编程了：

判断在字符串里的是不是左括号“（”，如果是左括号，那么就直接压入栈
如果是右括号“）”，那么你就需要，判断栈顶的元素是什么。（1） 如果是“（”，那么你就弹出它，然后压入“1”；
（2）如果是数字的话，那么你就做把数字弹出，乘以2，然后再压入。

这步最关键，如果栈里面的元素有多个数字的情况，那么你就需要吧这几个数字进行相加，然后再压入栈。
最后的结果就是栈里面只剩下了一个数字。那就是你想要的结果了！！！

```
public int scoreOfParentheses(String S) {
    Stack<String> stack = new Stack<>();
    for (int i = 0, len = S.length(); i < len; ++i) {
        if ('(' == S.charAt(i)) {
            stack.push("(");
        } else {
            if ("(".equals(stack.peek())) {
                stack.pop();
                stack.push(1 + "");
//               数字
            } else {
                int intTemp = Integer.parseInt(stack.pop());
                if ("(".equals(stack.peek())) {
                    stack.pop();
                    stack.push( (intTemp * 2) + "");
                }
            }
//          如果栈里面的元素有多个数字的情况，那么你就需要吧这几个数字进行相加，然后再压入栈
            int tempAdd = 0;
            while (!stack.isEmpty() &&  !"(".equals(stack.peek())) {
                tempAdd += Integer.parseInt(stack.pop());
            }
            stack.push(tempAdd + "");
        }
    }
    return Integer.parseInt(stack.pop());
}
```

----------
345

亲密字符串
给定两个由小写字母构成的字符串 A 和 B ，只要我们可以通过交换 A 中的两个字母得到与 B 相等的结果，就返回 true ；否则返回 false 。

 

示例 1：

输入： A = "ab", B = "ba"
输出： true
示例 2：

输入： A = "ab", B = "ab"
输出： false
示例 3:

输入： A = "aa", B = "aa"
输出： true


大的分类分为三种情形：

（1）两个字符串长度不相等，结果肯定为false

（2）两个字符串长度相等，但是字符串长度小于2，结果为false

（3）字符串长度相等且其长度大于等于2，又分为以下几种情况：

声明一个计数器变量cnt，两个记录索引位置的变量：index1和index2。遍历字符串，只要两个字符串中的字符不等，计数器就加1，index1记录字符串中第一次出现字符不等的位置，index2记录两个字符串中第二次出现字符不等的位置。

若cnt>2，则表示不能只通过交换一次字母达到两个字符串相等的目的，所以最终返回false

cnt为1，同样不能通过交换一次字母达到两个字符串相等的目的，返回false

cnt=0，查看字符串中是否出现重复的字母，如果有字母出现不止一次，则可以通过交换一次字母使得两字符串相等。声明一个map类型的变量，遍历字符串，如果当前字符串中的字符已经在map中出现过，则返回true，反之将其存到map中，若字符串遍历结束，map中无重复字符，则返回false

cnt=2，如果A[index1]!=B[index2]或B[index1]!=A[index2]，则返回false，其他情况返回true

```
class Solution {
    public boolean buddyStrings(String A, String B) {
        int len1=A.length();
        int len2=B.length();
        if(len1!=len2){
            return false;
        }
        if(len1<2){
            return false;
        }
        int cnt=0;
        int index1=0,index2=0;
        for(int i=0;i<len1;++i){
            if(A.charAt(i)!=B.charAt(i)){
                cnt++;
                if(cnt>2){
                    return false;
                }
                if(cnt==1){
                    index1=i;
                }
                else{
                    index2=i;
                }
            }
        }
        if(cnt==1){
            return false;
        }
        Map<String,Integer> map=new HashMap<String,Integer>();
        if(cnt==0){
            for(int i=0;i<len1;++i){
                String temp=A.substring(i,i+1);
                if(map.containsKey(temp)){
                    return true;
                }
                map.put(temp,i);
            }
            return false;
        }
        //cnt=2
        if(A.charAt(index1)!=B.charAt(index2)||B.charAt(index1)!=A.charAt(index2)){
            return false;
        }
        return true;
    }
}
```

----------
346

柠檬水找零
在柠檬水摊上，每一杯柠檬水的售价为 5 美元。

顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。

注意，一开始你手头没有任何零钱。

如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

示例 1：

输入：[5,5,5,10,20]
输出：true
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。
示例 2：

输入：[5,5,10]
输出：true



如果第一份账单不为5元，则肯定不能找零，返回false。
之后的账单若为10元，则判断是否有5元的，若没有，则也不能找零，返回false，
否则，5元的剩余数fiveCount自减，10元的余额数自增。
若账单为20元，则找零有这两种情况，即5,5,5或10,5.若两种情况都可采用，优先选择10,5找零（因为5元既可以找10元的订单，又可以找20元的订单，尽量保留）。
若这两种情况都不存在，则不能找零，返回false。当最后账单执行完，则成功全部找零，返回true。

```
class Solution {
    public boolean lemonadeChange(int[] bills) {
        if(bills[0] !=5){   //第一份账单不为5元，则不能找零，false
        	return false;
        }
        else{
			//通过Map形成映射，记录自己手中的钱
        	Map<Integer, Integer> myMoney = new HashMap<Integer, Integer>(); 

        	int fiveCount=1,tenCount=0;//定义5,10的张数,因为最大为20元，所以20元不能用来找零
        	myMoney.put(5, fiveCount);    //初始化
        	myMoney.put(10, tenCount);
        	int length = bills.length;  //订单长度
        	for(int i =1;i<length;i++){
        		if(bills[i] == 5){  //如果为五元，则不需找零
        			fiveCount++;
        			myMoney.put(5, fiveCount);
        		}
        		else if(bills[i] == 10){  //如果为10元，则去查看是否有5元进行找零，若无，则返回false
        			if(myMoney.get(5) == 0){  //没有5元的情况
        				return false;
        			}
        			else{  //有5元，则fiveCount自减，tenCount自增
        				fiveCount--;
        				tenCount++;
        				myMoney.put(5, fiveCount);
        				myMoney.put(10, tenCount);
        			}
        		}
        		else{  //如果为20元的情况,则需找零15元，有两种找零的情况，即10,5或者5,5,5
        			if(myMoney.get(5) == 0 ){  //若没有5元，则false
        				return false;
        			}
        			else if(myMoney.get(10) != 0 ){  //有既有5元，又有10元
        				tenCount--;
        				fiveCount--;
        				myMoney.put(5, fiveCount);
        				myMoney.put(10, tenCount);
        			}
        			else{  //没有10元，只有5元
        				if(myMoney.get(5) >=3){  //5元的张数大于等于3，则可以找零,否则不能找零

        					fiveCount -= 3;
        					myMoney.put(5, fiveCount);
        				}
        				else{
        					return false;
        				}
        			}
        		}
        	}
        	return true;  //若整个账单bills执行，则true
        }
    }
}
```

----------
348

重新排序得到 2 的幂
给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。

如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。

 

示例 1：

输入：1
输出：true
示例 2：

输入：10
输出：false
示例 3：

输入：16
输出：true

在10^9次方以内，只有32个数是2的幂 （分别位2^0, 2^1,...2^31）


```
    public boolean reorderedPowerOf2(int N) {
        String[] rec ={"1","2","4","8","16","23","46","128","256","125","0124","0248","0469","1289","13468",
                       "23678","35566","011237","122446","224588","0145678","0122579","0134449","0368888",
                       "11266777","23334455","01466788","112234778","234455668","012356789","0112344778"};
        char[] at = String.valueOf(N).toCharArray();
        Arrays.sort(at);
        String str = new String(at);
        for(String p:rec){
            if(str.equals(p)) return true;
        }
        return false;
    }
```

----------
349

链表的中间结点
给定一个带有头结点 head 的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

 

示例 1：

输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
示例 2：

输入：[1,2,3,4,5,6]
输出：此列表中的结点 4 (序列化形式：[4,5,6])

由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。


```
//两个指针，一个快指针，一个慢指针，快指针走两步，慢指针走一步，快指针走到尾部，慢指针到达中间
class Solution {
    public ListNode middleNode(ListNode head) {
       if(head==null || head.next==null) 
          return head;
       ListNode slow=head;
       ListNode fast=head;
       while(fast!=null && fast.next!=null){
          fast=fast.next.next;
          slow=slow.next;
       }
       return slow;
  
       }
    }
```

----------
350

两句话中的不常见单词
给定两个句子 A 和 B 。 （句子是一串由空格分隔的单词。每个单词仅由小写字母组成。）

如果一个单词在其中一个句子中只出现一次，在另一个句子中却没有出现，那么这个单词就是不常见的。

返回所有不常用单词的列表。

您可以按任何顺序返回列表。

 

示例 1：

输入：A = "this apple is sweet", B = "this apple is sour"
输出：["sweet","sour"]
示例 2：

输入：A = "apple apple", B = "banana"
输出：["banana"]

将两个句子用一个空格连接起来，加空格是为了防止第一个句子的最后一个单词与第二个句子的第一个单词连在一起。
将新句子通过空格拆分为一个字符串数组。
将字符串数组中的单词添加到Set中，将出现一次以上的单词添加到List中。
删除Set中在List出现的单词。
将Set转为字符串数组，并返回。

```
class Solution {
    public String[] uncommonFromSentences(String A, String B) {
        if (A == null && B == null) {
            return new String[]{};
        }
        String str = A + " " + B; //连接两个句子，中间加上空格
        String[] arr = str.trim().split(" ");
        HashSet<String> set = new HashSet<>();
        LinkedList<String> list = new LinkedList<>(); //用以存放出现一次以上的单词
        for (String s : arr) {
            if (!list.contains(s)) {
                boolean flag = set.add(s);
                if (!flag) {
                    list.add(s);
                }
            }
        }
        //删除出现一次以上的单词
        for (String s : list) {
            set.remove(s);
        }
        return set.toArray(new String[]{});
    }
}
```

----------
351

鸡蛋掉落
你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。

每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。

你的目标是确切地知道 F 的值是多少。

无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？

![](TY/58.PNG)

示例 1：

输入：K = 1, N = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
如果它没碎，那么我们肯定知道 F = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。

dp[k][m] 的含义是k个鸡蛋 移动m次最多能够确定多少楼层
这个角度思考
dp[k][m] 最多能够确定的楼层数为L
那么我选定第一个扔的楼层之后，我要么碎，要么不碎
这就是把L分成3段
左边是碎的那段 长度是dp[k][m - 1]
右边是没碎的那段 长度是dp[k-1][m - 1] 因为已经碎了一个了
中间是我选定扔的楼层 是1
所以递推公式是
dp[k][m] = dp[k - 1][m - 1] + dp[k][m - 1] + 1


```
class Solution {
    public int superEggDrop(int K, int N) {

        int[] dp = new int[K+1]; //int型会自动初始化为0
        int m = 0;
        while (dp[K]<N){
            m++;
            for (int i = K; i >= 1; i--)
            {
                dp[i] = dp[i] + dp[i-1] +1;
            }
        }
        return m;
    }
}
```

----------
354

卡牌分组
给定一副牌，每张牌上都写着一个整数。

此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：

每组都有 X 张牌。
组内所有的牌上都写着相同的整数。
仅当你可选的 X >= 2 时返回 true。

 

示例 1：

输入：[1,2,3,4,4,3,2,1]
输出：true
解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]
示例 2：

输入：[1,1,1,2,2,2,3,3]
输出：false
解释：没有满足要求的分组。

使用Map来统计每张牌上数字出现的次数，求所有出现次数的最大公约数，如果最大公约数大于等于2，则返回 true
```
class Solution {
    public boolean hasGroupsSizeX(int[] deck) {

        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        for(int i : deck) map.put(i, map.getOrDefault(i,0)+1);
        int minSize = Integer.MAX_VALUE;
        for(int i : map.values()) minSize = Math.min(minSize, i);
        int i = 2;
        boolean res = false;
        while(i <= minSize && !res) {
            boolean sign = true;
            for(int x : map.values()) {
                if(x % i != 0) {
                    sign = false;
                    break;
                }
            }
            if(sign) return true;
            i++;
        }
        return false;
    }
}
```

----------
355

仅仅反转字母
给定一个字符串 S，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。

 

示例 1：

输入："ab-cd"
输出："dc-ba"
示例 2：

输入："a-bC-dEf-ghIj"
输出："j-Ih-gfE-dCba"

思路:把字母拿出来反转,再遍历原字符串,碰到字母用反转后的数组,碰到非字母用原数组

```
    class Solution {
        public String reverseOnlyLetters(String S) {
             char[] chars = S.toCharArray();
            char[] zm = new char[S.length()];
            int j=0;
            for (int i = chars.length-1; i > -1; i--) {
                if ((chars[i]<=90&&chars[i]>=65)||(chars[i]<=122&&chars[i]>=97)){
                    zm[j]=chars[i];
                    j++;
                }
            }
            j=0;
            StringBuilder builder = new StringBuilder();
            for (int i = 0; i < chars.le356ngth; i++) {
                if ((chars[i]<=90&&chars[i]>=65)||(chars[i]<=122&&chars[i]>=97)){
 
                    builder.append(zm[j]);
                    j++;
                }else {
                    builder.append(chars[i]);
                }
            }
            return builder.toString();
        }
    }
```

----------

357

长按键入
你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。

你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。

 

示例 1：

输入：name = "alex", typed = "aaleex"
输出：true
解释：'alex' 中的 'a' 和 'e' 被长按。

![](TY/66.PNG)
```
pclass Solution {
    public boolean isLongPressedName(String name, String typed) {
        for(int i = 0, j=0; i < name.length(); ){
            if(j >= typed.length()){
                return false;
            }
            if(name.charAt(i) == typed.charAt(j)){
                i++;
                j++;
            }else if(i >= 1 && name.charAt(i - 1) == typed.charAt(j)) {
                j++;
            }else{
                return false;
            }
        }
        return true;
    }
}

```

----------

358

将字符串翻转到单调递增
如果一个由 '0' 和 '1' 组成的字符串，是以一些 '0'（可能没有 '0'）后面跟着一些 '1'（也可能没有 '1'）的形式组成的，那么该字符串是单调递增的。

我们给出一个由字符 '0' 和 '1' 组成的字符串 S，我们可以将任何 '0' 翻转为 '1' 或者将 '1' 翻转为 '0'。

返回使 S 单调递增的最小翻转次数。

 

示例 1：

输入："00110"
输出：1
解释：我们翻转最后一位得到 00111.
示例 2：

输入："010110"
输出：2
解释：我们翻转得到 011111，或者是 000111。
示例 3：

输入："00011000"
输出：2
解释：我们翻转得到 00000000。


dp[i]表示前i个字符所需最小翻转次数，则dp[i+1]有如下四种情况，取其最小值即可
1、第i+1个字符为0，且不翻转，d[i+1]=前i个字符中1的个数
2、第i+1个字符为0，且翻转，d[i+1]=d[i]+1
3、第i+1个字符为1，且不翻转，d[i+1]=d[i]
4、第i+1个字符为1，且翻转，d[i+1]=前i个字符中1的个数+1
其中1的个数可以在遍历S的时候记录下来。代码如下


```
    public static int minFlipsMonoIncr(String S) {
        int numOfOne = 0;
        int len = S.length();
        int[] dp = new int[len];
        for (int i = 0; i < len; i++) {
            if (S.charAt(i) == '1') {
                dp[i] = (i == 0 ? 0 : Math.min(dp[i - 1], numOfOne + 1));
                numOfOne++;                
            } else {
                dp[i] = (i == 0 ? 0 : Math.min(dp[i - 1] + 1, numOfOne));
            }

        }
        return dp[len -1];
    }

```

----------

360

漂亮数组
对于某些固定的 N，如果数组 A 是整数 1, 2, ..., N 组成的排列，使得：

对于每个 i < j，都不存在 k 满足 i < k < j 使得 A[k] * 2 = A[i] + A[j]。

那么数组 A 是漂亮数组。

 

给定 N，返回任意漂亮数组 A（保证存在一个）。

 

示例 1：

输入：4
输出：[2,1,4,3]

示例 2：

输入：5
输出：[3,1,2,5,4]

假如我们已经得到了两个漂亮数组，分别由[1,2,...N/2]  和 [1,2,....(N+1)/2] 构成（这里没有指定漂亮数组内的排列顺序）

那么我们只需要将第一个漂亮数组[1,2,...N/2] 乘以2，将第二个漂亮数组[1,2,....(N+1)/2]乘以2再减1，就得到了完整的漂亮数组。

为什么呢？

因为左边的数组乘以2之后都是偶数了，右边的数组乘以2再减1之后都是奇数。而且这两个数组仍然是漂亮数组。

(A[k]−1)∗2 = A[k]∗2−2 ≠ ( A[i]−1 + A[j]−1)

A[k]∗2∗2 ≠ (A[i] + A[j])∗2 =A[i]∗2 + A[j]∗2 
那么拼接之后仍然是漂亮数组，因为左边奇数，右边偶数，左边的数加右边的数必定为奇数。

A左 + A右 = 奇数 ≠ 2*A[k] = 偶数

因此递归即可。递归终止条件为N=1，返回数组 new int[]{1}即可

```
class Solution {
 
    public int[] beautifulArray(int N) {
        
        if(N==1){
            return new int[]{1};
        }
        
        int[] even = beautifulArray(N/2);//[1-N]中的偶数构成的漂亮数组
        int[] odd = beautifulArray((N+1)/2);//[1-N]中的奇数构成的漂亮数组
        
        int[] beautiful = new int[N];
        for(int i = 0;i<even.length;i++){
            beautiful[i] = even[i]*2;
        } 
        for(int i = 0;i<odd.length;i++){
            beautiful[i+even.length] = odd[i]*2-1;
        } 
        return beautiful;
    }
 
}
```

----------
361

有效的山脉数组
给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。

让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：

A.length >= 3
在 0 < i < A.length - 1 条件下，存在 i 使得：
A[0] < A[1] < ... A[i-1] < A[i]
A[i] > A[i+1] > ... > A[B.length - 1]
 

示例 1：

输入：[2,1]
输出：false
示例 2：

输入：[3,5,5]
输出：false
示例 3：

输入：[0,3,2,1]
输出：true

设置两个指针：left和right；这样就可以同时从两端遍历数组，直到找到left等于right的位置，否则输出false
```
class Solution {
    public boolean validMountainArray(int[] A) {
        if(A.length<3)
            return false;
        int left=0,right=A.length-1;
        while(left<A.length-2 && A[left]<A[left+1])
            left++;
        while(right>1 && A[right-1]>A[right])
            right--;
        return left == right;
    }
}
```

----------
362

给定数字能组成的最大时间
给定一个由 4 位数字组成的数组，返回可以设置的符合 24 小时制的最大时间。

最小的 24 小时制时间是 00:00，而最大的是 23:59。从 00:00 （午夜）开始算起，过得越久，时间越大。

以长度为 5 的字符串返回答案。如果不能确定有效时间，则返回空字符串。

 

示例 1：

输入：[1,2,3,4]
输出："23:41"
示例 2：

输入：[5,5,5,5]
输出：""

在遍历过程中，我们使用A[i]来记录小时的第一位，其实我们可以知道，如果第一位大于2了，那接下来的 j 和 k 就不需要遍历了。
同样的，如果第一位是2，第二位的 j 大于3,，那接下来的k也不需要遍历了
第三位如果大于5，也同样可以跳过这一步。所以，可以将算法改进，添加几个条件来减少运行时间。

```
class Solution {
    public String largestTimeFromDigits(int[] A) {
        Arrays.sort(A);//先给数组排序，倒着遍历，这样第一个合法的数据一定是最大值
        for(int i = 3;i>=0;i--){
            if(A[i]>2) continue;
            for(int j = 3;j>=0;j--){
                if(j==i||A[i]==2&&A[j]>3) continue;
                for(int k =3;k>=0;k--){
                    if(k==i||k==j||A[k]>5)  continue;
                    return ""+A[i]+A[j]+":"+A[k]+A[6-i-j-k];
                }
            }
        }
        return "";
    }
}
```

----------
363

重复 N 次的元素
在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。

返回重复了 N 次的那个元素。

 

示例 1：

输入：[1,2,3,3]
输出：3
示例 2：

输入：[2,1,2,5,3,2]
输出：2
示例 3：

输入：[5,1,5,2,5,3,5,4]
输出：5

```
class Solution {
    public int repeatedNTimes(int[] A) {
        Set<Integer> set=new HashSet<>();
        int result=0;
        for(int x:A)
        {
            if(set.contains(x))
            {
                result=x;
                break;
            }else
            {
                set.add(x);
            }
        }
        return result;
    }
}
```

----------
364

1、找到n个饼中最⼤的那个。
2、把这个最⼤的饼移到最底下。
3、递归调⽤	pancakeSort(A,n-1)。 base case：	n==1时，排序	1个饼时不需要翻转。 那么，最后剩下个问题，如何设法将某块烧饼翻到最后呢？ 

其实很简单，比如第3块饼是最大的，我们想把它换到最后，也就是换到第n	块。可以这样操作：

1、⽤锅铲将前	3块饼翻转⼀下，这样最⼤的饼就翻到了最上面。
2、⽤锅铲将前	n块饼全部翻转，这样最⼤的饼就翻到了第n块，也就是最后一块。

先遍历一遍，找到最大的数，把最大的数翻转到首位，然后再翻转到末位，每个数字都是这样遍历。
```
class Solution {
    public static List<Integer> pancakeSort(int[] A) {
    	List<Integer> list = new ArrayList<Integer>();
        if(A == null || A.length == 0) return list;
        for(int i = 0, max = A.length; i < A.length; i++, max--) {
            for(int j = 0; j < max; j++) {
                if(A[j] == max) {
                    reverse(A, j);
                    reverse(A, max - 1);
                    list.add(j + 1);
                    list.add(max);
                    break;
                }
            }
        }
        return list;
    }
    public static void reverse(int[]A,int end) {
    	for(int i=0;i<(end+1)/2;i++) {
    		int t=A[i];
    		A[i]=A[end-i];
    		A[end-i]=t;
    	}
    }
}

```

----------
365
强整数
给定两个正整数 x 和 y，如果某一整数等于 x^i + y^j，其中整数 i >= 0 且 j >= 0，那么我们认为该整数是一个强整数。

返回值小于或等于 bound 的所有强整数组成的列表。

你可以按任何顺序返回答案。在你的回答中，每个值最多出现一次。

 

示例 1：

输入：x = 2, y = 3, bound = 10
输出：[2,3,4,5,7,9,10]
解释： 
2 = 2^0 + 3^0
3 = 2^1 + 3^0
4 = 2^0 + 3^1
5 = 2^1 + 3^1
7 = 2^2 + 3^1
9 = 2^3 + 3^0
10 = 2^0 + 3^2
示例 2：

输入：x = 3, y = 5, bound = 15
输出：[2,4,6,8,10,14]

```
class Solution {
    public List<Integer> powerfulIntegers(int x, int y, int bound) {
        Set<Integer> set = new HashSet();
        
        for(int i = 0; i <= bound; i++){
            int tmp = (int)Math.pow(x, i);
            if(tmp > bound){
                break;
            }
            for(int j = 0; j <= bound; j++){
                int temp = tmp + (int)Math.pow(y, j);
                if(temp > bound){
                    break;
                }
                
                set.add(temp);
            }
            
        }
        return new ArrayList(set);
    }
}
```

----------
366

坏了的计算器
在显示着数字的坏计算器上，我们可以执行以下两种操作：

双倍（Double）：将显示屏上的数字乘 2；
递减（Decrement）：将显示屏上的数字减 1 。
最初，计算器显示数字 X。

返回显示数字 Y 所需的最小操作数。

 

示例 1：

输入：X = 2, Y = 3
输出：2
解释：先进行双倍运算，然后再进行递减运算 {2 -> 4 -> 3}.
示例 2：

输入：X = 5, Y = 8
输出：2
解释：先递减，再双倍 {5 -> 4 -> 8}.

```
//反着写
//只需要取余来看下Y值奇偶的两种情况就可以了。
class Solution {
        public int brokenCalc(int X, int Y) {
            if (X>=Y) {
                return X-Y;
            }
            // X < Y

            if(Y%2==0){
                return 1+brokenCalc(X,Y/2);
            }else {
                
                return 1+brokenCalc(X,Y+1);
            }

            
        }
    }
```

----------
367

查找常用字符
给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。

你可以按任意顺序返回答案。

 

示例 1：

输入：["bella","label","roller"]
输出：["e","l","l"]
示例 2：

输入：["cool","lock","cook"]
输出：["c","o"]


```
class Solution {
    public List<String> commonChars(String[] A) {
        Map<Character,Integer> map=new HashMap<>();
        for(char c:A[0].toCharArray()){
            map.put(c,map.getOrDefault(c,0)+1);
        }
        
        for(int i=1;i<A.length;i++){
            Map<Character,Integer> tmp=new HashMap<>();
            for(int j=0;j<A[i].length();j++){
                char c=A[i].charAt(j);
                if(map.containsKey(c) && map.get(c)>0){
                    tmp.put(c,tmp.getOrDefault(c,0)+1);
                    map.put(c,map.get(c)-1);
                }
            }
            map=tmp;
            if(map.size()==0)break;
        }
        List<String> res=new ArrayList<>();
        for(Character c:map.keySet()){
            for(int k=0;k<map.get(c);k++){
                res.add(""+c);
            } 
        }
        return res;
    }
}
```

----------
368

总持续时间可被 60 整除的歌曲
在歌曲列表中，第 i 首歌曲的持续时间为 time[i] 秒。

返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。形式上，我们希望索引的数字  i < j 且有 (time[i] + time[j]) % 60 == 0。

 

示例 1：

输入：[30,20,150,100,40]
输出：3
解释：这三对的总持续时间可被 60 整数：
(time[0] = 30, time[2] = 150): 总持续时间 180
(time[1] = 20, time[3] = 100): 总持续时间 120
(time[1] = 20, time[4] = 40): 总持续时间 60
示例 2：

输入：[60,60,60]
输出：3
解释：所有三对的总持续时间都是 120，可以被 60 整数。

用一个数组记录每个时间对应的模60结果的总和，如果两个数的模相加为60，则这两个数相加是60的倍数
```
class Solution {
    public int numPairsDivisibleBy60(int[] time){
        int[] record = new int[60];
        int ans = 0;

        for(int t : time){
            t %= 60;
            if(t != 0){
                ans += record[60 - t];
            }
            else ans += record[t];
            record[t]++; 
        }
        return ans;
    }
}

```

----------
369

将数组分成和相等的三个部分
给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。

形式上，如果可以找出索引 i+1 < j 且满足 (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1]) 就可以将数组三等分。

 

示例 1：

输出：[0,2,1,-6,6,-7,9,1,2,0,1]
输出：true
解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1
示例 2：

输入：[0,2,1,-6,6,7,9,-1,2,0,1]
输出：false
示例 3：

输入：[3,3,6,5,-2,2,5,1,-9,4]
输出：true
解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4
若数组和 sum 不是 3 的倍数，直接 false。


设置头尾两个指针 left、right，这样两个指针就将数组分为了三部分。

两个指针向中间移动，同时求数组第 1 段（left 左边）、第 3 段（right 右边）的和。
若发现这两段的和都等于 sum / 3 ，则可以分为三部分，返回 true；
若两指针碰头时仍然不能满足 ，则不能分成三部分，返回 false。

```
class Solution {
    public boolean canThreePartsEqualSum(int[] A) {
        int sum = 0;
        for (int i: A) {
            sum += i;
        }
        // 数组和不是3的倍数，直接false
        if (sum % 3 != 0) {
            return false;
        }

        // 左右指针
        int left = 0, right = A.length - 1;
        // 第1段的和，第3段的和
        int leftSum = A[left], rightSum = A[right];
        
        while (left + 1 < right) {
            if ((leftSum == sum / 3) && (rightSum == sum / 3)) {
                return true;
            }
            if (leftSum != sum / 3) {
                left ++;
                leftSum += A[left];
            }
            if (rightSum != sum / 3) {
                right --;
                rightSum += A[right];
            }
        }
        return false;
    }
}
```

----------
379

删除最外层的括号
有效括号字符串为空 ("")、"(" + A + ")" 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，""，"()"，"(())()" 和 "(()(()))" 都是有效的括号字符串。

如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。

给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。

对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。

 

示例 1：

输入："(()())(())"
输出："()()()"
解释：
输入字符串为 "(()())(())"，原语化分解得到 "(()())" + "(())"，
删除每个部分中的最外层括号后得到 "()()" + "()" = "()()()"。
示例 2：

输入："(()())(())(()(()))"
输出："()()()()(())"
解释：
输入字符串为 "(()())(())(()(()))"，原语化分解得到 "(()())" + "(())" + "(()(()))"，
删除每隔部分中的最外层括号后得到 "()()" + "()" + "()(())" = "()()()()(())"。

```
class Solution {
    public String removeOuterParentheses(String S) {
        StringBuilder ans = new StringBuilder();//可变长的字符串
        Stack<Character> stack = new Stack<>();//初始化一个栈
        int start = 0;// 初始化原语的起始位置
        int end = 0;// 初始化原语的结束位置
        boolean flag = false;// 标志每个原语
        int len=S.length();
        for (int i = 0;i < len;i++) {//遍历字符串
            char ch = S.charAt(i);
            if (ch == '(') {// 遇到左括号，入栈
                stack.push(ch);
                if (!flag) {// 遇到的第一个左括号，是原语的开始位置，记录下原语开始位置
                    start = i;
                    flag = true;
                }
            }
            if (ch == ')') {// 遇到右括号，出栈
                stack.pop();
                if (stack.isEmpty()) {// 当栈空的时候，找到了一个完整的原语
                    end = i;// 记录下结束位置
                    ans.append(S.substring(start + 1,end));// 去掉原语的最外层括号，并追加到答案中
                    flag = false;// 置标志为false，往后接着找下一个原语
                    start = end;// 往后找，再次初始化原语开始位置
                }
            }
        }
        return ans.toString();
    }
}
```


----------
381

两地调度
公司计划面试 2N 人。第 i 人飞往 A 市的费用为 costs[i][0]，飞往 B 市的费用为 costs[i][1]。

返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N 人抵达。

 

示例：

输入：[[10,20],[30,200],[400,50],[30,20]]
输出：110
解释：
第一个人去 A 市，费用为 10。
第二个人去 A 市，费用为 30。
第三个人去 B 市，费用为 50。
第四个人去 B 市，费用为 20。


最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。
从小到大排列 costs[i][0]-costs[i][1] (即i去A市与去B市的车票差额)。序列前面的人去A市花销更小，序列后面的人去B市花销更小。

```
class Solution {
     public int twoCitySchedCost(int[][] costs) {
        //计算每个人 A市费用-B市费用 ，并按差值从小到大排序
        Arrays.sort(costs, (a, b) -> {
            return (a[0] - a[1]) - (b[0] - b[1]);
        });

        //前N个人派往A市，其余派往B市
        int sum = 0;
        for (int i = 0; i < costs.length; ++i) {
            if (i < costs.length / 2) {
                sum += costs[i][0];
            } else {
                sum += costs[i][1];
            }
        }
        return sum;
    }
}
```

----------
382

最后一块石头的重量

有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出两块最重的石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。

```
class Solution {
    public int lastStoneWeight(int[] stones) {
        int weight=0;
        int len=stones.length;
        for(int i=0;i<len-1;i++){
            Arrays.sort(stones);	//升序排序
            weight =stones[len-1]-stones[len-2];	
            stones[len-1]=weight;	//相减的值赋给倒数第一个
            stones[len-2]=0;	
        }
        return stones[len-1];	//循环结束后 升序最大的值返回
    }
}
```

----------
383

删除字符串中的所有相邻重复项
给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

 

示例：

输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。


使用栈,入栈前,判断当前元素是否与栈顶元素相等,如果相等,出栈,如果不相等,入栈.
```
class Solution{
    public static String removeDuplicates(String S) {
        Stack<Character> stack=new Stack<>();
        stack.push(S.charAt(0));
        for(int i=1;i< S.length();i++){
            char c = S.charAt(i);
            if(!stack.isEmpty()){
                Character peek = stack.peek();
                if(peek !=c){
                    stack.push(c);
 
                }else{
                    stack.pop();
                }
            }else{
                stack.push(c);
            }
        }
 
        String stackStr = getStackStr(stack);
        return stackStr;
    }
 
    public static String  getStackStr(Stack stack){
        StringBuilder sb=new StringBuilder();
        while(!stack.isEmpty()){
            Object peek = stack.peek();
            sb.append(peek);
            stack.pop();

 
        }
        return sb.reverse().toString();
    }
}
```

----------
384

字符串的最大公因子
对于字符串 S 和 T，只有在 S = T + ... + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。

返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。

 

示例 1：

输入：str1 = "ABCABC", str2 = "ABC"
输出："ABC"
示例 2：

输入：str1 = "ABABAB", str2 = "ABAB"
输出："AB"
示例 3：

输入：str1 = "LEET", str2 = "CODE"
输出：""

```
class Solution {
    public String gcdOfStrings(String str1, String str2) {
        if(!(str1 + str2).equals(str2 + str1)) return "";
        return str1.substring(0, gcb(str1.length(), str2.length())); 
    }
    //辗转相除求最大公因子
    private int gcb(int a, int b) {
        return b == 0? a : gcb(b, a%b);
    }
}
```

----------
386

活字印刷
你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。

 

示例 1：

输入："AAB"
输出：8
解释：可能的序列为 "A", "B", "AA", "AB", "BA", "AAB", "ABA", "BAA"。
示例 2：

输入："AAABBC"
输出：188


```
//回溯法，关键考虑如何去查
class Solution {
    int result=0;
    public int numTilePossibilities(String tiles) {
        char[] ch=tiles.toCharArray();
        Arrays.sort(ch);
        boolean[] visit=new boolean[ch.length];
        backtrack(visit,ch);
        return result;
    }
    public void backtrack(boolean[] visit,char[] ch)
    {
        for(int i=0;i<ch.length;i++)
        {
            //这是这个代码核心的部分
            //选过一次的一定不会再选了
            //如果与前面一个字母相同，且它已经回退过了，说明它已经选完了
            if(visit[i]||(i>0&&ch[i]==ch[i-1]&&!visit[i-1]))
            {
                continue;
            }
            result++;
            visit[i]=true;
            backtrack(visit,ch);
            visit[i]=false;
        }
    }
}
```

----------
387

复写零
给你一个长度固定的整数数组 arr，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。

注意：请不要在超过该数组长度的位置写入元素。

要求：请对输入的数组 就地 进行上述修改，不要从函数返回任何东西。

 

示例 1：

输入：[1,0,2,3,0,4,5,0]
输出：null
解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]
示例 2：

输入：[1,2,3]
输出：null
解释：调用函数后，输入的数组将被修改为：[1,2,3]


1、for循环遍历数组arr；
2、对arr[i]判断是否为0；
3、如果为0，进行嵌套for循环。执行内部for循环。如果不是，继续进行该for循环。
4、内部循环，定义一个j指针，从arr数组的末尾开始遍历，止于i的后一位。
5、内部循环结束后，i++；（内部循环结束后，i++的原因是因为i进行了复写，所以紧挨i的那一位是复写的那一位，再继续外部for循环的时候，需要跳过该复写元素，故内部循环结束之后需要i++。

![](TY/59.png)

```
class Solution {
    public void duplicateZeros(int[] arr) {
        for(int i = 0;i<arr.length;i++){//遍历数组arr
            if(arr[i] == 0){//判断是否为0
                for(int j=arr.length - 1;j>i;j--){//定义指针j从后开始遍历
                    arr[j] = arr[j-1];//i以及后面的值都往后移一位
                }
                i++;//i指针后移一位，然后继续for循环
            }
        }
    }
}
```

----------

390

最长公共子序列
给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

若这两个字符串没有公共子序列，则返回 0。

 

示例 1:

输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace"，它的长度为 3。
示例 2:

输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc"，它的长度为 3。

二维数组中的值表示的是蓝色字符串当前子序列和红色字符串当前子序列的公共子序列长度

```
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        if(text1 == null || text2 == null) return 0;
        int m = text1.length();
        int n = text2.length();
      //多申请一行一列，是因为dp[0][0]需要处理越界，所以改成dp[1][1]
        int[][] dp = new int[m + 1][n + 1];
        for(int i = 1;i <= m;i++) {
        	for(int j = 1;j <= n;j++) {
        		if(text1.charAt(i - 1) == text2.charAt(j - 1)) {
        			dp[i][j] = dp[i - 1][j - 1] + 1;
        		}else {
        			dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
        		}
        	}
        }
        return dp[m][n];
    }
}
```

----------
391

拼写单词
给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。

假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。

注意：每次拼写时，chars 中的每个字母都只能用一次。

返回词汇表 words 中你掌握的所有单词的 长度之和。

 

示例 1：

输入：words = ["cat","bt","hat","tree"], chars = "atach"
输出：6
解释： 
可以形成字符串 "cat" 和 "hat"，所以答案是 3 + 3 = 6。
示例 2：

输入：words = ["hello","world","leetcode"], chars = "welldonehoneyr"
输出：10
解释：
可以形成字符串 "hello" 和 "world"，所以答案是 5 + 5 = 10。

简单的映射数组问题, 重点在于每次遍历, 需要创建一个临时计数的列表

思路：因为只包括小写英文字母，所以可以用长度为26的数组来存储字符串中所有字母的个数，然后比较word和chars中每个字母的个数，如果word中的字母个数等于或小于chars中的字母个数，则一定可以拼写出来该word

```
class Solution {
    public int countCharacters(String[] words, String chars) {
        Map<Character, Integer> m = new HashMap<>();
        for(int i = 0; i <chars.length(); i++){
            m.put(chars.charAt(i), m.getOrDefault(chars.charAt(i), 0) + 1);
        }
        int sum = 0;
        for(String s:words){
            boolean flag = true;
            Map<Character, Integer> map = new HashMap<>();
            map.putAll(m);//深拷贝
            for(int i = 0; i < s.length(); i++){
                if(map.get(s.charAt(i)) == null){
                    flag = false;
                    break;
                }
                if(map.get(s.charAt(i)) == 0){
                    flag = false;
                    break;
                }else{
                    map.put(s.charAt(i), map.get(s.charAt(i))-1);
                }
            }
            if(flag) sum += s.length();
        }
        return sum;
    }
}
```

----------
393
 “气球” 的最大数量

给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 "balloon"（气球）。

字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 "balloon"。


示例 1：



输入：text = "nlaebolko"
输出：1
示例 2：



输入：text = "loonbalxballpoon"
输出：2


```
class Solution {
    public int maxNumberOfBalloons(String text) {
    	int len=text.length();
    	int b=0;
    	int a=0;
    	int l=0;
    	int o=0;
    	int n=0;
    	
    	char[] tx=text.toCharArray();
    	for (int i=0;i<len;i++) {
    		if (tx[i]=='a') a++;
    		else if (tx[i]=='b') b++;
    		else if(tx[i] == 'l') l++;
            else if(tx[i] == 'o') o++;
            else if(tx[i] == 'n') n++; 
    		
    	}
    	return Math.min(Math.min(a, Math.min(b, n)), Math.min(l/2, o/2));
    }
}
```


----------
393

最小绝对差
给你个整数数组 arr，其中每个元素都 不相同。

请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。

 

示例 1：

输入：arr = [4,2,1,3]
输出：[[1,2],[2,3],[3,4]]
示例 2：

输入：arr = [1,3,6,10,15]
输出：[[1,3]]
示例 3：

输入：arr = [3,8,-10,23,19,-4,-14,27]
输出：[[-14,-10],[19,23],[23,27]]


第一，找到数组arr中的最小绝对差值，通过排序来完成，借助Arrays的sort方法实现，因为绝对值差最小的两个数肯定是相邻越近越小。
第二，再次遍历arr数组，将绝对值差等于最小绝对值差的两个元素添加到结果list中去。


如果比较找最小先定义min为 Integer.MAX_VALUE
如果找最大定义max=Integer.MAX_VALUE+1
```
public List<List<Integer>> minimumAbsDifference(int[] arr) {
    Arrays.sort(arr);
	int min = Integer.MAX_VALUE, len = arr.length;
	for (int i=1; i<len; i++) {
		min = Math.min(min, arr[i]-arr[i-1]);
	}
	List<List<Integer>> result = new ArrayList<List<Integer>>();
	for (int i=1; i<len; i++) {
		if (arr[i]-arr[i-1] == min) {
			List<Integer> list = new ArrayList<Integer>();
			list.add(arr[i-1]);
			list.add(arr[i]);
			result.add(list);
		}
	}
	return result;
}
```

----------
394
1111. 有效括号的嵌套深度
1112. 
嵌套深度 depth 定义：即有效括号字符串嵌套的层数，depth(A) 表示有效括号字符串 A 的嵌套深度
示例 1：

输入：seq = "(()())"
输出：[0,1,1,1,1,0]
示例 2：

输入：seq = "()(())()"
输出：[0,0,0,1,1,0,1,1]
解释：本示例答案不唯一。
按此输出 A = "()()", B = "()()", max(depth(A), depth(B)) = 1，它们的深度最小。
像 [1,1,1,0,0,1,1,1]，也是正确结果，其中 A = "()()()", B = "()", max(depth(A), depth(B)) = 1 。 


括号序列   ( ( ) ( ( ) ) ( ) )
下标编号   0 1 2 3 4 5 6 7 8 9
嵌套深度   1 2 2 2 3 3 2 2 2 1
将奇数深度的分一组用0标记，将偶数深度的括号分一组用1标记。
标记结果   0 1 1 1 0 0 1 1 1 0



```
public int[] maxDepthAfterSplit(String seq) {
    if (seq == null || seq.equals("")) return new int[0];
    Stack<Character> stack = new Stack<>();
    int[] res = new int[seq.length()];
    //遍历
    for (int i = 0; i < seq.length(); i++) {
        char c = seq.charAt(i);
        if (c == '(') {//入栈,记录括号对所在深度,奇数用0标记，偶数用1标记。
            res[i] = stack.size() % 2;
            stack.push(c);
        } else {//出栈,记录括号对所在深度,奇数用0标记，偶数用1标记。
            stack.pop();
            res[i] = stack.size() % 2;
        }
    }
    return res;
}
```

----------
395

下降路径最小和
给定一个方形整数数组 A，我们想要得到通过 A 的下降路径的最小和。

下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。

 

示例：

输入：[[1,2,3],[4,5,6],[7,8,9]]
输出：12
解释：
可能的下降路径有：
[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]
[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]
[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]
和最小的下降路径是 [1,4,7]，所以答案是 12。



dp[i][j]表示以A中第i行第j列位置为结束点时，对应的下降路劲最小和：

dp[i][j] = min{dp[i-1][j], dp[i-1][j+1]} + A[i][j], j = 0(前面第一列)

dp[i][j] = min{dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]} + A[i][j], 1 < j < A.length-1 (中间列)

dp[i][j] = min{dp[i-1][j-1], dp[i-1][j]} + A[i][j], j = A.length-1(最后一列)

返回dp中最后一行中最小值，即为下降路劲最小和


```
class Solution {
    public int minFallingPathSum(int[][] A) {
        int len = A.length;
        int[][] dp = new int[len][len];
        for(int i = 0; i < len; i++){
            dp[0][i] = A[0][i];
        }
        for(int i = 1; i < len; i++){
            // 第一列计算
            dp[i][0] = Math.min(dp[i-1][0], dp[i-1][1]) + A[i][0];
            // 中间列计算
            for(int j = 1; j < len-1; j++){
                dp[i][j] = Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]) + A[i][j];
            }
            // 最后一列计算
            dp[i][len-1] = Math.min(dp[i-1][len-2], dp[i-1][len-1]) + A[i][len-1];
        }
        int res = Integer.MAX_VALUE;
        // 求最后一行中的最小值
        for(int j = 0; j < len; j++){
            res = Math.min(res, dp[len-1][j]);
        }
        return res;
    }
}

```

----------
396


按奇偶排序数组 II
给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。

对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。

你可以返回任何满足上述条件的数组作为答案。

 

示例：

输入：[4,2,5,7]
输出：[4,5,2,7]
解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。

符合条件的不动，不符合的交换
----------
```
public int[] sortArrayByParityII(int[] A) {
    int a = 0;
    int b = 1;
    while (a < A.length || b < A.length) {
        if (a < A.length && A[a] % 2 == 0 ) {
            a += 2;
            continue;
        }
        if (A[b] % 2 == 1) {
            b += 2;
            continue;
        }
        swap(A, a, b);
    }
    return A;
}
public static void swap(int[] array, int a, int b) {
    int i = array[a];
    array[a] = array[b];
    array[b] = i;
}
```

----------
397


字符的最短距离
给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。

示例 1:

输入: S = "loveleetcode", C = 'e'
输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]

```
public int[] shortestToChar(String S, char C) {
  List<Integer> list = new ArrayList<>();
	for (int i = 0; i < S.length(); i++) {
		//根据第i个字符把字符串切成两半
		//左边的包含此字符，右边的也包含此字符
		String left = S.substring(0, i+1);
		String right = S.substring(i);
		int lindex=Integer.MAX_VALUE,rindex=Integer.MAX_VALUE;
		if (left.lastIndexOf(C)!=-1) {
			lindex=left.length()-1-left.lastIndexOf(C);
		}		
		if (right.lastIndexOf(C)!=-1) {
			 rindex = right.indexOf(C);
		}
		list.add(Math.min(lindex,rindex));
	}
	//转换成数组返回
	int[] res = new int[list.size()];
	for (int i = 0; i < res.length; i++) {
		res[i] = list.get(i);
	}
	return res;	
	}

```

----------
398


给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。

示例 1:

输入: [1,1,2,3,3,4,4,8,8]
输出: 2
示例 2:

输入: [3,3,7,7,10,11,11]


并且是有序数组，所以我们应该想到利用二分法。


```
class Solution {
    boolean find=false;
    int n=0;
    public int singleNonDuplicate(int[] nums) {
        if(nums.length == 1)return 1;
        help(nums,0,nums.length-1);
        return n;
    }

    public void help(int[] nums,int s,int e){
        if(find) return;
        if(s>nums.length-1 || e<0 || s>e) return;
        if(s==e){
            n = nums[s];
            return;
        }
        int mid = (s+e)/2;
        if(( mid-1>=0 && nums[mid-1] != nums[mid] )  && (mid+1<=nums.length-1 && nums[mid+1] != nums[mid])){
            find = true;
            n=nums[mid];
        }else{
            if(mid-1>=0 && nums[mid-1] == nums[mid]){
                help(nums,s,mid-2);
                help(nums,mid+1,e);
            }
            if(mid+1<=nums.length && nums[mid+1] == nums[mid]){
                help(nums,s,mid-1);
                help(nums,mid+2,e);
            }
        }
        return;
    }
}
```

----------
399


给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。

示例:

输入: [4, 6, 7, 7]
输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]


```
class Solution {
	
	     public List<List<Integer>> findSubsequences(int[] nums) {
	         Set<List<Integer>> res = new HashSet<List<Integer>>();
	         
	         List<Integer> temp =new ArrayList<>();
	         
	        helper(res, temp, nums, 0);
	         return new ArrayList<List<Integer>>(res);
	     }
	 
	     private void helper(Set<List<Integer>> res, List<Integer> temp, 
												int[] nums, int start) {
	         if (temp.size() >= 2) {
	             res.add(new ArrayList<Integer>(temp));
	         }
	        for (int i = start; i < nums.length; i++) {
	             if (temp.size() == 0 || temp.get(temp.size() - 1) <= nums[i]) {
	                 temp.add(nums[i]);
	                helper(res, temp, nums, i + 1);
	                 temp.remove(temp.size() - 1);
	             }
	         }
	     }
	 }
```

----------
400

213

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

示例:

s = "3[a]2[bc]", 返回 "aaabcbc".
s = "3[a2[c]]", 返回 "accaccacc".
s = "2[abc]3[cd]ef", 返回 "abcabccdcdcdef".

/**
 * 解法一
 *
 * 利用2个栈，一个数字栈numStack，一个字母栈strStack
 * 遍历字符串
 * 1、字符为数字，解析数字（注意连续数字的情况）存入 num
 * 2、字符为字母，拼接字母 存入 str
 * 3、字符为左括号，把之前得到的数字 num 和 字母 str 分别压栈，然后把数字重置为0，字母字符串重置为空串
 * 4、字符为右括号，数字栈栈顶数字出栈，作为重复次数 n，字母栈栈顶字母出栈，作为前缀字母字符串去拼接 str 字母变量，总共拼接 n 次，拼接后的新字母串给 str
 *
 * 例如：
 * 2[abc]3[cd]ef
 *  ↑
 * 遇到左括号，把数字 num=2 和 字母 str="" 入栈，并且 num 和 str 重置
 *    |   |      |    |
 *    |   |      |    |
 *    |_2_|      |_""_|
 *   numStack    strStack
 *
 * 2[abc]3[cd]ef
 *      ↑
 * 遇到左括号，num=0 str="abc"，numStack 和 strStack 栈顶元素出栈 str = strStack.pop() + str \* numStack.pop() = "" + "abc" * 2 =  "abcabc"
 *    |   |      |   |
 *    |   |      |   |
 *    |___|      |___|
 *   numStack    strStack
 *
 * 2[abc]3[cd]ef
 *        ↑
 * 遇到右括号，数字 num=3 和 字母 str="abcabc" 入栈，并且 num 和 str 重置
 *    |   |      |        |
 *    |   |      |        |
 *    |_3_|      |_abcabc_|
 *   numStack    strStack
 *
 * 2[abc]3[cd]ef
 *           ↑
 * 遇到左括号，num=0 str=cd，numStack 和 strStack 栈顶元素出栈 str = "abcabc" + "cd" * 3 = "abcabccdcdcd"
 *    |   |      |        |
 *    |   |      |        |
 *    |_3_|      |_abcabc_|
 *   numStack    strStack
 *
 * 遍历结束，最终结果 str="abcabccdcdcdef"
 */


这里需要注意的是：
数字可能不止是一位数，也有可能是两位数、三位数……所以需要设置一个while循环进行判断。

```
class Solution{

    public String decodeString(String s) {
        //初始化
        Stack<Integer> numStack = new Stack<>();
        Stack<String> strStack = new Stack<>();
        StringBuilder sb = new StringBuilder();
        int num = 0;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c >= '0' && c <= '9') {
                num = num * 10 + c - '0';//可能是两位数，三位数
            } else if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
                sb.append(c);
            } else if (c == '[') {
                if (num > 0) numStack.push(num);
                strStack.push(sb.toString());
                sb = new StringBuilder();
                num = 0;
            } else {
                //c==']'
                StringBuilder preSB = new StringBuilder().append(strStack.pop());
                int times = numStack.pop();
                for (int j = 0; j < times; j++) {
                    preSB.append(sb);
                }
                sb = preSB;
            }
        }
        return sb.toString();
    }
}
```

----------
