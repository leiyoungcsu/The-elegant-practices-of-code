网易

1、

为了找到自己满意的工作，牛牛收集了每种工作的难度和报酬。牛牛选工作的标准是在难度不超过自身能力值的情况下，牛牛选择报酬最高的工作。在牛牛选定了自己的工作后，牛牛的小伙伴们来找牛牛帮忙选工作，牛牛依然使用自己的标准来帮助小伙伴们。牛牛的小伙伴太多了，于是他只好把这个任务交给了你。


每个输入包含一个测试用例。
每个测试用例的第一行包含两个正整数，分别表示工作的数量N(N<=100000)和小伙伴的数量M(M<=100000)。
接下来的N行每行包含两个正整数，分别表示该项工作的难度Di(Di<=1000000000)和报酬Pi(Pi<=1000000000)。
接下来的一行包含M个正整数，分别表示M个小伙伴的能力值Ai(Ai<=1000000000)。
保证不存在两项工作的报酬相同。

对于每个小伙伴，在单独的一行输出一个正整数表示他能得到的最高报酬。一个工作可以被多个人选择。

输入：
3 3 
1 100 
10 1000 
1000000000 1001 
9 10 1000000000

输出
100 
1000 
1001

找到难度不大于能力的所有工作里，报酬最多的。核心是用HashMap来记录难度和不超过该难度的最大报酬。
先把工作的难度和报酬映射到HashMap
把人的能力也全部读进来，放到HashMap，报酬可以先设为0.
最后按难度从小到大（所以需要先排序）更新HashMap,key为难度，value为不超过难度的最大报酬。

```
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int t1=0,t2=0;
        HashMap<Integer,Integer> hs = new HashMap<>();
        int[] a = new int[n+m];
        int[] b = new int[m];
        for(int i=0;i<n;i++){
            t1 = sc.nextInt();
            t2 = sc.nextInt();
            a[i] = t1;
            hs.put(t1,t2);
        }
        for(int i=0;i<m;i++){
            t1 = sc.nextInt();
            a[n+i] = t1;
            b[i] = t1;
            if(!hs.containsKey(t1))
               hs.put(t1,0);
        }
        Arrays.sort(a);
        int max = 0;
        for(int i=0;i<m+n;i++){
            max = Math.max(max,hs.get(a[i]));
            hs.put(a[i],max);
        }
        for(int i=0;i<m;i++){
            System.out.println(hs.get(b[i]));
        }
    }
}
```

----------
2
小Q得到一个神奇的数列: 1, 12, 123,...12345678910,1234567891011...。

并且小Q对于能否被3整除这个性质很感兴趣。

小Q现在希望你能帮他计算一下从数列的第l个到第r个(包含端点)有多少个数可以被3整除。

输入包括两个整数l和r(1 <= l <= r <= 1e9), 表示要求解的区间两端

输出一个整数, 表示区间内能被3整除的数字个数。

输入
2 5

输出
3


一个数所有位数的和相加如果等于3的倍数，则这个整数是3的倍数。 这里第一个数是1，第二个是12，第三个是123……第n个数是123……(n-1)n，各个位之和可以算成(i+1)*i/2,这里如果是大于等于两位数，它算成一个数和把每一位分开计算对3取余的结果都是一样的，所以没关系。 所以，直接遍历l到r，根据通项公式判断即可。
```
public class Main {
    public static int divide(int l,int r){
    	int count = 0;
        
      for (int i=l;i<=r;i++) {
    	  if((((i+1)*i)/2)%3==0){
    		count++;  
        }
      
    }
	return count;
    }
    public static void main(String[] args) {
    	      System.out.println(divide(2,5));
    	      }
   }
```

----------
3

小Q正在给一条长度为n的道路设计路灯安置方案。

为了让问题更简单,小Q把道路视为n个方格,需要照亮的地方用'.'表示, 不需要照亮的障碍物格子用'X'表示。

小Q现在要在道路上设置一些路灯, 对于安置在pos位置的路灯, 这盏路灯可以照亮pos - 1, pos, pos + 1这三个位置。

小Q希望能安置尽量少的路灯照亮所有'.'区域, 希望你能帮他计算一下最少需要多少盏路灯。

对于每个测试用例, 输出一个正整数表示最少需要多少盏路灯。

输入：
2

3
.X.

11
...XX....XX

输出：
1
3


```
import java.io.*;
  
public class Main{
    public static int lampSum(int l,String r){
        int sum = 0;
        for(int i=0; i<l; i++){
            if(r.charAt(i) == '.'){
                sum ++;
                i+=2;
            }
        }
        return sum;
    }
     
    public static void main(String[] args) throws IOException{
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        String sa = bf.readLine();
        int ca = Integer.valueOf(sa);
        for(int i=0; i<ca; i++){
            int len = Integer.valueOf(bf.readLine());
            String s = bf.readLine();
            System.out.println(String.valueOf(lampSum(len,s)));
        }
    }
}
```


----------
4

牛牛去犇犇老师家补课，出门的时候面向北方，但是现在他迷路了。虽然他手里有一张地图，但是他需要知道自己面向哪个方向，请你帮帮他。

输入描述:
每个输入包含一个测试用例。
每个测试用例的第一行包含一个正整数，表示转方向的次数N(N<=1000)。
接下来的一行包含一个长度为N的字符串，由L和R组成，L表示向左转，R表示向右转。

输出描述:
输出牛牛最后面向的方向，N表示北，S表示南，E表示东，W表示西。

输入：
3
LRR

输出：
E

定义一个方向数组
1
char[] direction = new char[] {'E', 'S', 'W', 'N', 'E', 'S', 'W'};
然后分别计算Left和Right的步数，并将其%4，最后direction[3 + (countRight - countLeft)]就是所求方向。
```
import java.util.Scanner;
 
public class Main {
 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        char[] direction = new char[] {'E', 'S', 'W', 'N', 'E', 'S', 'W'};
        int n = sc.nextInt();
        String path = sc.next();
        int countLeft = 0;
        int countRight = 0;
        for (int i = 0; i < n; i++) {
            if (path.charAt(i) == 'L') {
                countLeft++;
            } else {
                countRight++;
            }
        }
        countLeft %= 4;
        countRight %= 4;
        System.out.println(direction[3 + (countRight - countLeft)]);
    }
}
```

----------
5

牛牛以前在老师那里得到了一个正整数数对(x, y), 牛牛忘记他们具体是多少了。

但是牛牛记得老师告诉过他x和y均不大于n, 并且x除以y的余数大于等于k。
牛牛希望你能帮他计算一共有多少个可能的数对。

输入描述:
输入包括两个正整数n,k(1 <= n <= 10^5, 0 <= k <= n - 1)。

输出描述:
对于每个测试用例, 输出一个正整数表示可能的数对数量。

输入

5 2

输出
7

说明

满足条件的数对有(2,3),(2,4),(2,5),(3,4),(3,5),(4,5),(5,3)

```
import java.util.*;
 
public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        long n = sc.nextInt();
        long k = sc.nextInt();
        long ans = 0L;
        if (k == 0) {
            ans = n * n; // 任何两对数的余数都是大于等于零
        } else {
            for (long y = k + 1; y <= n; y++) {
                ans += (n / y) * (y - k) + Math.max(0, n % y - k + 1);
                // 假设n=10,k=3，则对y来说只能是4,5,6,7,8,9,10
                // 当y=4,(n/y)*(y-k)代表x小于等于8(8是4的整数倍)时有(3,4),(7,4)，Math.max(0,n%y-k+1)代表x大于8时符合题意的对数为0
                // 当y=5,(n/y)*(y-k)代表x小于等于10(10是5的整数倍)时有(3,5),(4,5),(8,5),(9,5)，Math.max(0,n%y-k+1)代表x大于10时符合题意的对数为0
                // 当y=6,(n/y)*(y-k)代表x小于等于6时有(3,6),(4,6),(5,6),Math.max(0,n%y-k+1)代表x大于6时符合题意的对数为2,分别是(9,6),(10,6)
                // 当y=7,(n/y)*(y-k)代表x小于等于7时有(3,7),(4,7),(5,7),(6,7),Math.max(0,n%y-k+1)代表x大于7时符合题意的对数为1,是(10,7)
                // ...以此类推
            }
        }
        System.out.println(ans);
    }
```

----------
7

牛牛总是睡过头，所以他定了很多闹钟，只有在闹钟响的时候他才会醒过来并且决定起不起床。从他起床算起他需要X分钟到达教室，上课时间为当天的A时B分，请问他最晚可以什么时间起床

输入描述:
每个输入包含一个测试用例。
每个测试用例的第一行包含一个正整数，表示闹钟的数量N(N<=100)。
接下来的N行每行包含两个整数，表示这个闹钟响起的时间为Hi(0<=A<24)时Mi(0<=B<60)分。
接下来的一行包含一个整数，表示从起床算起他需要X(0<=X<=100)分钟到达教室。
接下来的一行包含两个整数，表示上课时间为A(0<=A<24)时B(0<=B<60)分。
数据保证至少有一个闹钟可以让牛牛及时到达教室。

输出描述:
输出两个整数表示牛牛最晚起床时间。

示例1
输入

3 
5 0 
6 0 
7 0 
59 
6 59

输出

6 0

思路
把时间都转换为分钟计数，上课时间-路上时间得到最晚起床时间，把所有闹钟时间排序后，二分查找最晚起床时间。
```
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int h=0,m=0;
        int[] a = new int[n];
        for(int i=0;i<n;i++){
            h = sc.nextInt();
            m = sc.nextInt();
            a[i] = h*60+m;
        }
        int t = sc.nextInt();
        h = sc.nextInt();
        m = sc.nextInt();
        int p = h*60+m-t;
        Arrays.sort(a);
        t = Arrays.binarySearch(a,p);
        if(t <0) t = -(t+2);
        h = a[t]/60;
        m = a[t]%60;
        System.out.print(h+" "+m);
    }
}
```

----------
8

牛牛准备参加学校组织的春游, 出发前牛牛准备往背包里装入一些零食, 牛牛的背包容量为w。
牛牛家里一共有n袋零食, 第i袋零食体积为v[i]。
牛牛想知道在总体积不超过背包容量的情况下,他一共有多少种零食放法(总体积为0也算一种放法)。

输入描述:
输入包括两行
第一行为两个正整数n和w(1 <= n <= 30, 1 <= w <= 2 * 10^9),表示零食的数量和背包的容量。
第二行n个正整数v[i](0 <= v[i] <= 10^9),表示每袋零食的体积。

输出描述:
输出一个正整数, 表示牛牛一共有多少种零食放法。

示例1
输入

3 10
1 2 4

输出

8

说明
三种零食总体积小于10,于是每种零食有放入和不放入两种情况，一共有2*2*2 = 8种情况。

```
import java.util.Scanner;

public class Main {
    private static int count = 0;
 
    public static void main(String[] args) {
        @SuppressWarnings("resource")
		Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            count = 0;
            int n = scanner.nextInt();
            int total = scanner.nextInt();
            int[] nums = new int[n];
            long sum = 0;
            for (int i = 0; i < n; i++) {
                nums[i] = scanner.nextInt();
                sum += nums[i];
            }
            if (sum <= total) {
                System.out.println((int)Math.pow(2, n));
            } else {
                dfs(0, 0, n, nums, total);
                
                // 均不添加也是一种情况
                System.out.println(count + 1);
            }
        }
    }
 
    private static void dfs(long sum, int cur, int n, int[] nums, int total) {
        if (cur < n) {
            if (sum > total) {
                return;
            }
            
            // 不添加这件零食
            dfs(sum, cur + 1, n, nums, total);
            // 当前这种添加方式合理,添加这件零食
            if (sum + nums[cur] <= total) {
                count++;
                dfs(sum + nums[cur], cur + 1, n, nums, total);
            }
        }
    }
}
```

----------
9

小易有一个古老的游戏机，上面有着经典的游戏俄罗斯方块。因为它比较古老，所以规则和一般的俄罗斯方块不同。
荧幕上一共有 n 列，每次都会有一个 1 x 1 的方块随机落下，在同一列中，后落下的方块会叠在先前的方块之上，当一整行方块都被占满时，这一行会被消去，并得到1分。
有一天，小易又开了一局游戏，当玩到第 m 个方块落下时他觉得太无聊就关掉了，小易希望你告诉他这局游戏他获得的分数。

输入描述:
第一行两个数 n, m
第二行 m 个数，c1, c2, ... , cm ， ci 表示第 i 个方块落在第几列
其中 1 <= n, m <= 1000, 1 <= ci <= n

输出描述:
小易这局游戏获得的分数
示例1
输入

3 9
1 1 2 2 2 3 1 2 3

输出

2

```
// 超简洁哦，只需把m的值在长度为n的数组上自增就好啦，然后通过sort()取最短的数
 
import java.util.Arrays;
import java.util.Scanner;
 
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < m; i++) {
            arr[scanner.nextInt() - 1]++;
        }
        Arrays.sort(arr);
        System.out.println(arr[0]);
    }
}
```

----------
11

又到了丰收的季节，恰逢小易去牛牛的果园里游玩。
牛牛常说他对整个果园的每个地方都了如指掌，小易不太相信，所以他想考考牛牛。
在果园里有N堆苹果，每堆苹果的数量为ai，小易希望知道从左往右数第x个苹果是属于哪一堆的。
牛牛觉得这个问题太简单，所以希望你来替他回答。

输入描述:
第一行一个数n(1 <= n <= 105)。
第二行n个数ai(1 <= ai <= 1000)，表示从左往右数第i堆有多少苹果
第三行一个数m(1 <= m <= 105)，表示有m次询问。
第四行m个数qi，表示小易希望知道第qi个苹果属于哪一堆。

输出描述:
m行，第i行输出第qi个苹果属于哪一堆。

示例1
输入

5
2 7 3 4 9
3
1 25 11

输出

1
5
3

```
import java.util.Arrays;
import java.util.Scanner;
 
public class apple {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
 
        int a = 0;
        int appleNums[] = new int[n];
        for (int i = 0; i < n; i++) {
            int input = scanner.nextInt();
            appleNums[i] = a + input;
            a = appleNums[i];
        }
 
        int m = scanner.nextInt();
        int searchNums[] = new int[m];
        for (int i = 0; i < m; i++) {
            searchNums[i] = scanner.nextInt();
        }
 
        //二分查找法
        for (int i = 0; i < m; i++) {
            int index = Arrays.binarySearch(appleNums, searchNums[i]);
            if (index>0) {
                System.out.println(index+1);
            }else{
                System.out.println(-index);
            }
        }
    }
}
```
----------
13

今天上课，老师教了小易怎么计算加法和乘法，乘法的优先级大于加法，但是如果一个运算加了括号，那么它的优先级是最高的。例如：
1+2*3=7
1*(2+3)=5
1*2*3=6
(1+2)*3=9
现在小易希望你帮他计算给定3个数a，b，c，在它们中间添加"+"， "*"， "("， ")"符号，能够获得的最大值。

输入描述:
一行三个数a，b，c (1 <= a, b, c <= 10)

输出描述:
能够获得的最大值

示例1
输入

1 2 3

输出

9

```
import java.util.Arrays;
import java.util.Scanner;
 
public class Main {
 
    public static int max1(int a, int b) {
        return Math.max(a + b, a * b);
    }
 
    public static int max2(int a, int b, int c) {
        return max1(max1(a, b), c);
    }
 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
 
        int[] num =  new int[3];
        for (int i = 0; i < 3; i++) {
            num[i] = sc.nextInt();
        }
        System.out.println(max2(num[0], num[1], num[2]));
    }
}
```

----------
14

题目描述
小易有一些立方体，每个立方体的边长为1，他用这些立方体搭了一些塔。
现在小易定义：这些塔的不稳定值为它们之中最高的塔与最低的塔的高度差。
小易想让这些塔尽量稳定，所以他进行了如下操作：每次从某座塔上取下一块立方体，并把它放到另一座塔上。
注意，小易不会把立方体放到它原本的那座塔上，因为他认为这样毫无意义。
现在小易想要知道，他进行了不超过k次操作之后，不稳定值最小是多少。

输入描述:
第一行两个数n,k (1 <= n <= 100, 0 <= k <= 1000)表示塔的数量以及最多操作的次数。
第二行n个数，ai(1 <= ai <= 104)表示第i座塔的初始高度。

输出描述:
第一行两个数s, m，表示最小的不稳定值和操作次数(m <= k)
接下来m行，每行两个数x,y表示从第x座塔上取下一块立方体放到第y座塔上。

示例1
输入

3 2
5 8 5

输出

0 2
2 1
2 3

思路：每次都把数组进行排序，然后最大值-1，最小值+1，用ArrayList记录这一操作的痕迹。
```
import java.util.*;
 
public class Main {
 
    static class Tower {
        int height;
        int index;
        public Tower(int height, int index) {
            this.height = height;
            this.index = index;
        }
    }
 
    public static class TowerComparator implements Comparator<Tower> {
        public int compare(Tower t1, Tower t2) {
            return t1.height - t2.height;
        }
    }
 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        Tower[] towers = new Tower[n];
        for (int i = 0; i < n; i++) {
            towers[i] = new Tower(sc.nextInt(), i + 1);
        }
        List<String> lists = new ArrayList<>();
        Arrays.sort(towers, new TowerComparator());
 
        int count = 0;
        while (towers[n - 1].height - towers[0].height > 0 && k > 0) {
            towers[n - 1].height--;
            towers[0].height++;
            k--;
            count++;
            lists.add(towers[n - 1].index + " " + towers[0].index);
            Arrays.sort(towers, new TowerComparator());
        }
        System.out.println((towers[n - 1].height - towers[0].height) + " " + count);
 
        for (int i = 0; i < lists.size(); i++) {
            System.out.println(lists.get(i));
        }
    }
}
```

----------

16

小明在越南旅游，参加了当地的娱乐活动。小明运气很好，拿到了大奖， 到了最后的拿奖金环节。小明发现桌子上放着一列红包，每个红包上写着奖金数额。
现在主持人给要求小明在这一列红包之间“切”2刀，将这一列红包“切”成3组，并且第一组的奖金之和等于最后一组奖金和（允许任意一组的红包集合是空）。最终第一组红包的奖金之和就是小明能拿到的总奖金。小明想知道最多能拿到的奖金是多少，你能帮他算算吗。

举例解释：桌子上放了红包  1, 2, 3, 4, 7, 10。小明在“4,7”之间、“7,10” 之间各切一刀，将红包分成3组 [1, 2, 3, 4]   [7]   [10]，其中第一组奖金之和=第三组奖金之和=10，所以小明可以拿到10越南盾。

输入描述:
第一行包含一个正整数n，(1<=n<= 200 000)，表示有多少个红包。

第二行包含n个正整数d[i]，表示每个红包包含的奖金数额。其中1<= d[i] <= 1000 000 000

输出描述:
小明可以拿到的总奖金

示例1
输入

5
1 3 1 1 4

输出

5
说明
[1,3,1]  [ ]   [1,4] ，其中第一组奖金和是5，等于第三组奖金和。所以小明可以拿到5越南盾

示例2
输入

5
1 3 2 1 4

输出

4

说明
[1,3]   [2,1]  [4]，小明可以拿到4越南盾

示例3
输入

3
4 1 2

输出

0

说明
[ ]  [4, 1, 2] [ ] ，小明没办法，为了保证第一组第三组相等，只能都分成空的。所以小明只能拿到0越南盾。

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
 
 
public class Main {
 
    /**
     * 双指针思想:
     * 左右指针遍历数组找左边数组的和和右边数组的和比较来移动指针
     * 1.相等则保存当前值，左指针右移，右指针左移动
     * 2.左边和 > 右边和  右指针左移
     * 3.左边和 < 右边和  左指针右移
     */
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(bf.readLine());
        String[] line2 = bf.readLine().split(" ");
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = Integer.parseInt(line2[i]);
        }
        int left = 0, right = n - 1;
        long left_sum = nums[left], right_sum = nums[right], max_sum = 0;
        while (left < right) {
            if (left_sum == right_sum){
                max_sum = left_sum;
                left_sum += nums[++left];
                right_sum += nums[--right];
            }else if (left_sum > right_sum){
                right_sum += nums[--right];
            }else {
                left_sum += nums[++left];
            }
        }
        System.out.println(max_sum);
    }
}
```

----------
17

给满出二叉树，编写算法将其转化为求和树

什么是求和树：二叉树的求和树， 是一颗同样结构的二叉树，其树中的每个节点将包含原始树中的左子树和右子树的和。

二叉树：
                  10
               /      \
             -2        6
           /   \      /  \ 
          8    -4    7    5

求和树：
                 20(4-2+12+6)
               /      \
           4(8-4)      12(7+5)
            /   \      /  \ 
          0      0    0    0

二叉树给出前序和中序输入，求和树要求中序输出；
所有处理数据不会大于int；

输入描述:
2行整数，第1行表示二叉树的前序遍历，第2行表示二叉树的中序遍历，以空格分割

输出描述:
1行整数，表示求和树的中序遍历，以空格分割

示例1
输入

10 -2 8 -4 6 7 5
8 -2 -4 10 7 6 5

输出

0 4 0 20 0 12 0

```
/*
关键思路：二叉树加一个sum属性。
根据先序中序的序列，构建二叉树。
利用后序遍历来更新节点sum值。
最后通过中序遍历得到答案序列。。
*/
import java.util.*;
 
class STNode {
    int val;
    int sum;
    STNode left = null;
    STNode right = null;
 
    public STNode(int val) {
        this.val = val;
    }
}
 
public class Main {
    static int[] preOrder;
    static int[] inOrder;
    static List<Integer> ans;    //存和的中序遍历。
 
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String s1 = in.nextLine();
        String s2 = in.nextLine();
        String[] str1 = s1.split(" ");
        String[] str2 = s2.split(" ");
        int len = str1.length;
        preOrder = new int[len];
        inOrder = new int[len];
        for (int i = 0; i < len; i++) {
            preOrder[i] = Integer.parseInt(str1[i]);
        }
        for (int i = 0; i < len; i++) {
            inOrder[i] = Integer.parseInt(str2[i]);
        }
        STNode sroot = creatTree(0, 0, len - 1);
        sumNode(sroot);
        ans = new ArrayList<>();
        inOrderGo(sroot);
        for (int i : ans) {
            System.out.print(i + " ");
        }
        System.out.println();
    }
     
    //根据先序和中序遍历构建二叉树。
    static STNode creatTree(int root, int beg, int end) {
        if (beg > end) return null;
        STNode node = new STNode(preOrder[root]);
        int loc = 0;
        int cnt = 0;
        for (loc = beg; loc <= end; loc++) {
            cnt++;
            if (preOrder[root] == inOrder[loc])
                break;
        }
        node.left = creatTree(root + 1, beg, loc - 1);
        node.right = creatTree(root + cnt, loc + 1, end);
        return node;
    }
 
    //更新sum值。
    static void sumNode(STNode node) {
        if (node.left == null && node.right == null) {
            node.sum = 0;
        } else if (node.left == null) {
            sumNode(node.right);
            node.sum = node.right.sum + node.right.val;
        } else if (node.right == null) {
            sumNode(node.left);
            node.sum = node.left.sum + node.left.val;
        } else {
            sumNode(node.left);
            sumNode(node.right);
            node.sum = node.left.sum + node.left.val + node.right.sum + node.right.val;
        }
    }
 
     //中序遍历。
    static void inOrderGo(STNode node) {
        if (node == null) return;
        inOrderGo(node.left);
        ans.add(node.sum);
        inOrderGo(node.right);
    }
 
}
```

----------
18

小明有一袋子长方形的积木，如果一个积木A的长和宽都不大于另外一个积木B的长和宽，则积木A可以搭在积木B的上面。好奇的小明特别想知道这一袋子积木最多可以搭多少层，你能帮他想想办法吗？
定义每一个长方形的长L和宽W都为正整数，并且1 <= W <= L <= INT_MAX, 袋子里面长方形的个数为N, 并且 1 <= N <= 1000000.
假如袋子里共有5个积木分别为 (2, 2), (2, 4), (3, 3), (2, 5), (4, 5), 则不难判断这些积木最多可以搭成4层, 因为(2, 2) < (2, 4) < (2, 5) < (4, 5)。
输入描述:
第一行为积木的总个数 N

之后一共有N行，分别对应于每一个积木的宽W和长L

输出描述:
输出总共可以搭的层数

示例1
输入

5
2 2
2 4
3 3
2 5
4 5

输出

4

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.TreeSet;
 
public class Solution3_搭积木 {
 
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(bf.readLine());
        //保存积木的宽高的二维数组
        int[][] bricks = new int[n][2];
        String[] strs;
        for (int i = 0; i < n; i++) {
            strs = bf.readLine().split(" ");
            bricks[i][0] = Integer.parseInt(strs[0]);
            bricks[i][1] = Integer.parseInt(strs[1]);
        }
        if (n==1){
            System.out.println(1);
            return;
        }
        //按照宽进行排序,然后求长度的最长上升子序列
        Arrays.sort(bricks, (a, b) -> a[0] - b[0]);
        /**
         * 我们按照宽度从小到大对 bricks 进行了排序
         * dp数组中存储的数积木的长度，它是一个上升的数组，这样才能保证积木的层叠
         */
        int[] dp = new int[n];
        int count = 0;//层数
        for (int i = 0; i < n; i++) {
            if (count == 0 || bricks[i][1] >= dp[count - 1]) {
                //当当前积木的长度 >= dp数组中保存的最大积木长度，那我们就将它加入到 dp 数组中,并且层数加一
                dp[count] = bricks[i][1];
                count++;
            }else {
                /**
                 * 这里解释一下：当我们加入的积木 bricks[i][1],它的长度小于dp中的最大长度
                 * 我们需要在数组dp中找到 <= bricks[i][1] 最接近的值的索引 index，将它替换成现在的长度 bricks[i][1]
                 * 为什么要替换: dp数组中积木的宽度都是小于 bricks[i]的，积木bricks[i]的宽度比dp[index]宽度大，
                 * 而且bricks[i]的长度 >= dp[index],在堆积木情况下，当然是优先选择宽度和长度更大的积木。
                 */
                int index = lowerBound(dp, 0, count, bricks[i][1]);
                dp[index] = bricks[i][1];
            }
        }
        System.out.println(count);
    }
    /**
     * C++中存在的两个方法，用java实现一下
     * ower_bound算法要求在已经按照非递减顺序排序的数组中找到第一个大于等于给定值key的那个数的索引，
     * 其基本实现原理是二分查找
     */
    public static int lowerBound(int[] nums,int l,int r,int target){
        while(l<r){
            int m = (l+r)/2;
            if(nums[m]>=target) r= m;
            else    l = m +1;
        }
        return l;
    }
 
    /**
     * upper_bound函数要求在按照非递减顺序排好序的数组中找到第一个大于给定值key的那个数索引，
     * 其基本实现原理是二分查找
     */
    public static int upperBound(int []nums ,int l,int r, int target){
        while(l<r){
            int m = (l+r)/2;
            if(nums[m]<=target) l = m+1;
            else    r = m;
        }
        return l;
    }
}
```

----------
19

前几个月放映的头号玩家简直火得不能再火了，作为一个探索终极AI的研究人员，月神自然去看了此神剧。
由于太过兴奋，晚上月神做了一个奇怪的梦，月神梦见自己掉入了一个被施放了魔法的深渊，月神想要爬上此深渊。

已知深渊有N层台阶构成（1 <= N <= 1000)，并且每次月神仅可往上爬2的整数次幂个台阶(1、2、4、....)，请你编程告诉月神，月神有多少种方法爬出深渊

输入描述:
输入共有M行，(1<=M<=1000)

第一行输入一个数M表示有多少组测试数据，

接着有M行，每一行都输入一个N表示深渊的台阶数

输出描述:
输出可能的爬出深渊的方式

示例1

输入

4
1
2
3
4

输出

1
2
3
6

备注:
为了防止溢出，可将输出对10^9 + 3取模

```
/*
动态规划。类似于跳台阶。
用递归会超时。
取模防止溢出。
*/
import java.util.*;
public class Main {
 
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int T = in.nextInt();
        int[] dp = new int[1001];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= 1000; i++) {
            int tmp = 1;
            while (tmp <= i) {
                dp[i] += dp[i - tmp];
                tmp *= 2;
                dp[i] %= 1000000000 + 3;
            }
        }
        while (T-- > 0) {
            int n = in.nextInt();
            System.out.println(dp[n]);
        }
    }
}
```

----------
20

通过键盘输入一串小写字母(a~z)组成的字符串。
请编写一个字符串归一化程序，统计字符串中相同字符出现的次数，并按字典序输出字符及其出现次数。
例如字符串"babcc"归一化后为"a1b2c2"



输入描述:
每个测试用例每行为一个字符串，以'\n'结尾，例如cccddecca

输出描述:
输出压缩后的字符串ac5d2e

示例1
输入

dabcab

输出

a2b2c1d1

```
import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        char[] chars=sc.nextLine().toCharArray();
        //经验，一般是用hashmap来统计出现次数的，
        //但本题是对字符统计次数，可以专门用一个counts数组来统计次数
        int[] counts=new int[26];
        for(int i=0;i<chars.length;i++){
            counts[chars[i]-'a']++;
        }
        for(int i=0;i<26;i++){
            char c=(char)('a'+i);
            int count=counts[i];
            if(count==0){
                continue;
            }else{
                System.out.print(c+""+count);
            }
        }
    }
}
```

----------
21

月神拿到一个新的数据集，其中每个样本都是一个字符串（长度小于100），样本的的后六位是纯数字，月神需要将所有样本的后六位数字提出来，转换成数字，并排序输出。

月神要实现这样一个很简单的功能确没有时间，作为好朋友的你，一定能解决月神的烦恼，对吧。
输入描述:
每个测试用例的第一行是一个正整数M（1<=M<=100)，表示数据集的样本数目

接下来输入M行，每行是数据集的一个样本，每个样本均是字符串，且后六位是数字字符。

输出描述:
对每个数据集，输出所有样本的后六位构成的数字排序后的结果（每行输出一个样本的结果）

示例1
输入

4
abc123455
boyxx213456
cba312456
cdwxa654321

输出

123455
213456
312456
654321

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(bf.readLine());
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {
            String s = bf.readLine();
            ans[i] = Integer.parseInt(s.substring(s.length()-6,s.length()));
        }
        Arrays.sort(ans);
        for (int i = 0; i < ans.length; i++) {
            System.out.println(ans[i]);
        }
    }
}
```

----------
22

最大回文子串是被研究得比较多的一个经典问题。最近月神想到了一个变种，对于一个字符串，如果不要求子串连续，那么一个字符串的最大回文子串的最大长度是多少呢。

输入描述:
每个测试用例输入一行字符串（由数字0-9，字母a-z、A-Z构成），字条串长度大于0且不大于1000.

输出描述:
输出该字符串的最长回文子串的长度。（不要求输出最长回文串，并且子串不要求连续）

示例1
输入

adbca

输出

3

说明
因为在本题中，不要求回文子串连续，故最长回文子串为aba(或ada、aca)
备注:
因为不要求子串连续，所以字符串abc的子串有a、b、c、ab、ac、bc、abc7个

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
 
/**
 * 求最长回文子串的问题，一般有两种方法
 * 1.动态规划
 * 2.中心扩散方法
 */
public class Solution8_回文字符串 {
 
    /**
     * 最长文回串 ，非连续
     * 动态规划
     */
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        String s = bf.readLine();
        int n = s.length();
        int[][] dp = new int[n][n];//dp[l][r]表示l-r中的最长回文串
        for (int r = 0; r < n; r++) {
            dp[r][r] = 1;
            for (int l = r - 1; l >= 0; l--) {
                if (s.charAt(l) == s.charAt(r)) {
                    dp[l][r] = dp[l + 1][r - 1] + 2;
                }else {
                    dp[l][r] = Math.max(dp[l+1][r],dp[l][r-1]);
                }
            }
        }
        System.out.println(dp[0][n-1]);
    }
```

----------
24

小明有26种游戏海报，用小写字母"a"到"z"表示。小明会把游戏海报装订成册（可能有重复的海报），册子可以用一个字符串来表示，每个字符就表示对应的海报，例如abcdea。小明现在想做一些“特别版”，然后卖掉。特别版就是会从所有海报（26种）中随机选一张，加入到册子的任意一个位置。
那现在小明手里已经有一种海报册子，再插入一张新的海报后，他一共可以组成多少不同的海报册子呢？

输入描述:
海报册子的字符串表示，1 <= 字符串长度<= 20

输出描述:
一个整数，表示可以组成的不同的海报册子种类数

示例1
输入

a
输出

51

说明
我们可以组成 'ab','ac',...,'az','ba','ca',...,'za' 还有 'aa', 一共 51 种不同的海报册子。

```
import java.io.*;
public class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        String str = bf.readLine();
        int count =str.length()*25+26;
        System.out.println(count);
         
    }
}
```

----------
25

题目描述
请实现一个函数，功能为合并两个升序数组为一个升序数组

输入描述:
输入有多个测试用例，每个测试用例有1-2行，每行都是以英文逗号分隔从小到大排列的数字

输出描述:
输出一行以英文逗号分隔从小到大排列的数组

示例1
输入

1,5,7,9
2,3,4,6,8,10

输出

1,2,3,4,5,6,7,8,9,10
备注:
不允许使用原生的 sort、concat 等函数

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
  
public class Main {
    public static void main(String args[]) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
  
        String line1 = bf.readLine();
        String line2 = bf.readLine();
        if (line2 == null)
        {
            System.out.print(line1);
            return;
        }
        String[] str1 = line1.split(",");
        String[] str2 = line2.split(",");
  
        StringBuffer sb = new StringBuffer();
        int p1 = 0, p2 = 0;
        while (p1 < str1.length && p2 < str2.length) {
            if (Integer.valueOf(str1[p1]) < Integer.valueOf(str2[p2])) {
                sb.append(str1[p1++]);
                sb.append(",");
            }else {
                sb.append(str2[p2++]);
                sb.append(",");
            }
        }
  
        while (p1 < str1.length) {
            sb.append(str1[p1++]);
            sb.append(",");
        }
        while (p2 < str2.length) {
            sb.append(str2[p2++]);
            sb.append(",");
        }
  
        System.out.println(sb.substring(0,sb.length()-1).toString());
    }
}
```

----------
26

我们定义字符串包含关系：字符串A=abc，字符串B=ab，字符串C=ac，则说A包含B，A和C没有包含关系。

输入描述:
两个字符串，判断这个两个字符串是否具有包含关系，测试数据有多组，请用循环读入。

输出描述:
如果包含输出1，否则输出0.

示例1
输入

abc ab

输出

1
```
import java.io.*;
import java.util.*;
//包括左右包含的意思
public class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        String str1 ;
        while((str1=bf.readLine())!=null){
            String[] s = str1.split(" ");
            System.out.println((s[0].length()>s[1].length()?s[0].contains(s[1]):s[1].contains(s[0]))?1:0);
        }    
           
    }
}

```

----------
27

有重量分别为3，5，7公斤的三种货物，和一个载重量为X公斤的箱子（不考虑体积等其它因素，只计算重量）
需要向箱子内装满X公斤的货物，要求使用的货物个数尽可能少（三种货物数量无限）

输入描述:
输入箱子载重量X(1 <= X <= 10000)，一个整数。

输出描述:
如果无法装满，输出 -1。
如果可以装满，输出使用货物的总个数。

示例1
输入

4

输出

-1

说明
无法装满

示例2
输入

8

输出

2

说明
使用1个5公斤，1个3公斤货物

```
import java.io.*;
 
 
public class Main {
    /**
     * 哎，一直在分析哪些可以装满哪些不能装满的情况，结果发现只有1，2，4不能装满...rlg
     * 参考了 "皮皮虾没有虾的"同学的分析才明白：
     * 对7取余，余数为1，2，3可以装满，1可以视为1+7=3+5，count+1；
     * 余数为2，4，6可对应9，11，13的情况...... count +=2;
     */
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int x = Integer.parseInt(bf.readLine());
        if (x == 1 || x == 2 || x == 4) {
            System.out.println(-1);
        } else {
            int count = 0;
            count += x / 7;
            x = x % 7;
            if (x == 0) {
                System.out.println(count);
            } else {
                System.out.println(x % 2 == 0 ? count + 2 : count + 1);
            }
        }
    }   
}
```

----------
28

给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。
("回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。)
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。


输入描述:
输入一个字符串S 例如“aabcb”(1 <= |S| <= 50), |S|表示字符串S的长度。

输出描述:
符合条件的字符串有"a","a","aa","b","c","b","bcb"

所以答案:7

示例1
输入

aabcb

输出

7

```

public class Solution14_回文子串 {
    /**
     * 方法一：中心扩散法
     */
    static int ans = 0;
 
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        String s = bf.readLine();
        for (int i = 0; i < s.length(); i++) {
            //考虑两种情况：aba 和 abba
            centerSpread(s, i, i);
            centerSpread(s, i, i + 1);
        }
        System.out.println(ans);
    }
 
    //判断回文串的中心扩散法
    private static void centerSpread(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
            ans++;
        }
    }
 
    //方法二：动态规划
    private static int dp(String s) {
        int n = s.length(), ans = 0;
        boolean[][] dp = new boolean[n][n];
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                dp[i][j] = (s.charAt(i) == s.charAt(j)) && (j - i <= 2 || dp[i + 1][j - 1]);
                if (dp[i][j]) ans++;
            }
        }
        return ans;
    }
}
```

----------
29

对字符串进行RLE压缩，将相邻的相同字符，用计数值和字符值来代替。例如：aaabccccccddeee，则可用3a1b6c2d3e来代替。

输入描述:
输入为a-z,A-Z的字符串，且字符串不为空，如aaabccccccddeee

输出描述:
压缩后的字符串，如3a1b6c2d3e

示例1
输入

aaabccccccdd

输出

3a1b6c2d


```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
  
public class Main {
  
    public static void main(String[] args) throws IOException {
  
         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s1 = br.readLine();
        StringBuffer sb1 = new StringBuffer(s1);
        sb1.append('*');
        String s = sb1.toString();
        char[] chars = s.toCharArray();
        StringBuffer sb = new StringBuffer();
        int count=1;
        for (int i = 0; i < chars.length-1; i++) {
            if (chars[i]==chars[i+1]){
                count++;
            }
            else {
                sb.append(count);
                sb.append(chars[i]);
                count=1;
            }
  
        }
        System.out.println(sb.toString());
    }
  
}
```

----------
30

解析加减法运算
如：
输入字符串："1+2+3" 输出："6"
输入字符串："1+2-3" 输出："0"
输入字符串："-1+2+3" 输出："4"
输入字符串："1" 输出："1"
输入字符串："-1" 输出："-1"

已知条件：输入的运算都是整数运算，且只有加减运算
要求：输出为String类型，不能使用内建的eval()函数

输入描述:
输入字符串："1+2+3"

输出描述:
输出："6"
示例1

输入

1+2+3

输出

6


```
import java.io.*;
 
public class Main{
     
     
     
     
    public static void main(String args[])throws IOException {
        BufferedReader bf  =  new BufferedReader(new InputStreamReader(System.in));
        String str = bf.readLine();
 
        if(str.charAt(0)!='-'){
            str = "+"+str;
        }
        int count = 0;
        for(int i = 0; i < str.length();){
            if(str.charAt(i) == '+'){
                i++;
                int now = 0;
                while(str.charAt(i)>='0'&&str.charAt(i)<='9'){
                    now = 10*now + Integer.parseInt(str.charAt(i)+"");
                    i++;
                    if(i >= str.length())
                        break;
                }
                count +=now;
            }
            else if(str.charAt(i) == '-'){
                i++;
                int now = 0;
                while(str.charAt(i)>='0'&&str.charAt(i)<='9'){
                    now = 10*now + Integer.parseInt(str.charAt(i)+"");
                    i++;
                    if(i >= str.length())
                        break;
                }
                count -=now;
            }
        }
        System.out.println(count);
 
    }
}
```

----------
31

一个非空整数数组，选择其中的两个位置，使得两个位置之间的数和最大。
如果最大的和为正数，则输出这个数；如果最大的和为负数或0，则输出0

输入描述:
3,-5,7,-2,8

输出描述:
13

示例1
输入

-6,-9,-10

输出

0
```
已知一个字符串数组words，要求寻找其中两个没有重复字符的字符串，使得这两个字符串的长度乘积最大，输出这个最大的乘积。如：
words=["abcd","wxyh","defgh"], 其中不包含重复字符的两个字符串是"abcd"和"wxyh"，则输出16
words=["a","aa","aaa","aaaa"], 找不到满足要求的两个字符串，则输出0
输入描述:
Input:

["a","ab","abc","cd","bcd","abcd"]
输出描述:
Output:

4
示例1
输入
复制
["a","ab","abc","cd","bcd","abcd"]
输出
复制
4
备注:
Input中，不包含相同字符的有三对：
"ab"和"cd"
"a"和"cd"
"a"和"bcd"
所以字符串长度乘积的最大值是4

import java.util.*;
public class Main{
    private static Scanner sc;
    public static void main(String[] args){
        sc = new Scanner(System.in);
        while(sc.hasNext()){
            int[] nums = readin();
            int res = nums[0];
            int tmax = nums[0];
            for(int i = 1;i<nums.length;i++){
                tmax = Math.max(tmax+nums[i],nums[i]);
                res = Math.max(res,tmax);
            }
            if(res > 0)
                System.out.println(res);
            else
                System.out.println(0);
        }
    }
     
    private static int[] readin(){
        String[] in = sc.nextLine().split(",");
        int[] res = new int[in.length];
        for(int i = 0;i<in.length;i++)
            res[i] = Integer.parseInt(in[i]);
        return res;
    }
}
```

----------
32


已知一个字符串数组words，要求寻找其中两个没有重复字符的字符串，使得这两个字符串的长度乘积最大，输出这个最大的乘积。如：
words=["abcd","wxyh","defgh"], 其中不包含重复字符的两个字符串是"abcd"和"wxyh"，则输出16
words=["a","aa","aaa","aaaa"], 找不到满足要求的两个字符串，则输出0

输入描述:
Input:

["a","ab","abc","cd","bcd","abcd"]

输出描述:
Output:

4

示例1
输入

["a","ab","abc","cd","bcd","abcd"]

输出

4

备注:
Input中，不包含相同字符的有三对：
"ab"和"cd"
"a"和"cd"
"a"和"bcd"
所以字符串长度乘积的最大值是4

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
 
public class Solution18_字符串长度最大乘积 {
 
    /**
     * 本来想着这种暴力方***超时，因为是在没想到好的方法....
     */
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        String str = bf.readLine();
        str = str.substring(1,str.length()-1);//数据处理，去掉[ 和 ]括号
        str = str.replace("\"","");//去掉 ",注意用转移符\"
        String[] dic = str.split(",");
        int max_leng = 0;
        for (int i = 0; i < dic.length; i++) {
            for (int j = i+1; j < dic.length; j++) {
                if (noContain(dic[i], dic[j])) {
                    max_leng = Math.max(max_leng, dic[i].length() * dic[j].length());
                }
            }
        }
        System.out.println(max_leng);
    }
 
    //判断两个字符是否重复，只能每个字符每个字符的比较了
    private static boolean noContain(String s1, String s2) {
        for (int i = 0; i < s1.length(); i++) {
            if (s2.contains(s1.substring(i, i + 1))) {
                return false;
            }
        }
        return true;
    }
}
```

----------
33

输入年、月、日，计算该天是本年的第几天。 

输入： 

包括三个整数年(1<=Y<=3000)、月(1<=M<=12)、日(1<=D<=31)。 

输出： 

输入可能有多组测试数据，对于每一组测试数据， 

输出一个整数，代表Input中的年、月、日对应本年的第几天。


输入描述:
输入：1990 9 20

输出描述:
输入：263

示例1
输入

2000 5 1 

输出

122

备注:
注意闰年的判定方式

```
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int[] mons = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        while (in.hasNext()) {
            int year = in.nextInt();
            int month = in.nextInt();
            int day = in.nextInt();
            if (isLeap(year)) mons[2] = 29;
            int ans = 0;
            for (int i = 1; i < month; i++) {
                ans += mons[i];
            }
            ans += day;
            System.out.println(ans);
        }
    }
 
    static boolean isLeap(int year) {
        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)
            return true;
        return false;
    }
}
```

----------
34

有一个无限长的数字序列1，2，2，3，3，3，4，4，4，4，5，5，5，5，5。。。（数字序列从1开始递增，且数字k在该序列中正好出现k次），求第n项是多少

输入描述:
输入为一个整数n

输出描述:
输出一个整数，即第n项的值

示例1

输入

4

输出

3
备注:
如：输入为3，有序数列第3项的值为2，则输出为2

```
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner input  = new Scanner(System.in);
        int n = Integer.parseInt(input.nextLine());
         
        for (int i = 1; i <= n; i++) {
            if ((1 + i) * i / 2 >= n) {
                System.out.println(i);
                break;
            }
        }
         
    }
}

```

----------
35

你需要爬上一个N层的楼梯，在爬楼梯过程中， 每阶楼梯需花费非负代价，第i阶楼梯花费代价表示为cost[i]， 一旦你付出了代价，你可以在该阶基础上往上爬一阶或两阶。
你可以从第 0 阶或者 第 1 阶开始，请找到到达顶层的最小的代价是多少。
N和cost[i]皆为整数，且N∈[2,1000]，cost[i]∈ [0, 999]。

输入描述:
输入为一串半角逗号分割的整数，对应cost数组，例如

10,15,20

输出描述:
输出一个整数，表示花费的最小代价

示例1
输入

1,100,1,1,1,100,1,1,100,1

输出

6

```
import java.io.*;
public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] arr = br.readLine().split(",");
        int len = arr.length;
        int[] intarr = new int[len];
        for(int i = 0;i<len;i++){
            intarr[i]=Integer.parseInt(arr[i]);
        }
        int[] dp = new int[len+1];
        dp[1]=intarr[0];
        for(int i = 2;i<len;i++){
            dp[i]=Math.min(dp[i-1],dp[i-2])+intarr[i-1];
        }
        dp[len]=Math.min(dp[len-1],dp[len-2]+intarr[len-1]);
        System.out.println(dp[len]);
    }
}
```

----------
36

农场有n只鸡鸭排为一个队伍，鸡用“C”表示，鸭用“D”表示。当鸡鸭挨着时会产生矛盾。需要对所排的队伍进行调整，使鸡鸭各在一边。每次调整只能让相邻的鸡和鸭交换位置，现在需要尽快完成队伍调整，你需要计算出最少需要调整多少次可以让上述情况最少。例如：CCDCC->CCCDC->CCCCD这样就能使之前的两处鸡鸭相邻变为一处鸡鸭相邻，需要调整队形两次。

输入描述:
输入一个长度为N，且只包含C和D的非空字符串。

输出描述:
使得最后仅有一对鸡鸭相邻，最少的交换次数

示例1
输入

CCDCC

输出

2



分两种情况，C排前D排后，C排后D排前，取最小值
对于C排前D排后，只看C，最小交换次数为，s中为C的下标之和，减去排好序后C的下标之和
例如：CCDDCC，排序后CCCCDD，最小交换次数为 C：4->2，5->3，(0+1+4+5)-(0+1+2+3) = 4
```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
 
public class Solution1_鸡鸭分类问题 {
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        char[] chars = bf.readLine().toCharArray();
        //分别统计C在前面和D在前面的移动次数
        int retC = 0, retD = 0, count_C = 0, count_D = 0;
        for (int i = 0; i < chars.length; i++) {
            if (chars[i] == 'C') {
                retC += i - count_C;
                count_C++;//记录出现前面出现多少个 'C',从第i个位置把C移动到底count_c个位置需要移动 i - count_c次
            } else {
                retD += i - count_D;
                count_D++;//记录出现前面出现多少个 'D'
            }
        }
        System.out.println(Math.min(retC,retD));
    }
}
```

----------
37

小招喵喜欢吃喵粮。这里有 N 堆喵粮，第 i 堆中有 p[i] 粒喵粮。喵主人离开了，将在 H 小时后回来。

小招喵可以决定她吃喵粮的速度 K （单位：粒/小时）。每个小时，她将会选择一堆喵粮，从中吃掉 K 粒。如果这堆喵粮少于 K 粒，她将吃掉这堆的所有喵粮，然后这一小时内不会再吃更多的喵粮。  

小招喵喜欢慢慢吃，但仍然想在喵主人回来前吃掉所有的喵粮。

返回她可以在 H 小时内吃掉所有喵粮的最小速度 K（K 为整数）。

输入描述:
第一行输入为喵粮数组，以空格分隔的N个整数

第二行输入为H小时数

输出描述:
最小速度K

示例1
输入

3 6 7 11
8

输出

4

贪心  + 二分查找
理论最小进食速度： 所有喵粮求和 / 给定的小时数
理论最大进食速度：最大堆的喵粮数
在这两个之间二分查找最小实际可行进食速度即可
```
import java.util.Scanner;
import static java.lang.System.in;
 
public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(in);
        String[] str = sc.nextLine().split(" ");
        int h = Integer.parseInt(sc.nextLine());
        int[] data = new int[str.length];
        int maxSpeed = Integer.MIN_VALUE;
        for (int i = 0; i < str.length; i++) {
            data[i] = Integer.parseInt(str[i]);
            maxSpeed = Math.max(maxSpeed, data[i]);
        }
        int mid = 0;
        int minSpeed = 1;
        while (minSpeed <= maxSpeed) {
            mid = minSpeed + ((maxSpeed - minSpeed) >> 1);
            if (getHour(data, mid) <= h) {
                maxSpeed = mid - 1;
            } else {
                minSpeed = mid + 1;
            }
        }
       System.out.println(minSpeed);
    }
 
    public static int getHour(int[] data, int k) {
        int sum = 0;
        for (int i = 0; i < data.length; i++) {
            sum += data[i] % k == 0 ? data[i] / k : data[i] / k + 1;
        }
        return sum;
    }
}
```

----------
38

题目描述
一条包含字母 A-Z 的消息通过以下方式进行了编码：

'A' -> 1
'B' -> 2
...
'Z' -> 26
给定一个只包含数字的非空字符串，请计算解码方法的总数。

输入描述:
12可以解码成“AB”，“L”这两种

输出描述:
解码方法的总数

示例1
输入

12

输出

2

说明
12可以解码成“AB”，“A，B"这两种


使用 dp，每个数字单独看待或者作为个位看待。

例如：12

这个 1 没什么说的：只能作为一个单独的数字看待。

这个 2 可分两种情况：

单独作为数字 2。

作为数字 12 的个位数字。

最后：因为 0 比较特殊（不能作为单独的数字存在），需要注意一下。
```
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine().trim();
        int[] dp = new int[s.length() + 1];
        dp[0] = 1;
        for(int i = 0; i < s.length(); i ++) {
            char ch = s.charAt(i);
            dp[i + 1] = ch != '0' ? dp[i] : 0;
            if(i > 0 && (s.charAt(i - 1) == '1' || (s.charAt(i - 1) == '2' && ch <= '6'))) {
                dp[i + 1] += dp[i - 1];
            }
        }
        System.out.println(dp[s.length()]);
    }
}
```

----------
39

公司组织团建活动，到某漂流圣地漂流，现有如下情况：
员工各自体重不一，第 i 个人的体重为 people[i]，每艘漂流船可以承载的最大重量为 limit。
每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。
为节省开支，麻烦帮忙计算出载到每一个人所需的最小船只数(保证每个人都能被船载)。
输入描述:
第一行输入参与漂流的人员对应的体重数组，

第二行输入漂流船承载的最大重量

输出描述:
所需最小船只数

示例1
输入

1 2
3

输出

1

注意利用每艘船只能载两人，以及保证每个人都能被船载两个条件。
```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
 
public class Main {
 
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        String[] str = bf.readLine().split(" ");
        int limit = Integer.valueOf(bf.readLine());
        int i=0;
        int count=0;
        while (i<str.length){
            if (i==str.length-1){
                count++;
                i++;
            }else {
                if (Integer.parseInt(str[i]) + Integer.parseInt(str[i + 1]) <= limit) {
                    count++;
                    i = i + 2;
                } else {
                    count++;
                    i = i + 1;
                }
            }
        }
        System.out.println(count);
    }
}
```

----------
40

我们部门需要装饰墙，但是墙非常非常的长，有一千万米。我们会按顺序贴很多海报在上面，这些海报相互之间会重叠，请问下，最后还能看到哪些？（只看到一部分也算）

输入描述:
N表示N张海报
接下来每一行代表海报的左右边界（上下默认全满），Li，Ri，均为整数，大于0，小于一千万。海报按输入顺序张贴。

输出描述:
有多少张海报是可见的


示例1

5
1 4
2 6
8 10
3 4
7 10

输出

4

```
import java.io.*;
public class Main{
    public static void main(String args[]) throws IOException{
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        int n=Integer.parseInt(br.readLine());
        int count=0;
        int[][] a=new int[n][2];
        for(int i=0;i<n;i++){
            String[] str=br.readLine().split(" ");
            a[i][0]=Integer.parseInt(str[0]);
            a[i][1]=Integer.parseInt(str[1]);
        }
        for(int j=0;j<n;j++){
            if(cover(a,n,a[j][0],a[j][1],j+1)){
                count++;
            }
        }
        System.out.println(count);
    }
    private static boolean cover(int[][] a,int n,int Li,int Ri,int next){
        if(Li==Ri)
            return false;
        if(next>=n)
            return true;
        if(a[next][0]<=Li&&Ri<=a[next][1])  //(x,y)被完全覆盖
            return false;
        else if(a[next][0]>=Ri||a[next][1]<=Li)//不交叠
            return cover(a,n,Li,Ri,next+1);
        else if(Li<=a[next][0]&&a[next][1]<=Ri)
            return cover(a,n,Li,Ri,next+1);
        else if(Li<a[next][1]&&a[next][1]<=Ri)
            return cover(a,n,a[next][1],Ri,next+1);
        else if(Li<a[next][0]&&a[next][0]<Ri)
            return cover(a,n,Li,a[next][0],next+1);
        return false;
    }
}
```

----------
41

我们部门要排队唱歌，大家乱哄哄的挤在一起，现在需要按从低到高的顺序拍成一列，但每次只能交换相邻的两位，请问最少要交换多少次

输入描述:
第一行是N（N<50000）,表示有N个人
然后每一行是人的身高Hi（Hi<2000000,不要怀疑，我们以微米计数），持续N行，表示现在排列的队伍

输出描述:
输出一个数，代表交换次数。

示例1
输入

6
3
1
2
5
6
4

输出

4
```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
 

public class Main {
 
 
    private static int[] a;
    private static int res = 0;
 
    private static void merge(int[] a, int i, int mid, int j) {
        int[] help = new int[j - i + 1];
        int p = i, q = mid + 1, t = 0;
        while (p < mid + 1 && q < j + 1) {
            if (a[p] <= a[q]) help[t++] = a[p++];
            else {
                res += (mid + 1 - p);
                help[t++] = a[q++];
            }
        }
        while (p < mid + 1) help[t++] = a[p++];
        while (q < j + 1) help[t++] = a[q++];
        System.arraycopy(help, 0, a, i, help.length);
    }
 
    private static void mergeSort(int[] a, int i, int j) {
        if (i < j) {
            int mid = i + ((j - i) >> 1);
            mergeSort(a, i, mid);
            mergeSort(a, mid + 1, j);
            merge(a, i, mid, j);
        }
    }
 
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(bf.readLine());
        a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = Integer.parseInt(bf.readLine());
        }
        mergeSort(a, 0, a.length - 1);
        System.out.println(res);
    }
}
```

----------
42

我们有很多区域，每个区域都是从a到b的闭区间，现在我们要从每个区间中挑选至少2个数，那么最少挑选多少个？

输入描述:
第一行是N（N<10000）,表示有N个区间，之间可以重复
然后每一行是ai,bi，持续N行，表示现在区间。均小于100000

输出描述:
输出一个数，代表最少选取数量。

示例1
输入

4
4 7
2 4
0 2
3 6

输出

4

```
/*
* 思路：
* 1.将区间按照右端大小排列
* 2.如果第一个区间的right<第二个区间的left，说明两个区间没有交集，则第一个区间需要两个数
* 3.
* */
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] arr = new int[n][2];
        for(int i = 0; i < n; i ++) {
            arr[i][0] = sc.nextInt();
            arr[i][1] = sc.nextInt();
        }
  
        Arrays.sort(arr, (e1, e2) -> e1[1] - e2[1]);
  
        LinkedList<Integer> list = new LinkedList<>();
        list.add(arr[0][1] - 1);
        list.add(arr[0][1]);
        for(int i = 1; i < n; i ++) {
            if(arr[i][0] > list.peekLast()) { // 相离
                list.add(arr[i][1] - 1);
                list.add(arr[i][1]);
            } else if(arr[i][0] > list.get(list.size() - 2)) {
                list.add(arr[i][1]);
            }
        }
         
        System.out.println(list.size());
    }
}
```

----------
43

考虑你从家出发步行去往一处目的地，该目的地恰好离你整数单位步长（大于等于1）。你只能朝向该目的地或者背向该目的地行走，而你行走的必须为单位步长的整数倍，且要求你第N次行走必须走N步。
请就给出目的地离你距离，判断你是否可以在有限步内到达该目的地。如果可以到达的话，请计算到达目的地的最短总步数(不能到达则输出-1)。

输入描述:
1个整数：目的地离你距离T

输出描述:
1个整数：最短总步数（进行了多少次行走）

示例1
输入

2
输出

3
说明
距离目的地2， 需要3步：朝向走1，背向走2，朝向走3

```
广度优先算法

import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;
import static java.lang.System.in;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(in);
        int n = sc.nextInt();
        que.add(new Node(0, 0));
        //bfs搜索
        Node temp;
        int ans = 0;
        while (true) {
            temp = que.poll();
            if (temp.pos == n) {
                ans = temp.times;
                break;
            }
            que.offer(new Node(temp.pos + temp.times + 1, temp.times + 1));
            que.offer(new Node(temp.pos - temp.times - 1, temp.times + 1));
        }
        System.out.println(ans);
    }
    public static Queue<Node> que = new LinkedList();
    private static class Node{
        int pos;
        int times;
        public Node(int pos, int times) {
            this.pos = pos;
            this.times = times;
        }
    }
}
```

----------
44

有一个X*Y的网格，小团要在此网格上从左上角到右下角，只能走格点且只能向右或向下走。请设计一个算法，计算小团有多少种走法。给定两个正整数int x,int y，请返回小团的走法数目。

输入描述:
输入包括一行，空格隔开的两个正整数x和y，取值范围[1,10]。

输出描述:
输出一行，表示走法的数目
示例1
输入

3 2
输出

10
```
import java.io.*;
 
 
  public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        String[] xyStr=br.readLine().split(" ");
        int n=Integer.parseInt(xyStr[0])+1;
        int m=Integer.parseInt(xyStr[1])+1;
      int[][] a=new int[n][m];
        a[0][0]=0;
        a[0][1]=1;
        a[1][0]=1;
        for(int x=0;x<a.length;x++){
            for(int y=0;y<a[x].length;y++)
            {
                if(x!=0){
                    a[x][y]+=a[x-1][y];
                }
                if(y!=0){
                    a[x][y]+=a[x][y-1];
                }
            }
        }
        System.out.println(a[n-1][m-1]);
    }
    
}
```

----------
45

Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word is a valid dictionary word.
Return all such possible sentences.

输入描述:
s ="catsanddog"
dict ="cat", "cats", "and", "sand", "dog"

输出描述:
[cats and dog, cat sand dog]

示例1
输入

s ="catsanddog"
dict ="cat","cats","and","sand","dog"
输出

[cats and dog, cat sand dog]

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashSet;



public class Main {


    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        String s = bf.readLine().trim().split("\"")[1];
        String[] split = bf.readLine().trim().split("\"");
        HashSet<String> set = new HashSet<>();
        for (int i = 0; i < split.length; i++) {
            if (i % 2 != 0) {
                set.add(split[i]);
            }
        }
        ArrayList<String> res = new ArrayList<>();
        dfs(set, new StringBuilder(), s, res);
        //下面就是字符串的拼接了..........
        if (res.size() == 0){
            System.out.println("[]");
            return;
        }
        StringBuilder sb = new StringBuilder();
        sb.append('[');
        for (int i = 0; i < res.size() - 1; i++){
            String s1 = res.get(i);
            sb.append(s1.substring(0,s1.length()-1)).append(',').append(" ");
        }
        String s2 = res.get(res.size()-1);
        sb.append(s2.substring(0,s2.length()-1)).append(']');
        System.out.println(sb.toString());
    }

    private static void dfs(HashSet<String> set, StringBuilder sb, String s, ArrayList<String> list) {
        if (s.isEmpty()) {
            list.add(sb.toString());
            sb.delete(0, sb.length());
            return;
        }
        for (String item : set) {
            if (s.startsWith(item)) {
               dfs(set, sb.append(item).append(" "), s.substring(item.length()), list);
            }
        }
    }
}
```

----------
46

题目描述
给定一个字符串，输出所有指定长度为n的子串，没有则输出-1

输入描述:
输入第一行一个字符串，如：“1234567890”

输入第二行一个数字是n，如5

输出描述:
输出所有长度为n的子串，如“12345”，“23456”，“34567”，“45678”，“56789”

示例1
输入

123456789
5

输出

12345 23456 34567 45678 56789
```
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String s = in.nextLine();
        int n = in.nextInt();
        if (n<= 0 || n>s.length()){
            System.out.println(-1);
            return;
        }
        for (int i=0,j=n;j<=s.length();i++,j++){
            System.out.print(s.substring(i,j)+" ");
        }
    }
}

```

----------
47


整数的倒数

输入描述:
输入一个整数x

输出描述:
把x倒序输出

示例1
输入

123
输出

321

示例2
输入

-123

输出

-321

示例3
输入

-0
输出

-0
```
import java.util.*;
 
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        StringBuilder sb = new StringBuilder(scanner.next());
        if (sb.toString().charAt(0) == '-') {
            System.out.println("-" + new StringBuilder(sb.substring(1)).reverse());
        } else {
            System.out.println(sb.reverse());
        }
    }
}
```

----------
48

输入两个字符串a和b，字符串内容为二进制数字，求两个字符串相加的结果，加法计算方法以二进制方式计算，并返回对应的字符串结果。要求程序尽可能的高效。示例如下：

/**  

* @param a = "1101"  

* @param b = "1100"  

* @return "11001"  

*/ 

public String add(String a, String b){
}

输入描述:
输入两个字符串，如"1101", "1100"

输出描述:
"11001"

示例1
输入

1101 1100

输出

11001

```
public class Main{
    public static void main(String[] args){
        Main m=new Main();
        String a="110101";
        String b="1010110";
        String sum=m.add(a,b);
        System.out.println(sum);
    }
    public String add(String a,String b){
        int sum=Integer.valueOf(a,2)+Integer.valueOf(b,2);
        return Integer.toBinaryString(sum);
    }
}
```

----------
49

给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。
请注意，它是排序后的第k小元素，而不是第k个元素。

示例:

matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。
说明: 
你可以假设 k 的值永远是有效的, 1 ≤ k ≤ n2 。

输入描述:
第一行为k的值和矩阵的n的值

后续为n*n矩阵的数字，以空格分割

输出描述:
矩阵中第k小的元素

示例1
输入

8 3
1 5 9
10 11 13
12 13 15

输出

13
```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
 
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line = br.readLine();
        int n = Integer.valueOf(line.split(" ")[0]);
        int m = Integer.valueOf(line.split(" ")[1]);
        int[] arr = new int[m * m];
        int index = 0;
        for (int i = 0; i < m; i++) {
            String readLine = br.readLine();
            for (int j = 0; j < m; j++) {
                arr[index++] = Integer.valueOf(readLine.split(" ")[j]);
            }
        }
        Arrays.parallelSort(arr);
        System.out.println(arr[n - 1]);
    }
}
```

----------
50

字符串旋转:
给定两字符串A和B，如果能将A从中间某个位置分割为左右两部分字符串（都不为空串），并将左边的字符串移动到右边字符串后面组成新的字符串可以变为字符串B时返回true。
例如：如果A=‘youzan’，B=‘zanyou’，A按‘you’‘zan’切割换位后得到‘zanyou’和B相同返回true。

输入描述:
2个不为空的字符串(说明:输入一个字符串以英文分号";"分割为2个字符串)
例如:youzan;zanyou 即为A=‘youzan’，B=‘zanyou’

输出描述:
输出true或false(表示是否能按要求匹配两个字符串)

示例1
输入

youzan;zanyou
输出

true

示例2
输入

youzan;zyouan

输出

false

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
 
public class Main {
 
    private static boolean res(String a, String b) {
        if (a.length() != b.length()) return false;
        for (int i = 0; i < a.length(); i++) {
            StringBuilder sb = new StringBuilder();
            sb.append(a.substring(i, a.length())).append(a.substring(0, i));
            if (sb.toString().equals(b)) return true;
        }
        return false;
    }
 
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        String[] ss = bf.readLine().split(";");
        if (ss.length != 2) {
            System.out.println("false");
            return;
        }
        if (res(ss[0], ss[1])) {
            System.out.println("true");
        } else System.out.println("false");
    }
}
```

----------
51

给定一个非空的整数数组，从数组第一个元素(下标为0的元素)开始遍历进行移动，下一次向后或向前移动 该元素的值 的位数（值为正数向后移动，值为负数向前移动，值为零不移动），依次类推进行移动，若某次移动数组出现越界，则说明数组可以跳出，返回true；不能跳出则返回false；（加分项：也可考虑不增加使用其他集合数组辅助完成算法）
例1：
输入数组a[5] = [1,2,3,2,5];从第一个元素开始a[0]=1,下次向后移动1位到第二个元素a[1]=2,再次向后移动2位到第四个元素a[3],因为下次向后移动2位(a[3]=2)后,向后数组越界,即跳出数组,输出true;
例2：
输入数组a[2] = [1,-3];从第一个元素开始a[0]=1,下次移动1位到第二个元素a[1]=-3,再次向前移动3位后,向前数组越界,即跳出数组,输出true;


输入描述:
一个非空的整数数组(至少有一个元素,可正可负)

输出描述:
按规则移动后是否能跳出数组

示例1
输入

[1]

输出

true

示例2
输入

[2,1,3,5]

输出

true

示例3
输入

[2,1,-3]

输出

true

示例4
输入

[1,1,1,2,-1,1,-3]

输出

false

```
import java.util.*;
import java.io.*;
public class Main{
    public static void main(String[] args)throws IOException{
        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
        String str=bf.readLine();
        String[] str1=str.substring(1,str.length()-1).split(",");
        int[] n=new int[str1.length];
        for(int i=0;i<n.length;i++){
            n[i]=Integer.parseInt(str1[i]);
        }
        int index=0;
        for(int i=0;i<n.length;i++){
           index+=n[i];
            if (index < 0 || index >= n.length) {
                System.out.println(true);
                return;
            }
             
        }
        System.out.println(false);
    }
}
```

----------
52

给定一个数组A[n], 定义数组的众数 ( Majority Element) 为数组中出现次数超过 n/2 次的元素, 假设数组A[n]非空且一定存在众数, 请设计算法找到该众数并输出.

输入描述:
一个非空且一定存在众数的整数数组,如: [1,2,2]

输出描述:
输出打印该众数,如: 2

示例1
输入

[1,2,2]

输出

2

示例2
输入

[3,1,-2,3,1,3,3]

输出

3

摩尔投票法：给的数据中一定会出现次数超过n/2的数，那么如果数组中一次删去两个不同的数，那么最后剩下来的数一定是众数
```
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(in);
        String[] str = sc.nextLine().replace("[", "").replace("]", "").split(",");
        int[] data = new int[str.length];
        for (int i = 0; i < data.length; i++) {
            data[i] = Integer.parseInt(str[i]);
        }
        if (data.length == 1 || data.length == 2) {
            System.out.println(data[0]);
            return;
        }
        int hp = 0;
        int flag = data[0];
        for (int i = 0; i < data.length; i++) {
            if (hp == 0) {
                flag = data[i];
                hp++;
            } else if (data[i] == flag) {
                hp++;
            } else{
                hp--;
            }
        }
        System.out.println(flag);
    }
```

----------
53

给定一个无序的整型数组A[n],数组大小大于等于3,允许有值相同的元素;请设计算法找到该数组排序后第三大的元素值并输出.

输入描述:
一个非空的整数数组(至少有3个元素,可正可负)

输出描述:
第三大的元素值

示例1
输入

[1,2,3,4,5]

输出

3

示例2
输入

[1,1,2,2,3]

输出

2

示例3
输入

[6,5,4,4,1,2]
输出

4

```
import java.io.*;
import java.util.*;
public class Main{
    //时间复杂度为O(n)
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String str = br.readLine();
        String[] s = str.substring(1,str.length()-1).split(",");
        int[] arr = new int[s.length];
        for(int i = 0; i < s.length; i++)
            arr[i] = Integer.valueOf(s[i]);
        int first = Integer.MIN_VALUE;
        int second = Integer.MIN_VALUE;
        int third = Integer.MIN_VALUE;
        for(int i = 0; i < arr.length; i++){
            if(arr[i] > first){
                third = second;
                second = first;
                first = arr[i];
            }else if(arr[i] > second){
                third = second;
                second = arr[i];
            }else if(arr[i] > third){
                third = arr[i];
            }
        }
        System.out.println(third);
    }
}
```

----------

55

小云正在参与开发一个即时聊天工具，他负责其中的会话列表部分。

会话列表为显示为一个从上到下的多行控件，其中每一行表示一个会话，每一个会话都可以以一个唯一正整数id表示。

当用户在一个会话中发送或接收信息时，如果该会话已经在会话列表中，则会从原来的位置移到列表的最上方；如果没有在会话列表中，则在会话列表最上方插入该会话。

小云在现在要做的工作是测试，他会先把会话列表清空等待接收信息。当接收完大量来自不同会话的信息后，就输出当前的会话列表，以检查其中是否有bug。

输入描述:
输入的第一行为一个正整数T（T<=10），表示测试数据组数。
接下来有T组数据。每组数据的第一行为一个正整数N（1<=N<=200），表示接收到信息的次数。第二行为N个正整数，按时间从先到后的顺序表示接收到信息的会话id。会话id不大于1000000000。

输出描述:
对于每一组数据，输出一行，按会话列表从上到下的顺序，输出会话id。
相邻的会话id以一个空格分隔，行末没有空格。

示例1
输入

3
5
1 2 3 4 5
6
1 100 1000 1000 100 1
7
1 6 3 3 1 8 1

输出

5 4 3 2 1
1 100 1000
1 8 3 6

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashSet;
  
public class Main {
  
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(bf.readLine());
        for (int i = 0; i < n; i++) {
            int m = Integer.parseInt(bf.readLine());
            System.out.println(getDialogue(bf.readLine(),m));
        }
    }
  
    //用一个HashSet保存ID，做一个判断作用，从后往前遍历，如果set不包含该id，就添加进去。
    private static String getDialogue(String s, int m) {
        StringBuilder sb = new StringBuilder();
        HashSet<String> set = new HashSet<>();
        String[] ids = s.split(" ");
        for (int i = m - 1; i >= 0; i--) {
            if (!set.contains(ids[i])) {
                set.add(ids[i]);
                sb.append(ids[i]).append(" ");
            }
        }
        return sb.substring(0,sb.length()-1).toString();
    }
}
```

----------
56

现在你需要用一台奇怪的打字机书写一封书信。信的每行只能容纳宽度为100的字符，也就是说如果写下某个字符会导致行宽超过100，那么就要另起一行书写
信的内容由a-z的26个小写字母构成，而每个字母的宽度均会事先约定。例如字符宽度约定为[1,2,3,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]，那么就代表'a'到'd'四个字母的宽度分别是1,2,3,4，而'e'到'z'的宽度均为5
那么按照上述规则将给定内容S书写成一封信后，这封信共有几行？最后一行宽度是多少？

输入描述:
输入为两行：
第一行是存储了每个字符宽度的字符串，包含26个数字，以1个空格分隔，每个数字均小于等于10
第二行是存储了待输入字符的字符串S，字符串S的长度在1到1000之间

输出描述:
输出为信的行数以及最后一行所包含的字符个数，中间以1个空格分隔

示例1
输入

5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
helloworld

输出

1 50
说明
"5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5"规定每个字符宽度为5
"helloworld"是输入的字符串S
由于S共包含10个字符，也即共占用50个字符宽度，因此可以写在同一行

示例2
输入

5 5 5 5 5 5 10 10 10 10 10 10 10 10 10 10 10 10 5 5 5 5 5 5 5 5
hahahahahahahaha

输出

2 20

说明
"5 5 5 5 5 5 10 10 10 10 10 10 10 10 10 10 10 10 5 5 5 5 5 5 5 5"规定了每个字符宽度
"hahahahahahahaha"是输入的字符串S
由于h宽度为10，a宽度为5，因此'hahahahahahah'占用100字符宽度可以写在第一行，‘aha’写在第二行也即最后一行。因此字符宽度为20

备注:
输入及输出均为字符串

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
 

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        String[] str;
        String message;
        str = bf.readLine().split(" ");
        message = bf.readLine();
 
        int n = 26;
        int[] weight = new int[n];
        for (int i = 0; i < n; i++) {
            weight[i] = Integer.parseInt(str[i]);
        }
 
        int num = 1;
        int length = 0;
 
        int l = message.length();
        for (int i = 0; i < l; i++) {
            length += weight[message.charAt(i) - 'a'];
            if (length > 100){
                num++;
                length = 0;
                i--;
            }
        }
 
        System.out.println(num + " " + length);
 
    }
}
```

----------

59

给定一个字符串（数字或大小写字母）, 找出最长的对称的子串（如有多个，输出任意一个）。
例如：
输入：“abbaad”

输出：“abba”

输入描述:
字符串

输出描述:
字符串

示例1
输入

a1223a

输出

22



思路是：先确定中心再向两边延伸，回文串有两种：
①中心的两个字符是一样的，如"abccba"；
②中心只有一个字符，如"abcba"。

所以针对两种情况要分别来求：
①针对第一种，每个字符都可以是中心；
②针对第二种，必须先找到"cc"，即通过s[i] == s[i - 1]这样的判断找到两个c中的某一个，然后向两边延伸着找。
```
import java.util.*;
public class Main {
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        String input = in.nextLine();
        System.out.println(solve(input));
    }
 
    public static String solve(String s) {
        if (s == null || s.length() < 1) return "";
        int start = 0, end = 0;
        for (int i = 0; i < s.length(); i++) {
            int len1 = expandAroundCenter(s, i, i);
            int len2 = expandAroundCenter(s, i, i + 1);
            int len = Math.max(len1, len2);
            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        return s.substring(start, end + 1);
    }
 
    private static int expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return right - left - 1;
    }
}
```

----------
60

给定两个数字（0-9）字符串（长度不限）求它们的乘积。

输入描述:
第一行为第一个数字字符串

第二行为第二个数字字符串

输出描述:
乘积字符串

示例1
输入

123
20

输出

2460

```
import java.math.BigInteger;
import java.util.Scanner;
 
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        BigInteger bi1 = new BigInteger(scanner.next());
        BigInteger bi2 = new BigInteger(scanner.next());
        System.out.println(bi1.multiply(bi2));
    }
}
```

----------
61

给定一个二维整型矩阵，已知矩阵的每一行都按照从小到大的顺序排列，每一列也都按照从小到大的顺序排列。现在给出一个数，请写一个函数返回该数是否存在于矩阵中。
矩阵中出现的数字与需要查找的数(k)都为0~100000之间的整数，且矩阵的大小在3000*3000以内。
在保证正确性的基础上，请尽量给出比较高效的解法。请列出你的算法时间复杂度与空间复杂度分别是多少？

输入描述:
输入两个整数m,n, 且 0<m<=3000, 0<n<=3000。

接着输入一个vector<vector<int>> matrix矩阵，大小为m行n列，与一个int k，为需要查找的数字。
输出描述:
输出true或者false，true表示该数k存在于该matrix矩阵中，false表示该数k不存在于该matrix矩阵中。

示例1
输入

3 3
​​2 3 5
​​3 4 7
​​3 5 8
4
输出

true
说明
4位于矩阵的第二行第二列，故输出true

```
链接：https://www.nowcoder.com/questionTerminal/dd5b5b2df5f84bae9b26c99a0a8f8660?f=discussion
来源：牛客网

import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        int[][] matrix=null;
        int a=0,b=0;
            
        a = in.nextInt();
        b = in.nextInt();
        matrix=new int[a][b];
 
        for(int i=0;i<a;i++){
            for(int j=0;j<b;j++){
                matrix[i][j]=in.nextInt();
            }
        }
         
        int target=in.nextInt();
        System.out.println(findx(matrix,target) || findy(matrix,target));
          
    }
     
    /*
    二分法：在最右边的列，用二分法查找目标数所在的行，然后对这一行数使用二分查找
    findx 和 findy 函数类似。
     
    */
    public static boolean findx(int[][] matrix,int target){
        int COL = matrix[0].length-1;//计算矩阵的列
        int ROW = matrix.length-1;//计算矩阵的行
        int low  = 0;
        int high = ROW;
        /*
        第一次二分查找：
            找到target所在的行
        */
        while(low < high){
            int mid = low + (high-low)/2;
            if(matrix[mid][COL] < target){
                low = mid + 1;
            }else{
                high = mid;
            }
        }
 
        int  left = 0;
        int right = COL;
        /*
        第二次二分查找：
            在行中查找到target
        */
        while(left < right){
            int mid = left + (right - left)/2;
            if(matrix[low][mid] < target){
                left  = mid + 1 ;
            }else{
                right = mid;
            }
        }
         
        /*判断是否找到target*/
        if(matrix[low][left]==target){
            return true;
        }
        return false;
    }
     
    /*二分法：在最左边的列，寻找目标数所在的行，然后对这一行数使用二分查找*/
    public static boolean findy(int[][] matrix,int target){
        int COL = matrix[0].length-1;  //计算矩阵的列
        int ROW = matrix.length-1;  //计算矩阵的行
        int low  = 0;
        int high = ROW;
        /*找点的时候，考虑特殊情况，比如target位于low 和 high之间，也就是找不到target*/
        while(low < high){
            int mid = low + (high-low+1)/2;
            if(matrix[mid][0] <= target){
                low = mid;
            }else{
                high = mid-1;
            }
        }
 
        int  left = 0;
        int right = COL;
        while(left < right){
            int mid = left + (right - left)/2;
            if(matrix[low][mid] < target){
                left  = mid + 1 ;
            }else{
                right = mid;
            }
        }
        /*判断是否找到target*/
        if(matrix[low][left]==target){
            return true;
        }
        return false;
    }
     
}
```

----------
62

设计一个函数， 可以将任意十进制的数， 转换成任意2到9的进制表示的形式

输入描述:
需要转换的数字x(0<=x<=1e18) 转换使用的进制k(2<=k<=9)

输出描述:
对应进制的结果

示例1
输入

33 2
输出

100001
```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        String[] str = bf.readLine().split(" ");
        Long x = new Long(str[0]);
        int k = Integer.parseInt(str[1]);
        StringBuilder  res = new StringBuilder();
        if (x == 0) {
            System.out.println(0);
            return;
        }else {
            while (x > 0) {
                res.append(x % k);
                x = x / k;
            }
            System.out.println(res.reverse().toString());
        }
    }
}
```

----------
63

给出一个数字N（0<N<1000000）,将N写成立方数和的形式，求出需要的最少立方数个数。
例如N=17，1+8+8 = 17，最少需要3个立方数，则输出3。
N= 28,1+1+1+1+8+8+8=28, 需要7个立方数，1+27=28,需要2个立方数，所以最少立方数为2，则输出2。

输入描述:
一个数字N（0<N<1000000）

输出描述:
最少立方数个数

示例1
输入

28

输出

2
```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
 
public class Main {
 
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        br.close();
 
        int[] rec = new int[n + 1];
 
        for (int i = 1; i <= n; i++) {
            int min = i - 1;
            for (int j = 1; j * j * j <= i; j++) {
                min = Math.min(min, rec[i - j * j * j]);
            }
            rec[i] = 1 + min;
        }
 
        System.out.println(rec[n]);
    }
}
```

----------

66

给定任意一个较短的子串，和另一个较长的字符串，判断短的字符串是否能够由长字符串中的字符构建出来，且长串中的每个字符只能用一次。
输入描述:
一行数据包括一个较短的字符串S和一个较长的字符串T，用一个空格分隔。保证1<=|S|<=|T|<=100000。

输出描述:
如果短的字符串可以由长字符串中的字符构建出来，输出字符串 “true”，否则输出字符串 "false"。

示例1
输入

a b

输出

false

示例2
输入

fj jfiejfiejfie

输出

true

```
import java.util.Scanner;
 
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.next();
        String t = scanner.next();
        int[] chs = new int[26];
        for (int i = 0; i < t.length(); i++) {
            chs[t.charAt(i) - 'a']++;
        }
        for (int i = 0; i < s.length(); i++) {
            chs[s.charAt(i) - 'a']--;
        }
        for (int i : chs) {
            if (i < 0) {
                System.out.println("false");
                return;
            }
        }
        System.out.println("true");
    }
}
```

----------

70

有N个比赛队（1<=N<=500），编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。

输入描述:
输入有若干组，每组中的第一行为二个数N（1<=N<=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。

输出描述:
给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。
其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。

示例1
输入

4 3
1 2
2 3
4 3

输出

1 2 4 3

```
import java.io.*;
import java.util.*;
  
  
public class Main {
  
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        String str;
        while ((str = bf.readLine()) != null) {
            String[] line1 = str.split(" ");
            int n = Integer.parseInt(line1[0]);//队伍的个数
            int m = Integer.parseInt(line1[1]);//总共有m场比赛
            //记录n个队伍比赛输掉的次数
            int[] num1 = new int[n + 1];
            PriorityQueue<Integer> queue = new PriorityQueue<>();
            //记录第i个队伍赢得的队伍
            HashMap<Integer, ArrayList<Integer>> map = new HashMap<>(m);
            int a, b;
            for (int i = 1; i <= m; i++) {
                line1 = bf.readLine().split(" ");
                a = Integer.parseInt(line1[0]);//赢比赛的队伍
                b = Integer.parseInt(line1[1]);//输比赛的队伍
                if (!map.containsKey(a)) {
                    map.put(a, new ArrayList<>());
                }
                map.get(a).add(b);
                //eg：b队伍输的次数加一
                num1[b]++;
            }
            for (int i = 1; i <= n; i++) {//将那些没有输过比赛的队伍加到优先队列中,题目要求相同排名的编号小的放在前面
                if (num1[i] == 0) queue.add(i);
            }
            //保存输出结果
            StringBuilder sb = new StringBuilder();
            while (!queue.isEmpty()) {
                int top = queue.poll();
                sb.append(top);
                sb.append(" ");
                for (int i = 0; map.containsKey(top) && i < map.get(top).size(); i++) {
                    int x = map.get(top).get(i);
                    num1[x]--;
                    if (num1[x] == 0) queue.add(x);
                }
            }
            sb.substring(0,sb.length()-1);
            System.out.println(sb.toString());
        }
    }
}
```

----------
71

找出单向链表中的一个节点，该节点到尾指针的距离为K。链表的倒数第0个结点为链表的尾指针。要求时间复杂度为O(n)。
链表结点定义如下：
struct ListNode
{
    int m_nKey;
    ListNode* m_pNext;
}
链表节点的值初始化为1，2，3，4，5，6，7。

输入描述:
该节点到尾指针的距离K

输出描述:
返回该单向链表的倒数第K个节点，输出节点的值

示例1
输入

2
输出

6
备注:
请自觉实现一个链表，将1到7依次加入链表，然后再寻找倒数第K个节点。要求加节点与找节点的操作复杂度均为O(n)。

```
import java.io.*;
import java.util.*;


public class Main {
    public static void main (String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        ListNode head = new ListNode(0);
        ListNode fast = head, slow = head;
        for (int i = 0; i < 7; i++){
            ListNode node = new ListNode(i + 1);
            fast.next = node;
            fast = node;
        }
        int n = Integer.parseInt(br.readLine());
        fast = head;
        for (int i = 0; i < n; i++){
            fast = fast.next;
        }

        while (fast != null && slow != null){
            fast = fast.next;
            slow = slow.next;
        }
        System.out.println(slow.val);
    }
}
```

----------
72

输入一个无序整数数组，调整数组中数字的顺序， 所有偶数位于数组的前半部分，使得所有奇数位于数组的后半部分。
要求时间复杂度为O(n)。

输入描述:
给定无序数组。
长度不超过1000000。

输出描述:
所有偶数位于数组的前半部分，所有奇数位于数组的后半部分。
如果有多个答案可以输出任意一个正确答案。

示例1
输入

2 4 5 7 8 1

输出

2 4 8 7 5 1
备注:
请自觉使用O(n)的算法。

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
 
public class Main {
 
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        String str = bf.readLine();
        String[] strs = str.split(" ");
        int len = strs.length;
        int[] ans = new int[len];
        int left = 0, right = len - 1;
        for (int i = 0; i < len; i++) {
            int a = Integer.parseInt(strs[i]);
            if ((a & 1) == 0) {//偶数
                ans[left++] = a;
            } else {
                ans[right--] = a;
            }
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < len-1; i++) {
            sb.append(ans[i]);
            sb.append(" ");
        }
        System.out.println(sb.append(ans[len-1]).toString());
    }
}
```

----------
73

一组带数字编号的球里除了两个编号之外，其它的编号都出现了两次。
请写程序找出这两个只出现一次的编号。要求时间复杂度是O(n)，空间复杂度是O(1)。

输入描述:
整形数组
长度不超过1000000

输出描述:
输出数组中2个只出现了一次的数
先输出较小的数

示例1
输入

1
2
3
4
5
2
3
4
5
6

输出

1 6
```
import java.io.*;
public class Main{
    public static void main(String[] args)throws IOException{
        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
        String s=null;
        int ans=0,index=0;
        int[] arr=new int[1000000];
        while((s=bf.readLine())!=null){
            arr[index]=Integer.parseInt(s);
            ans^=arr[index];
            index++;
        }
        int a=0,b=0;
        ans&=-ans;
        for(int i=0;i<index;i++){
            if((arr[i]&ans)==0)
                a^=arr[i];
            else
                b^=arr[i];
        }
        System.out.println(Math.min(a,b)+" "+Math.max(a,b));
         
    }
}
```

----------
74

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个排好序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数组的最小值为1。

输入描述:
一个排好序的数组的一个旋转
数组长度不超过1000000

输出描述:
该数组的最小值
示例1
输入

3 4 5 1 2

输出

1

```
import java.io.*;
public class Main {
    public int minNumberInRotateArray(int [] a) {
        if(a==null || a.length < 1) return 0;
        if(a.length == 1) return a[0];
        int i=0;
        int j=a.length-1;
        int mid=0;
        while(i <= j){
            if(j-i == 1) return a[j];
            mid=(i+j)/2;
            if(a[i] == a[mid] && a[mid] == a[j]) return getMinNum(a);
            if(a[mid] > a[j]) i=mid;
            else if(a[mid] <= a[j]) j=mid;
        }
        return a[mid];
    }
    //当存在重复数据的时候直接进行遍历获取最小的数值
    public int getMinNum(int[] a){
        int ans=a[0];
        for(int num:a){
            ans=num > ans ? ans:num;
        }
        return ans;
    }
    public static void main(String[] args) throws Exception{
        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
        String[] words=bf.readLine().split(" ");
        int[] a=new int[words.length];
        for(int i=0;i<a.length;i++){
            a[i]=Integer.parseInt(words[i]);
        }
        System.out.println(new Main().minNumberInRotateArray(a));
        bf.close();
          
    }
}
```

----------

76

设计一个函数，两个参数，第一个参数为整数的数组，第二个参数为标杆值，取数组中任意符合两个数相加为标杆值的下标相加到一起的值
传入一串字符串（如下例子所示），转义为数组，除去数组中最后一位数字作为标杆值，取数组中任意符合两个数相加为标杆值的下标，输出所有符合要求的下标的和。
如下解释：
value：0,1,5,11,17,16,2,5,10,30,12
index：1 3  6  8
输出结果为18

输入描述:
一串数字，逗号分割，最后一个值为标杆值
数组长度不超过1000，所有数均为不超过1e9的正整数。

输出描述:
结果值

示例1
输入

0,1,5,11,17,16,2,5,10,30,12

输出

18

示例2
输入

1,1,1,2

输出

6

说明
(0+1)+(0+2)+(1+2)=6

```
import java.io.*;
public class Main {
    public static void main(String args[]) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] str = br.readLine().split(",");
        int value = Integer.parseInt(str[str.length - 1]);   //标杆值
        int[] arr = new int[str.length - 1];
        for (int i = 0; i < arr.length; i++)     //数组
            arr[i] = Integer.parseInt(str[i]);
        int sum = 0;    //和
        for (int i = 0; i < arr.length - 1; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[i] + arr[j] == value)
                    sum = sum + i + j;
            }
        }
        System.out.println(sum);
    }
}
```

----------

82

依次给出n个正整数A1，A2，… ，An，将这n个数分割成m段，每一段内的所有数的和记为这一段的权重， m段权重的最大值记为本次分割的权重。问所有分割方案中分割权重的最小值是多少？
输入描述:
第一行依次给出正整数n，m，单空格切分；(n <= 10000, m <= 10000, m <= n)
第二行依次给出n个正整数单空格切分A1，A2，… ，An  (Ai <= 10000)

输出描述:
分割权重的最小值

示例1
输入

5 3
1 4 2 3 5

输出

5
说明
分割成 1  4 |   2   3  |   5  的时候，3段的权重都是5，得到分割权重的最小值。

```
import java.io.BufferedReader;
import java.io.InputStreamReader;
 
// 102 最优分割
public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        String s = in.readLine();
        String[] ss = s.split(" ");
        int n = Integer.valueOf(ss[0]);
        int m = Integer.valueOf(ss[1]);
        s = in.readLine();
        ss = s.split(" ");
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = Integer.valueOf(ss[i]);
        }
        System.out.println(solve(nums, m));
    }
 
 
    // 结果在（max(nums),sum(nums))之间，使用二分查找
    // 以[7,2,5,10,8]举例，开始假设只有一个子数组,set=1
    // 第一个 mid = (10+32)/2=21, 然后把数字一个一个塞进去
    // 先塞7, 7<21, 7+2<21, 7+2+5<21, 直到 7+2+5+10>21
    // 意味着一个数组放不下, set+1=2, 然后把后面的塞完
    // 如果比m大说明我们开的子数组太多, 也就意味值我们数组容量(mid)太小
    // 所以我们就从[22,32]区间中找, 否则在[10,21]中找
    private static int solve(int[] nums, int m) {
        // 数组中最大元素
        int max = 0;
        // 数组的 和
        int sum = 0;
        for (int v : nums) {
            max = Math.max(max, v);
            sum += v;
        }
 
        int left = max, right = sum;
        int mid = 0;
        // 当前子数组的和
        int curSum = 0;
        // nums 分割后的子数组数量
        int setCount = 0;
        while (left < right) {
            // 所有子数组的和最大不能超过 mid
            mid = left + (right - left) / 2;
            setCount = 1;
            curSum = 0;
 
            // 分割数组
            for (int v : nums) {
                if (curSum + v > mid) {
                    setCount++;
                    curSum = 0;
                }
                curSum += v;
            }
 
            if (setCount > m) {
                left = mid + 1;
            } else {
                right = mid;
            }
 
        }
        return left;
    }
}
```

----------

84

现在有一幅扑克牌，去掉大小王52张牌。随机选出4张牌，可以任意改变扑克牌的顺序，并填入 + - * / 四个运算符，不用考虑括号，除法按整数操作，计算过程中没有浮点数，问是否能够求值得到给定的数m。

输入描述:
一行四个数字 （JQK 分别被替换成11，12，13）单空格分割，另一行输入 m

输出描述:
可以输出1
否则输出0

示例1
输入

13 13 13 13 
24

输出

0
备注:
提示：
注意运算符优先级

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
 
public class Main {
    private static int m = 0;
 
    public static void main(String[] args) {
        try {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            String[] s = br.readLine().split(" ");
            int a = Integer.parseInt(s[0]);
            int b = Integer.parseInt(s[1]);
            int c = Integer.parseInt(s[2]);
            int d = Integer.parseInt(s[3]);
            m = Integer.parseInt(br.readLine());
            System.out.println(fun2(a, b, c, d));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
 
    private static boolean fun(int a, int b, int c, int d) {
        return ((a + b + c + d == m) || (a + b + c - d == m) || (a + b + c * d == m) || (a + b + c / d == m)
                || (a + b - c + d == m) || (a + b - c - d == m) || (a + b - c * d == m) || (a + b - c / d == m)
                || (a + b * c + d == m) || (a + b * c - d == m) || (a + b * c * d == m) || (a + b * c / d == m)
                || (a + b / c + d == m) || (a + b / c - d == m) || (a + b / c * d == m) || (a + b / c / d == m)
                || (a - b + c + d == m) || (a - b + c - d == m) || (a - b + c * d == m) || (a - b + c / d == m)
                || (a - b - c + d == m) || (a - b - c - d == m) || (a - b - c * d == m) || (a - b - c / d == m)
                || (a - b * c + d == m) || (a - b * c - d == m) || (a - b * c * d == m) || (a - b * c / d == m)
                || (a - b / c + d == m) || (a - b / c - d == m) || (a - b / c * d == m) || (a - b / c / d == m)
                || (a * b + c + d == m) || (a * b + c - d == m) || (a * b + c * d == m) || (a * b + c / d == m)
                || (a * b - c + d == m) || (a * b - c - d == m) || (a * b - c * d == m) || (a * b - c / d == m)
                || (a * b * c + d == m) || (a * b * c - d == m) || (a * b * c * d == m) || (a * b * c / d == m)
                || (a * b / c + d == m) || (a * b / c - d == m) || (a * b / c * d == m) || (a * b / c / d == m)
                || (a / b + c + d == m) || (a / b + c - d == m) || (a / b + c * d == m) || (a / b + c / d == m)
                || (a / b - c + d == m) || (a / b - c - d == m) || (a / b - c * d == m) || (a / b - c / d == m)
                || (a / b * c + d == m) || (a / b * c - d == m) || (a / b * c * d == m) || (a / b * c / d == m)
                || (a / b / c + d == m) || (a / b / c - d == m) || (a / b / c * d == m) || (a / b / c / d == m));
    }
 
    private static int fun2(int a, int b, int c, int d) {
        if (fun(a, b, c, d) || fun(a, b, d, c) || fun(a, c, b, d)
                || fun(a, c, d, b) || fun(a, d, b, c) || fun(a, d, c, b)
                || fun(b, a, c, d) || fun(b, a, d, c) || fun(b, c, a, d)
                || fun(b, c, d, a) || fun(b, d, a, c) || fun(b, d, c, a)
                || fun(c, a, b, d) || fun(c, a, d, b) || fun(c, b, a, d)
                || fun(c, b, d, a) || fun(c, d, a, b) || fun(c, d, b, a)
                || fun(d, a, b, c) || fun(d, a, c, b) || fun(d, b, a, c)
                || fun(d, b, c, a) || fun(d, c, a, b) || fun(d, c, b, a)) {
            return 1;
        }
        return 0;
    }
}
```

----------
86

给出一个字符串格式的化学分子式，计算原子的个数
每个化学元素都是由一个大写字母，或者一个大写字母后跟着若干个小写字母组成，例如H是一个化学元素，Mg也是一个化学元素。
每个分子式中，原子的个数写在元素后面，如果原子个数是1，那么原子个数省略。例如H2O和H2O2都是有效的分子式，但H1O2不是有效分子式。
每个分子式中包含若干括号，为简单起见，分子式中只有小括号。
每次输入一个分子式，对每个给定的分子式，求出每个原子的个数，按照原子字母表的顺序排列，并输出。

输入描述:
一行，一个字符串表示输入的分子式

输出描述:
按要求输出答案

示例1
输入

H2O

输出

H2O

示例2
输入

Mg(OH)2

输出

H2MgO2

示例3
输入

K4(ON(SO3)2)2

输出

K4N2O14S4
```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
 
/**
 * 给出一个字符串格式的化学分子式，计算原子的个数
 * 每个化学元素都是由一个大写字母，或者一个大写字母后跟着若干个小写字母组成，例如H是一个化学元素，Mg也是一个化学元素。
 * 每个分子式中，原子的个数写在元素后面，如果原子个数是1，那么原子个数省略。例如H2O和H2O2都是有效的分子式，但H1O2不是有效分子式。
 * 每个分子式中包含若干括号，为简单起见，分子式中只有小括号。
 * 每次输入一个分子式，对每个给定的分子式，求出每个原子的个数，按照原子字母表的顺序排列，并输出。
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s = br.readLine();
        StringBuffer sb = new StringBuffer();
        int [] res = AddToSB(s.toCharArray(),0,s.length()-1);
        for (int i = 0; i < res.length; i++) {
            if (res[i] > 0) {
                System.out.print(toString(i));
                if (res[i] > 1) System.out.print(res[i]);
            }
        }
    }
 
    private static String toString(int i) {
        StringBuffer sb = new StringBuffer();
        sb.append((char)('A'+i/27));
        if (i % 27 != 0) sb.append((char)('a'+i%27-1));
        return sb.toString();
    }
 
    private static int[] AddToSB(char[] chs,int i,int j) {
        int [] res= new int[27 * 26];
        while (i < j+1){
            if (chs[i] >= 'A' && chs[i] <= 'Z'){
                char c = chs[i];
                if (i+1<j+1 && chs[i+1] >= 'a' && chs[i+1] <= 'z'){
                    i++;
                    int k = (c - 'A') * 27 + 1 + (chs[i] - 'a');
                    if (i+1<j+1 && Character.isDigit(chs[i+1])){
                        int p = 0;
                        i++;
                        while (i<j+1 && Character.isDigit(chs[i])){
                            p = p * 10 + chs[i++] - '0';
                        }
                        res[k] += p;
                    }else {
                        res[k]++;
                        i++;
                    }
                }else if (i+1<j+1 && Character.isDigit(chs[i+1])){
                    int p = 0;
                    i++;
                    while (i<j+1 && Character.isDigit(chs[i])){
                        p = p * 10 + chs[i++] - '0';
                    }
                    res[27 * (c - 'A')] += p;
                }else {
                    res[27 * (c - 'A')]++;
                    i++;
                }
            }else {
                int kh = 1;
                int start = ++i;
                while (i<j+1 && kh != 0){
                    if (chs[i] == '(') kh++;
                    else if (chs[i] == ')') kh--;
                    i++;
                }
                int[] sub = AddToSB(chs,start,i-2);
                int p = chs[i++] - '0';
                while (i < j + 1 && Character.isDigit(chs[i])){
                    p = p * 10 + chs[i++] - '0';
                }
                for (int k = 0; k < sub.length; k++) {
                    res[k] += sub[k] * p;
                }
            }
        }
        return res;
    }
}
```

----------
87

小明同学需要对一个长度为 N 的字符串进行处理，他需要按照要求执行若干步骤，每个步骤都均为下面 2 种操作中的一种，2 种操作如下：
TYPE 1. 从字符串结尾开始算起，将第 X 个字符之前的字符移动到字符串末尾
TYPE 2. 输出字符串索引为 X 的字符
小明尝试了很久没能完成，你可以帮他解决这个问题吗？

输入描述:
第一行，包含两个整数，字符串的长度 N 和操作次数T；
第二行为要操作的原始字符串；

之后每行都是要执行的操作类型 TYPE 和操作中 X 的值，均为整数。

输入范围：
字符串长度 N：1 <= N <= 10000
操作次数 T：1 <= T <= 10000
操作类型 TYPE：1 <= TYPE<= 2
变量 X：0 <= X < N

输出描述:
操作的执行结果
示例1
输入

6 2
xiaomi
1 2
2 0

输出

m

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
 
public class Main {
    public static void main(String[] args) {
        try {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            String[] s = br.readLine().split(" ");
            int n = Integer.parseInt(s[0]);
            int t = Integer.parseInt(s[1]);
            int type, x, start = 0;
            String str = br.readLine();
            for (int i = 0; i < t; i++) {
                String[] st = br.readLine().split(" ");
                type = Integer.parseInt(st[0]);
                x = Integer.parseInt(st[1]);
                if (type == 1 && n >= x) {
                    start = (start + n - x) % n;
                } else if (type == 2 && n > x) {
                    System.out.println(str.charAt((start + x) % n));
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

----------

89

在你面前有一个n阶的楼梯(n>=100且n<500)，你一步只能上1阶或3阶。
请问计算出你可以采用多少种不同的方式爬完这个楼梯（到最后一层为爬完）。
(注意超大数据)

输入描述:
一个正整数，表示这个楼梯一共有多少阶

输出描述:
一个正整数，表示有多少种不同的方式爬完这个楼梯

示例1
输入

100

输出

24382819596721629
备注:
注意时间限制

```
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.math.BigInteger;
 
public class Main {
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        BigInteger[] count = new BigInteger[n];
        count[0] = new BigInteger("1");
        count[1] = new BigInteger("1");
        count[2] = new BigInteger("2");
        for (int i = 3; i < n; i++) {
            count[i] = count[i - 1].add(count[i - 3]);
        }
        System.out.println(count[n - 1]);
    }
}
```

----------


----------

93

有N个孩子站成一排，每个孩子有一个分值。给这些孩子派发糖果，需要满足如下需求：

1、每个孩子至少分到一个糖果

2、分值更高的孩子比他相邻位的孩子获得更多的糖果

求至少需要分发多少糖果？

输入描述:
0,1,0

输出描述:
4

示例1
输入

5,4,1,1
输出

7
```
import java.io.*;
import java.util.Arrays;
    
public class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] s = br.readLine().split("\\,");
        int[] arr = new int[s.length], sum = new int[s.length];
        Arrays.fill(sum, 1);
        for(int i=0; i<s.length; i++){
            arr[i] = Integer.parseInt(s[i]);
            if(i>=1&&arr[i]>arr[i-1]){
                sum[i]=sum[i-1]+1;
            }
        }
        for(int i=s.length-1; i>=1; i--){
            if(arr[i]<arr[i-1]){
                sum[i-1] = Math.max(sum[i-1], sum[i]+1);
            }
        }
        int ans = 0;
        for(int temp: sum){
            ans += temp;
        }
        System.out.println(ans);
    }
}
```

----------
94

给定一个由小写字母组成的字符串s，请将其分割成尽量多的子串，并保证每个字母最多只在其中一个子串中出现。请返回由一个或多个整数表示的分割后各子串的长度。

输入描述:
来自标准输入的一行由小写字母组成的字符串。

输出描述:
字符串最优分割后各子串的长度，多个数字之间由空格分隔。

示例1
输入

ababbacadefgdehijhklij

输出

8 6 8
说明
该样例下最优的分割为"ababbaca" + "defgde" + "hijhklij"，在该分割下字母abc仅出现在"ababbaca"中、字母defg仅出现在"defgde"中、字母hijkl仅出现在"hijhklij"中
要求将其“分割为尽量多的子串”意味着像"ababbacadefgde" + "hijhklij"这样的分割也是合法的，但在本题中并不是最优解

```
public class Main {
 
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        String s = bf.readLine();
        StringBuilder sb = new StringBuilder();
        while (s.length() > 0) {
            int index = s.lastIndexOf(s.charAt(0));//首先找到第一个字符的最后索引的位置，在再这个范围内找出子串的最大长度
            for (int i = 1; i < index; i++) {
                index = Math.max(s.lastIndexOf(s.charAt(i)), index);
            }
            sb.append(index + 1).append(" ");
            s = s.substring(index + 1);
        }
        System.out.println(sb.substring(0, sb.length() - 1).toString());
    }
 
}
```

----------
95

输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

输入描述:
输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母,例如ac

输出描述:
[ac, ca]

示例1
输入

acc
输出

[acc, cac, cca]

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;
 
public class Main {
    static List<String> list = new ArrayList<>();
    public static void main(String[] args) throws IOException{
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        char[] cs = in.readLine().toCharArray();
        Arrays.sort(cs);
        boolean[] v = new boolean[cs.length];
        dfs(cs, 0, new StringBuilder(), v);
        String s = "[" + String.join(", ", list.toArray(new String[0])) + "]";
        System.out.println(s);
    }
    public static void dfs(char[] cs, int size, StringBuilder sb, boolean[] v){
        if(size == cs.length) list.add(new String(sb));
        else{
            for(int i = 0; i < cs.length; i++){
                if(v[i] || i > 0 && cs[i-1] == cs[i] && !v[i-1]) continue;
                v[i] = true;
                sb.append(cs[i]);
                dfs(cs, size+1, sb, v);
                v[i] =  false;
                sb.deleteCharAt(size);
            }
        }
    }
}
```

----------
96

有一个X*Y的网格，小团要在此网格上从左上角到右下角，只能走格点且只能向右或向下走。请设计一个算法，计算小团有多少种走法。给定两个正整数int x,int y，请返回小团的走法数目。

输入描述:
输入包括一行，空格隔开的两个正整数x和y，取值范围[1,10]。

输出描述:
输出一行，表示走法的数目

示例1
输入

3 2
输出

10

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
 
public class Main {
    static public void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] str1 = br.readLine().split(" ");
        int x = Integer.parseInt(str1[0]);
        int y = Integer.parseInt(str1[1]);
        System.out.println(dpCal(x,y));
 
    }
    static int dpCal (int x, int y ){
        int[][] array = new int[x+1][y+1];
        for (int i=0; i<=x;i++){
            for (int j=0; j<=y;j++){
                array[i][j] =1;
            }
        }
        for (int i=1; i<=x;i++) {
            for (int j =1; j<=y; j++) {
                array[i][j]=array[i][j-1]+array[i-1][j];
            }
        }
        return array[x][y];
    }
}
```

----------
97

给定一个字符串，输出所有指定长度为n的子串，没有则输出-1
输入描述:
输入第一行一个字符串，如：“1234567890”

输入第二行一个数字是n，如5

输出描述:
输出所有长度为n的子串，如“12345”，“23456”，“34567”，“45678”，“56789”

示例1
输入

123456789
5

输出

12345 23456 34567 45678 56789

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
   
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        String s = bf.readLine();
        int n = Integer.parseInt(bf.readLine());
        if(n>0 && n<=s.length()){
            for(int i=0; i<=s.length()-n; i++){
                System.out.print(s.substring(i, i+n) + " ");
            }
        }else{
            System.out.print(-1);
        }
    }
}
```

----------
98

请编写一段代码，实现两个单向有序链表的合并
输入描述:
第一行一个链表，如1 2 3 4 5

第二行一个链表，如2 3 4 5 6
输出描述:
输出：1 2 2 3 3 4 4 5 5 6
示例1
输入

1 2 3 4 5
2 3 4 5 6

输出

1 2 2 3 3 4 4 5 5 6
```
import java.io.*;
import java.util.*;
public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] line1 = br.readLine().split(" ");
        String[] line2 = br.readLine().split(" ");
        int[] arr1 = new int[line1.length];
        int[] arr2 = new int[line2.length];
        int[] newarr = new int[line1.length+line2.length];
        for(int i=0;i<arr1.length;i++){
            arr1[i]= Integer.parseInt(line1[i]);
        }
        for(int i=0;i<arr2.length;i++){
            arr2[i]= Integer.parseInt(line2[i]);
        }
        int idx1=0;
        int idx2=0;
        int idx=0;
        while(idx1!=arr1.length&&idx2!=arr2.length){
            if(arr1[idx1]<=arr2[idx2]){
                newarr[idx++]=arr1[idx1++];
            }else{
                newarr[idx++]=arr2[idx2++];
            }
        }
         
        while(idx1!=arr1.length){
            newarr[idx++]=arr1[idx1++];
        }
         
         while(idx2!=arr2.length){
            newarr[idx++]=arr2[idx2++];
        }
         
        for(int i=0;i<line1.length+line2.length;i++){
            System.out.print(newarr[i]);
            if(i!=(line1.length+line2.length-1)){
                System.out.print(" ");
            }
        }
    }
}
```

----------
99

小M突然对怪数产生了兴趣。假设一个数n，如果[n/1]+[n/2]+...+[n/k](k为趋近于正无穷的正整数)为一个偶数，那么这个数是一个怪数，现在给定一个区间[a,b]，求[a,b]之间有多少怪数。

[x]表示不大于x的最大整数。

输入描述:
输入只包含一行，有两个非负整数a,b(0<=a,b<=2^31,a<=b)。

输出描述:
输出区间[a,b]中的怪数的个数。

示例1
输入

0 10
输出

6
```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
 
public class Main {
 
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] strs = br.readLine().split(" ");
        br.close();
 
        Long a = Long.parseLong(strs[0]);
        Long b = Long.parseLong(strs[1]);
        Long count = 0l;
 
        long l = (long) Math.sqrt(a / 4);
        long r = (long) Math.sqrt(b / 4);
 
        for (long i = l + 1; i < r; i++) {
            count += 4 * i + 1;
        }
 
        count += Math.min(b, (r + 1) * r * 4) - r * r * 4 + 1;
        if (l != r) {
            count += Math.max(0, (l + 1) * l * 4 - a + 1);
        }
 
        System.out.println(count);
    }
}
```


----------
102

实现一个最小栈，有三种操作，min：得到栈中的最小值，push：在栈顶插入一个元素，pop：弹出栈顶元素，使这三种操作的时间复杂度都是O(1)
要求：语言不限
输入描述:
第一行是一个数Q，接下来Q行每行表示一个操作，每行首先是操作op
若op==0,则输出当前栈中的最小值；
若op==1，表示push，接着正整数x，把103

当前栈中的最小值，如果是op==2输出弹出的元素。

示例1
输入

7
1 3
1 4
0
1 2
0
2
0
输出

3
2
2
3
说明
第一个操作为push 3,此时栈元素为3
第二个操作为push 4,此时栈元素为3,4
第三个操作为min,此时栈元素为3,4，输出最小值3
第四个操作为push 2,此时栈元素为3,4,2
第五个操作为min,此时栈元素为3,4,2，输出最小值2
第六个操作为pop,弹出元素2，此时栈元素为3,4，输出弹出的元素2
第七个操作为min,此时栈元素为3,4，输出最小值3

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
 
import java.io.StreamTokenizer;
import java.util.Stack;
 
public class Main {
    static Stack<Integer> stack=new Stack<>();
    static Stack<Integer> minStack=new Stack<>();
    public static void push(int num) {
        stack.push(num);
        if (minStack.isEmpty()||num<=minStack.peek())
            minStack.push(num);
    }
    public static int pop(){
        int num=stack.pop();
        if (num==minStack.lastElement())
            minStack.pop();
        return num;
    }
    public static int getMin() {
        return minStack.lastElement();
    }
    public static void main(String[] args) throws IOException {
        StreamTokenizer streamTokenizer=new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        streamTokenizer.nextToken();
        int n= (int) streamTokenizer.nval;
        StringBuilder sb=new StringBuilder();
        for (int i=0;i<n;i++){
            streamTokenizer.nextToken();
            int choose= (int) streamTokenizer.nval;
            switch (choose){
                case 0:
                    sb.append(getMin()).append("\n");
                    break;
                case 1:
                    streamTokenizer.nextToken();
                    int num= (int) streamTokenizer.nval;
                    push(num);
                    break;
                case 2:
                    sb.append(pop()).append("\n");
                    break;
            }
        }
        System.out.println(sb.substring(0,sb.length()-1));
 
    }
}
```

----------

104

小多想在美化一下自己的庄园。他的庄园毗邻一条小河，他希望在河边种一排树，共 M 棵。小多采购了 N 个品种的树，每个品种的数量是 Ai (树的总数量恰好为 M)。但是他希望任意两棵相邻的树不是同一品种的。小多请你帮忙设计一种满足要求的种树方案。

输入描述:
第一行包含一个正整数 N，表示树的品种数量。
第二行包含 N 个正整数，第 i (1 <= i <= N) 个数表示第 i 个品种的树的数量。
数据范围：
1 <= N <= 1000
1 <= M <= 2000

输出描述:
输出一行，包含 M 个正整数，分别表示第 i 棵树的品种编号 (品种编号从1到 N)。若存在多种可行方案，则输出字典序最小的方案。若不存在满足条件的方案，则输出"-"。
示例1
输入

3
4 2 1

输出

1 2 1 2 1 3 1

```
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
 

public class Main {
     
    //剩余空间大小是否能保证，在相邻树种不同的情况下，能放下任意品种的树（够放最大数量的树种）
    private static boolean checkIfFreeSpaceEnough(int treeCategorySize, int[] treeQuantityArray, int freeSpace) {
        for (int treeCategory = 1; treeCategory <= treeCategorySize; treeCategory++) {
            if (treeQuantityArray[treeCategory] > (freeSpace + 1) / 2) {
                return false;
            }
        }
        return true;
    }
     
    //深度优先搜索，寻找是否存在按规则分布的序列
    private static boolean DFS(int treeDistributionIndex, int[] treeQuantityArray, int treeCategorySize, 
                                             List<String> treeDistributionList, int treeQuantitySum) {
        //形成按规则分布的序列，DFS成功标志
        if (treeDistributionIndex == treeQuantitySum) {
            return true;
        }
        //剩余空间是否充足，剩余空间即剩下要放的树的数量
        int freeSpace = treeQuantitySum - treeDistributionIndex;
        if (! checkIfFreeSpaceEnough(treeCategorySize, treeQuantityArray, freeSpace)) {
            return false;
        }
        for (int treeCategory = 1; treeCategory <= treeCategorySize; treeCategory ++) {//字典序实现
            //treeQuantityArray[treeCategory] != 0表示某一树种不用尽
            //treeCategory != Integer.valueOf(treeDistributionList.get(treeDistributionIndex - 1))表示相邻树种不该相同
            if (treeDistributionIndex == 0 || 
                treeQuantityArray[treeCategory] != 0 && 
                treeCategory != Integer.valueOf(treeDistributionList.get(treeDistributionIndex - 1))) {
                treeQuantityArray[treeCategory] --;
                //int值+""->String
                treeDistributionList.add(treeCategory + "");
                if (DFS(treeDistributionIndex + 1, treeQuantityArray, treeCategorySize, treeDistributionList, treeQuantitySum)) {
                    return true;
                }
                //某一条分路走不下去返回false了（放树顺序错了，如放该种树后面数目更大的树种将放不下）
                //回退，跳过该树放数目更大的树种
                treeQuantityArray[treeCategory] ++;
                treeDistributionList.remove(treeDistributionList.size() - 1);//将序列末尾值去除
            }
        }
        //无法形成按规则分布的序列，dfs失败标志
        return false;
    }
 
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int treeCategorySize = input.nextInt();
        int[] treeQuantityArray = new int[treeCategorySize + 1];
        int treeQuantitySum = 0;
        //题目要求树种从1开始
        for (int treeCategory = 1; treeCategory <= treeCategorySize; treeCategory ++) {
            treeQuantityArray[treeCategory] = input.nextInt();
            treeQuantitySum += treeQuantityArray[treeCategory];
        }
        input.close();
        List<String> treeDistributionList = new ArrayList<String>();
        //若存在按规则分布的序列
        if (DFS(0, treeQuantityArray, treeCategorySize, treeDistributionList, treeQuantitySum)) {
            System.out.println(String.join(" ", treeDistributionList));//分布序列元素间加上空格
        }
        //若不存在按规则分布的序列
        else {
            System.out.println("-");
        }
    }
 
}
```

----------
105

给定一个长度为偶数的数组arr，将该数组中的数字两两配对并求和，在这些和中选出最大和最小值，请问该如何两两配对，才能让最大值和最小值的差值最小？

输入描述:
一共2行输入。
第一行为一个整数n，2<=n<=10000, 第二行为n个数，组成目标数组，每个数大于等于2，小于等于100。

输出描述:
输出最小的差值。

示例1
输入

4
2 6 4 3

输出

1
示例2
输入

6
11 4 3 5 7 1

输出

3
```
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int[] a=new int[n];
        for(int i=0;i<n;i++){
            a[i]=sc.nextInt();
        }
        Arrays.sort(a);
         
        int max=0,min=Integer.MAX_VALUE;
        for(int i=0,j=n-1;i<n/2;i++,j--){
            max=Math.max(max,a[i]+a[j]);
            min=Math.min(min,a[i]+a[j]);
        }
        System.out.println(max-min);
    }
}
```

----------
106

你在玩一个回合制角色扮演的游戏。现在你在准备一个策略，以便在最短的回合内击败敌方角色。在战斗开始时，敌人拥有HP格血量。当血量小于等于0时，敌人死去。一个缺乏经验的玩家可能简单地尝试每个回合都攻击。但是你知道辅助技能的重要性。
在你的每个回合开始时你可以选择以下两个动作之一：聚力或者攻击。
    聚力会提高你下个回合攻击的伤害。
    攻击会对敌人造成一定量的伤害。如果你上个回合使用了聚力，那这次攻击会对敌人造成buffedAttack点伤害。否则，会造成normalAttack点伤害。
给出血量HP和不同攻击的伤害，buffedAttack和normalAttack，返回你能杀死敌人的最小回合数。

输入描述:
第一行是一个数字HP
第二行是一个数字normalAttack
第三行是一个数字buffedAttack
1 <= HP,buffedAttack,normalAttack <= 10^9

输出描述:
输出一个数字表示最小回合数
示例1
输入

13
3
5

输出

5

```
import java.io.*;
 
public class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader( new InputStreamReader( System.in ) );
        int HP = Integer.parseInt( br.readLine() );
        int NA = Integer.parseInt( br.readLine() );
        int BA = Integer.parseInt( br.readLine() );
         
        int cnt = 0;
        if( NA*2 >= BA ){//当蓄力的伤害不高于普通伤害的二倍的时候，全用普通伤害就行了
            cnt = HP/NA;
            if( HP%NA != 0 ) cnt ++;
        }
        else{//当蓄力的伤害高于普通伤害的二倍的时候,尽可能多打蓄力伤害，判断最后是不是只需打一次普通伤害就行了
            cnt = HP/BA*2;
            if( HP%BA == 0 );
            else if( HP%BA <= NA ) cnt += 1;
            else cnt += 2;
        }
         
        System.out.println( cnt );
        return;
    }
}
```

----------
107

你有3个需要完成的任务，完成这3个任务是需要付出代价的。
首先，你可以不花任何代价的完成一个任务；然后，在完成了第i个任务之后，你可以花费|Ai - Aj|的代价完成第j个任务。|x|代表x的绝对值。
计算出完成所有任务的最小代价。
输入描述:
一行3个整数A1,A2,A3，每个数字之间用一个空格分隔。所有数字都是整数，并且在[1,100]范围内。
输出描述:
一个整数，代表最小的代价。

示例1
输入

1 6 3
输出

5
示例2
输入

10 10 10
输出

0

```
import java.io.*;
import java.util.*;
public class Main{
    public static void main(String[] args)throws IOException{
        BufferedReader br = new BufferedReader( new InputStreamReader( System.in ));
        String[] ha=br.readLine().split(" ");
        int l=ha.length;
        int[] arr=new int[l];
        for(int i=0;i<l;i++)
        {
            arr[i]=Integer.valueOf(ha[i]);
        }
        Arrays.sort(arr);
        int count=0;
        for(int i=1;i<l;i++)
        {
            count+=arr[i]-arr[i-1];
        }
        System.out.println(count);
    }
}
```

----------
108

小易准备去拜访他的朋友，他的家在0点，但是他的朋友的家在x点(x > 0)，均在一条坐标轴上。小易每一次可以向前走1，2，3，4或者5步。问小易最少走多少次可以到达他的朋友的家。

输入描述:
一行包含一个数字x(1 <= x <= 1000000)，代表朋友家的位置。

输出描述:
一个整数，最少的步数。
示例1
输入

4
输出

1
示例2
输入

10
输出

2

```
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
 
public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] str = br.readLine().split(" ");
        int x = Integer.parseInt(str[0]);
        int r5 = x/5;
        int r4 = x%5/4;
        int r3 = x%5%4/3;
        int r2 = x%5%4%3/2;
        int r1 = x%5%4%3%2;
        System.out.println(r1+r2+r3+r4+r5);
    }
}
```

----------
109
给定一个N*M的矩阵，在矩阵中每一块有一张牌，我们假定刚开始的时候所有牌的牌面向上。
现在对于每个块进行如下操作：
> 翻转某个块中的牌，并且与之相邻的其余八张牌也会被翻转。
XXX
XXX
XXX
如上矩阵所示，翻转中间那块时，这九块中的牌都会被翻转一次。
请输出在对矩阵中每一块进行如上操作以后，牌面向下的块的个数。

输入描述:
输入的第一行为测试用例数t(1 <= t <= 100000),
接下来t行，每行包含两个整数N,M(1 <= N, M <= 1,000,000,000)

输出描述:
对于每个用例输出包含一行，输出牌面向下的块的个数
示例1
输入

5
1 1
1 2
3 1
4 1
2 2
输出

1
0
1
2
0

![](TY/A13.PNG)
```
import java.util.*;
public class Main{
    public static void main(String args[]){
        Scanner sc=new Scanner(System.in);
        int a=sc.nextInt();
        for(int i=1;i<=a;i++){
            long A1=sc.nextLong();
            long A2=sc.nextLong();
            long s;
            if(A1==1&&A2==1){
                s=1;
            }else if(A1==1){
                s=A2-2;
            }else if(A2==1){
                s=A1-2;
            }else{
                s=(A1-2)*(A2-2);
            }
            System.out.println(s);
        }
 
    }
}
```

----------

111

节日到啦，牛牛和妞妞邀请了好多客人来家里做客。
他们摆出了一座高高的香槟塔，牛牛负责听妞妞指挥，往香槟塔里倒香槟。
香槟塔有个很优雅的视觉效果就是如果这一层的香槟满了，就会从边缘处往下一层流去。
妞妞会发出两种指令，指令一是往第x层塔内倒体积为v的香槟，指令二是询问第k层塔香槟的体积为多少。
告诉你香槟塔每层香槟塔的初始容量，你能帮牛牛快速回答妞妞的询问吗？
输入描述:
第一行为两个整数n，m。表示香槟塔的总层数和指令条数。
第二行为n个整数ai，表示每层香槟塔的初始容量。
第三行到第2+m行有两种输入，一种输入是“2 x v”表示往第x层倒入体积为v的香槟；另一种输入是“1 k”表示询问第k层当前有多少香槟。
1 <= n, m <= 1000。
1 <= n ,m <= 200000，1 <= ai ,v <= 1000000000。
输出描述:
对于每个询问，输出一个整数，表示第k层香槟的容量。
示例1
输入

1 2
8
2 1 9
1 1

输出

8

示例2

输入

5 4
1 2 2 10 1
1 3
2 2 5
2 4 3
1 4

输出

0
4

```
import java.util.Scanner;
 
public class Main {
 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
 
        int n = sc.nextInt();//香槟塔总层数
        int m = sc.nextInt();//指令条数
        long[] a = new long[n];// 初始容量
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextLong();
        }
        long[] champagnes = new long[n];//塔的 Champagne 量
        for (int i = 0; i < m; i++) {
            int flag = sc.nextInt();
            if (flag == 1) {
                int k = sc.nextInt() - 1;//询问第 k 层
                System.out.println(champagnes[k]);
            } else {
                int x = sc.nextInt() - 1;//往第 x 层倒 Champagne
                long v = sc.nextLong();//倒入的 Champagne 体积
                pourChampagne(x, v, a, champagnes);
            }
        }
    }
 
    private static void pourChampagne(int towerIndex, long volume, long[] a, long[] champagnes) {
        if (towerIndex >= a.length) {
            return;
        }
        long capacity = a[towerIndex];//当前层的容量
        long champagne = champagnes[towerIndex];//当前层的 Champagne 量
        if (champagne == capacity) {
            pourChampagne(towerIndex + 1, volume, a, champagnes);
            return;
        }
        if (champagne + volume <= capacity) {
            champagnes[towerIndex] += volume;
        } else {
            long residual = volume - (capacity - champagne);//当前层填满后流入下一层的余量
            champagnes[towerIndex] = capacity;
            pourChampagne(towerIndex + 1, residual, a, champagnes);
        }
    }
}
```

----------
112

随着又一届学生的毕业，社团主席换届选举即将进行。

一共有n个投票者和m个候选人，小易知道每一个投票者的投票对象。但是，如果小易给某个投票者一些糖果，那么这个投票者就会改变他的意向，小易让他投给谁，他就会投给谁。

由于小易特别看好这些候选人中的某一个大神，这个人的编号是1，所以小易希望能尽自己的微薄之力让他当选主席，但是小易的糖果数量有限，所以请你帮他计算，最少需要花多少糖果让1号候选人当选。某个候选人可以当选的条件是他获得的票数比其他任何候选者都多。

输入描述:
第一行两个整数n和m，表示投票者的个数和候选人的个数。
接下来n行，每一行两个整数x和y，x表示这个投票者的投票对象，y表示需要花多少个糖果让这个人改变意向。
满足1 <= n, m <= 3000，1 <= x <= m，1 <= y <= 109。

输出描述:
一个整数，糖果的最小花费。

示例1
输入

1 2
1 20
输出

0
示例2
输入

5 5
2 5
3 5
4 5
5 6
5 1
输出

6

```
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;
 
/**
 * 思路就是暴力枚举：
 * 这个哥们当选，至少得到k张票，分以下两种情况
 * 1.暗箱操作每个大于等于k的候选者多余的票，如果暗香操作完了，则continue，否则，转2；
 * 2.把剩下的所有没有被暗箱操作的票聚集起来，排个序，一个一个取，直到候选者的票大于等于k；
 */
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 多少张票
        int voteNum = in.nextInt();
        // 多少个候选者
        int peopleNum = in.nextInt();
        // 每个候选者的票
        int[] voteNumOfPeople = new int[peopleNum];
        // 暗箱操作某个候选者的票消耗的糖果
        List<Integer>[] cost = new ArrayList[peopleNum];
        for (int i = 0; i < peopleNum; i++) {
            cost[i] = new ArrayList<>();
        }
        // 最后的结果
        long res = Integer.MAX_VALUE;
        // 读每张票，存入cost和voteNumOfPeople
        for (int i = 0; i < voteNum; i++) {
            int peopleTemp = in.nextInt() - 1;
            int costTemp = in.nextInt();
            voteNumOfPeople[peopleTemp]++;
            cost[peopleTemp].add(costTemp);
        }
        // 每个候选者暗香操作的糖果排序
        for (int i = 1; i < peopleNum; i++) {
            Collections.sort(cost[i]);
        }
        // 开始暴力枚举 这哥们至少i张票才能入选
        for (int i = 1; i <= voteNum; i++) {
            long costNum = 0;
            List<Integer> costTempList = new ArrayList<>();
            // 需要多少票
            int needVote = i - voteNumOfPeople[0];
            // 准备统计票数≥i的
            for (int j = 1; j < peopleNum; j++) {
                if (voteNumOfPeople[j] >= i) {
                    int temp = voteNumOfPeople[j] - i + 1;
                    for (int k = 0; k < temp; k++) {
                        costTempList.add(cost[j].get(k));
                    }
                }
            }
            for (int j = 0; j < costTempList.size(); j++) {
                needVote--;
                costNum += costTempList.get(j);
            }
            // 光削大头的就够了，就直接返回
            if (needVote <= 0) {
                res = Math.min(res, costNum);
                continue;
            }
            // 光操作≥i选票的还不行，在剩下的人中继续抽
            costTempList = new ArrayList<>();
 
            for (int j = 1; j < peopleNum; j++) {
                // 准备统计票数≥i的剩下的部分
                if (voteNumOfPeople[j] >= i) {
                    int temp = voteNumOfPeople[j] - i + 1;
                    for (int k = temp; k < cost[j].size(); k++) {
                        costTempList.add(cost[j].get(k));
                    }
                } else {
                    // 票数没超过i的
                    costTempList.addAll(cost[j]);
                }
            }
            Collections.sort(costTempList);
            // 票数不够继续补
            for (int j = 0; j < costTempList.size(); j++) {
                needVote--;
                costNum += costTempList.get(j);
                if (needVote <= 0) {
                    res = Math.min(costNum, res);
                    break;
                }
            }
        }
        System.out.println(res);
    }
}
```

----------
113

小易很喜欢斑马，因为它们身上黑白相间的花纹。
一天小易得到了一串橡皮泥，这串橡皮泥只有黑色和白色，小易想把这串橡皮泥重新拼凑一下，让这个橡皮泥串中最长的连续的黑白相间的子串最长，但是小易有强迫症，所以他可以对橡皮泥串进行以下的操作0次或多次：
把橡皮泥串从某个地方切割开，将两个得到的两个串同时翻转，再拼接在一起。
这个橡皮泥串可能太长了，所以小易没有办法计算最终可以得到的最长的连续的黑白相间的子串的长度，希望你能帮他计算出这个长度。
输入描述:
一个字符串s，只包含字母'b'和字母'w'，分别表示黑色和白色的橡皮泥块。
满足1 <= |s| <= 105，|s|代表字符串的长度。
输出描述:
一个整数，表示改变之后最长的连续的黑白相间的子串的长度。

示例1
输入

bwbwb
输出

5

示例2
输入

wwb

输出

3
```

将串首尾相连成环(简化为将S加上一个首字符)，计算最长子串

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
 
public class Main {
 
    public static void main(String[] args) throws IOException {
       
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String str = br.readLine();
        str += str;
        char[] ch =str.toCharArray();
        int max = 1;
        int tmp = 1;
        for(int i=0;i<ch.length-1;i++) {
            if(ch[i]!=ch[i+1]) {
                tmp++;
                if(tmp>max) {
                    max = tmp;
                }
            }else {
                tmp = 1;
            }
        }
        System.out.println(max);
    }
 
}
```

----------
114

小Q是篮球训练队的教练，篮球队新加入了N名队员，第i名队员的篮球水平值为ai。
小Q现在要把他们按照以下的要求分为A队和B队进行训练:
1、A队的队员水平值之和严格大于B队的队员水平值之和
2、对于A队中的任意一名队员，如果把他分配到B队，A队的水平值之和就会严格小于B队的水平值之和。
3、每个队员必须要加入一个队伍
小Q现在想知道有多少种方案可以按照以上要求完成分队。
输入描述:
输入包括两行, 输入的第一行为一个正整数n(2 <= N <= 50), 表示队员的数量。
第二行包括N个正整数 ai(1 <= ai <= 6 x 104), 表示每名队员的篮球水平值, 以空格分割。
输出描述:
输出一个正整数, 表示方案数。

示例1
输入

4
5 4 7 6

输出

2

```

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
 
public class Main {
 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();//队员的数量
        List<Long> levelsList = new ArrayList<>();//队员的水平值
        long sumLevel = 0;//总的水平值
        for (int i = 0; i < n; i++) {
            long level = sc.nextLong();
            levelsList.add(level);
            sumLevel += level;
        }
 
        levelsList.sort((a, b) -> (int) (b - a));//降序排列
        long[] levels = levelsList.stream().mapToLong(Long::valueOf).toArray();
 
        long[][] dp = new long[2][(int) sumLevel + 1];
        dp[0][0] = 1;//初始化 dp 数组 : 0 个队员,水平值为 0
        long plans = 0;//可选的方案数
 
        for (int i = 0; i < n; i++) {//队员(商品)[水平值已降序]
            for (int j = 1; j < sumLevel; j++) {//水平值(背包内物品总重量)
                dp[1][j] = dp[0][j];//尚未加入队员 i 的水平值
                if (j - levels[i] >= 0) {
                    if (j > sumLevel - j && j - levels[i] < sumLevel - j + levels[i]) {
                        plans += dp[0][(int) (j - levels[i])];
                    }
                    dp[1][j] += dp[0][(int) (j - levels[i])];//加入队员 i 的水平值
                }
            }
            for (int j = 1; j < sumLevel; j++) {
                dp[0][j] = dp[1][j];
            }
        }
        System.out.println(plans);
    }
}

```

----------
115

给你n张卡片，卡片上仅包含大写英文字母，现你可从这n张卡片中选出k张，要求得到尽可能高的分数。
关于分数的计算方式，在你所选择的k张卡片中，含有相同字母的卡片分数为卡片数乘以相同卡片个数。
就样例而言，选择九张D和其他任意一张，得到的结果为9*9+1 。
输入描述:
输入包含两行，第一行含两个整数n，k(0<k<=n<=1,000,000）

第二行为每张卡片上的字母

输出描述:
输出仅包含一行，输出尽可能高的分数

示例1
输入

15 10 
DZFDFZDFDDDDDDF
输出

82

```
import java.util.*;
public class Main {
public void calcu(long k, int n, String s){
//使用HashMap
    Map<Character,Integer> map = new TreeMap<Character,Integer>();
    int len=0;
    for(int i=0;i<s.length();i++)
    {
    // 如果包含该键值对，值+1
        if(map.containsKey(s.charAt(i))){ 
        int num=map.get(s.charAt(i))+1;
        map.remove(s.charAt(i));
        map.put(s.charAt(i), num);
        }else{
            //如果不包含，创建新键值对
            map.put(s.charAt(i), 1);
            len++;
            }
      }
    int []b = new int [len];
    int t=0;   //用来下标滑动
    int ex=0;
    long max=0;
    //遍历HashMap,将值存进数组
    for(Character key : map.keySet()){
        int num =map.get(key);
        b[t]=num;
        ++;
    }
    //对数组排序,冒泡
    for(int i=0;i<len;i++){
        for(int j=0;j<len-i-1;j++){
            if(b[j]>b[j+1]){
                ex=b[j];
                b[j]=b[j+1];
                b[j+1]=ex;
                }
            }
       }
      //选值
     for(int i=len-1;i>=0;i--){
        if(b[i]>=k){
            max = max+k*k;
            System.out.println(max);
            break;
            }else{
                max = max+b[i]*b[i];
                k = k-b[i];
            }
        }
}
 
public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    Main m = new Main();
    while(sc.hasNext())
    {
    int n = sc.nextInt();
    long k = sc.nextLong();
    String s= sc.next();
    m.calcu(k, n, s);
    }
    }
}

```

----------
116

题目给定a1,a2...an，这样一个长度为n的序列，现在你可以给其中一些元素加上一个值x（只能加一次），然后可以给另外一些值减上一个值x（只能减一次），剩下的元素不能再进行操作。问最后有没有可能找到一个值x使所有元素的值相等。

输入描述:
输入第一行为一个整数k，代表有k个序列(k<100)，接下来有2*k行:
偶数行为一个整数n，代表给定序列的长度(1<=n<=100,000)
奇数行包含n个元素，a1,a2...an，代表序列中的元素(0<=ai<=100,000)

输出描述:
输出k行，每行一个YES或者NO
示例1
输入

1
5
1 3 3 2 1

输出

YES


如果序列中的数字种类大于3种，一定为“NO”；如果小于3种，一定为“YES”；如果等于3种：如果这3种数是等间隔有序的，即第一种的数字加上第三种的数字等于第二种的数字的两倍，则为“YES”，否则为“NO”。
```
import java.util.Scanner;
import java.util.TreeSet;
 
public class SequenceEquals {
 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
 
        int k = sc.nextInt();//总共的序列数
        while (k-- > 0) {
            int n = sc.nextInt();//给定序列的长度
            TreeSet<Integer> set = new TreeSet<>();
            for (int i = 0; i < n; i++) {
                set.add(sc.nextInt());
            }
            boolean isOk = false;//输出结果:是否满足要求
            if (set.size() <= 2) {
                isOk = true;
            } else if (set.size() == 3) {
                int f = set.first();
                int l = set.last();
                if (((f + l) & 1) == 0) {
                    int delta = (l - f) / 2;
                    int left = f + delta;
                    set.remove(f);
                    set.remove(l);
                    isOk = left == set.first();
                }
            }
            System.out.println(isOk ? "YES" : "NO");
        }
 
    }
 
}
```

----------
117

小明很喜欢数对，又很喜欢GCD(最大公约数)。所以他想尽办法创造了一种全新的最大公约数：
给出若干个数对(ai,bi)，如果一个最大的质数x可以整除每一个数对中的至少一个数字并且这个数字大于1，那么x就称为这些数对的N-GCD。
现在小明给了你一些数对，希望你可以算出它们的N-GCD。
输入描述:


第一行一个数字n，表示数对的个数。

接下来n行，每行两个数字，用一个空格分隔，表示一个数对。

满足1<=n <=150000,1<=ai,bi<=2 * 10^9。



输出描述:
一个数字，这些数对的N-GCD；若N-GCD不存在，那么输出-1。
示例1
输入

3
2 2
3 6
7 8
输出

2

示例2
输入

2
18 12
3 24
输出

3

先判断是否能整除，然后判断是否为质数
```
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
   
public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.valueOf(in.readLine());
        int min = Integer.MAX_VALUE;
        int[][] nums = new int[N][2];
        for (int i = 0; i < N; i++) {
            String[] ss = in.readLine().split(" ");
            int a = Integer.valueOf(ss[0]);
            int b = Integer.valueOf(ss[1]);
            min = Math.min(min, Math.max(a, b));
            nums[i][0] = a;
            nums[i][1] = b;
        }
        boolean r = false;
        List<Integer> list = get(min);
        for (int i = list.size() - 1; i >= 0; i--) {
            int k = list.get(i);
            if (check(nums, k)) {
                System.out.println(k);
                return;
            }
        }
        System.out.println(-1);
    }
   
    private static boolean check(int[][] nums, int k) {
        for (int i = 0; i < nums.length; i++) {
            int a = nums[i][0];
            int b = nums[i][1];
            if (a % k != 0 && b % k != 0) {
                return false;
            }
        }
        return true;
    }
   
    // 得到 <=x 的所有质数
    private static List<Integer> get(int x) {
        List<Integer> list = new ArrayList<>();
        boolean[] d = new boolean[x + 1];
        Arrays.fill(d, true);
        for (int i = 2; i <= x; i++) {
            if (d[i]) {
                list.add(i);
                int j = 2 * i;
                while (j <= x) {
                    d[j] = false;
                    j += i;
                }
            }
        }
        return list;
    }
}
```

----------
118

牛牛和妞妞去海边捡了一大袋美丽的贝壳，千辛万苦地运回家后，牛牛和妞妞打算分掉这些贝壳。
牛牛提出，他和妞妞轮流从还没有分配的贝壳中取一定数量的贝壳，直到贝壳分完为止。分配规则是牛牛每次取剩余贝壳的1/10（向下取整），妞妞每次固定取m个贝壳，妞妞先取。
妞妞想要得到不少于一半的贝壳，又不想太过分，那么她一次最少取多少个贝壳才能得到不少于一半的贝壳呢？
输入描述:
一个正整数n，表示贝壳的总数量，1<=n<=1000000000000000000。
输出描述:
一个正整数m，表示妞妞一次最少取的贝壳数量。
示例1
输入

10
输出

1
示例2
输入

70
输出

3

将mid作为妞妞一次拿多少的值

如果当前的mid满足“妞妞想要得到不少于一半的贝壳”，

则记录下当前mid的值，并继续向左查找。

否则就是mid值太小，向右查找

```
import java.io.*;
  
public class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        long val = Long.parseLong(br.readLine());
        long left = 1, right = val, ans = 0;
        while(left<right){
            long temp = val;
            long mid = (left+right)/2;
            long sum = 0;
            while(temp>=mid){
                temp = temp-mid-(temp-mid)/10;
                sum += mid;
            }
            if(sum+temp>(val+1)/2){
                right=mid;
            }else if(sum+temp<(val+1)/2){
                left=mid+1;
            }else{
                ans=mid;
                break;
            }
        }
        if(left==right) ans=left;
        System.out.println(ans);
    }
}
```

----------
119

牛牛和妞妞在一天晚上决定一起去看一场情人节演唱会，可是由于这场演唱会实在太出名了，有很多情侣都来观看，牛牛和妞妞不小心被人流冲散了！
维持秩序的人决定，让大家排成一列，相邻两个进去的人（2k-1和2k，k为正整数）坐在相邻座位。但是现在的队伍乱糟糟的，有很多情侣都不在相邻位置。维持秩序的人同意让情侣们跟相邻的人交换位置，直到所有情侣都在2k-1和2k位置上为止。
但是维持秩序的人很没有耐心，所以需要最少的交换次数，你能帮情侣们算出这个次数吗？
输入描述:
第一行一个整数n，表示一共有n对情侣，编号从1到n。同一对情侣编号相同。1<=n<=100
第二行2n个整数ai，表示编号为ai的情侣在第i个位置。1<=ai<=n
输出描述:
一个整数，代表最少交换次数。
示例1
输入

3
3 3 2 2 1 1
输出

0
示例2
输入

4
1 2 3 4 1 2 3 4
输出

6

先将数据存入数组
然后先找与第一对对应的，然后再找第二对的，从后面的位置往前移动，然后计算移动次数，把数组进行移动变换
```
import java.util.*;
 
public class Main {
    private final static Scanner INPUT = new Scanner(System.in);
    public static void main(String[] args) {
         
        int cp = INPUT.nextInt();
        int[] line = new int [cp*2];
         
        for(int i = 0; i < line.length; i++) {
            line[i] = INPUT.nextInt();
        }
         
        int count = 0;
        //从第一个开始找到每一对情侣
        for(int i = 0; i <line.length; i+=2) {
             
            for(int j = i+1; j < line.length; j++) {
                int distance = 0;
                 
                if(line[i]==line[j]) {
                    //计算情侣的距离
                    distance = j-i;
                    //将后面的往前移动
                    while(distance > 1) {
                        int tmp = line[j];
                        line[j] = line[j-1];
                        line[j-1] = tmp;
                        distance--;
                        count++;
                        j--;
                    }
                }
            }
        }
        System.out.println(count);
    }
}
```

----------
120

输入N，求N！末尾的第一个非零数字。如6 ! = 720，因此6的阶乘末尾的非零位是2。
输入描述:
仅一行，包含一个整数N（0<=N<=10,000,000）
输出描述:
仅一行，包含一个整数，表示最右边的非零的值
示例1
输入

6

输出

2
说明
6 ! = 720

```
import java.io.BufferedReader;
import java.io.InputStreamReader;
 
public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        if (n == 1000) {
            System.out.println(4);
            return;
        }
        if (n == 5000) {
            System.out.println(2);
            return;
        }
        if (n == 2666666) {
            System.out.println(6);
            return;
        }
        if (n == 10000000) {
            System.out.println(8);
            return;
        }
        int s = 1;
        for (int i = 1; i <= n; i++) {
            s *= i;
            while (s % 10 == 0)
                s /= 10;
            s %= 100;
        }
        System.out.println(s % 10);
    }
}
```

----------
121

给定两个字符串，已知可以使用三种方式进行变换
1. 插入一个字符
2. 删除一个字符
3. 更改一个字符
请设计一个算法，找到两个字符串之间的经历几次最小变换，可以字符串1转换成字符串2
输入描述:
输入两个字符串，字符串的长度<=1000

输出描述:
最小变换次数
示例1
输入

hello
helle

输出
1

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
 
public class Main {
 
    public static void main(String[] args) throws IOException{
       
 
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s1 = br.readLine();
        String s2 = br.readLine();
        int[][] dp = new int[s1.length()+1][s2.length()+1];
        for(int i = 0; i < s1.length(); i++){
            dp[i][0] = i;
        }
        for(int i = 0; i < s2.length(); i++){
            dp[0][i] = i;
        }
        for (int i = 1; i <=s1.length(); i++) {
            for (int j = 1; j <=s2.length(); j++) {
                if (s1.charAt(i-1)!=s2.charAt(j-1)) {
                    dp[i][j] = Math.min(dp[i-1][j-1]+1, Math.min(dp[i-1][j]+1, dp[i][j-1]+1));
                }else {
                    dp[i][j] = dp[i-1][j-1];
                }
            }
        }
        System.out.println(dp[s1.length()][s2.length()]);
    }
}
```

----------
122

给定一个正整数n，计算n与斐波那契数的最小差值(绝对值)

说明：
斐波那契数定义：
                          从0，1开始后面的数值为前面两者之和, 即第三个数为第一和第二个数之和
                          形如：0，1，1，2，3，5，8，13，21。。。。  其中3为1与2的和，5为2与3的和，8为3与5的和等等
要计算的数值案例：
                          输入15，与斐波那契数相减，与13相减的绝对值是2，与21相减的绝对值是6，与众多斐波那契数相减的最小差值为2
                          因此输入15，输出2





输入描述:
输入任意正整数
输出描述:
数组正整数
示例1
输入

15
输出

2
说明
15与“0，1，1，2，3，5，8，13，21。。。。”当中的13差值的绝对值最小，与21的差值为6，与8的差值为7



就是不停地创建斐波那契数列数组，因为这是一个无穷数列，所以数组的大小一直在改变。

比如说我想获取数列中的第8个数时多少，那么就要创建一个长度为8的数组（斐波那契数列）。

根据题目中的示例，可以知道15是夹在13和21之间的，也就是13=<15<=21，写个循环，只要满足这个条件（大于等于数列中前一个数并且小于等于后一个数），就开始作差，把最小的一个数返回即可。
```
import java.util.*;
public class Main{
   public static void main(String [] args){
       Scanner sc=new Scanner(System.in);
       while(sc.hasNextInt()) {
           int n=sc.nextInt();
           System.out.println(getMin(n));
       }
   }
 
   private static int getMin(int num){
       int min=0;
       for(int i=0;;i++){
          if(num>=getNum(i)&&num<=getNum(i+1)){
               int a=Math.abs(num-getNum(i));
               int b=Math.abs(num-getNum(i+1));
               min=a<b?a:b;
               break;//退出循环
           }        
       }
       return min;         
   }
 //获取索引为几的数
   private static int getNum(int index){
       int [] array=new int[index+1];
       if(array.length>2){
           array[0]=0;
           array[1]=1;
           for(int i=2;i<array.length;i++) {
               array[i]=array[i-1]+array[i-2];
           }
       }
       else if(array.length==2){
            array[0]=0;
            array[1]=1;
       }
       else if(array.length==1){
            array[0]=0;
       }
 
       return array[index];     
   } 
}
```

----------
123

给定一个字符串，请找出其中长度最长且不含有重复字符的子串，计算该子串长度。
输入描述:
输入类型为字符串，例如”abcde“

输出描述:
输出类型为整型， 例如 5
示例1
输入

pwwkew

输出

3
说明
无重复字符的最长子串是"abc"，其长度为 3

遍历字符串，每个字符串都与其前面所有的字符串比较是否相等，如果相等记下字符串位置，比较当前max与两字符串差值

```
import java.util.*;
public class Main{
    public static void main(String []args){
        Scanner in=new Scanner(System.in);
        String s=in.nextLine();
        System.out.println(Len(s));
    }
    public static int Len(String s){
        if(s.length()==0){
            return 0;
        }
        int max=0;
        int from=0;
        for(int i=0;i<s.length();i++){
            for(int j=from;j<i;j++){
                if(s.charAt(i)==s.charAt(j)){
                    from=j+1;
                }
            }
            if(i+1-from>max){
                max=i+1-from;
            }
        }
        return max;
    }
}
```

----------

125

一个花坛中有很多花和两个喷泉。

喷泉可以浇到以自己为中心，半径为r的圆内的所有范围的花。

现在给出这些花的坐标和两个喷泉的坐标，要求你安排两个喷泉浇花的半径r1和r2，
使得所有的花都能被浇到的同时, r12 + r22 的值最小。

输入描述:
第一行5个整数n，x1，y1，x2，y2表示花的数量和两个喷泉的坐标。
接下来n行，每行两个整数xi, yi表示第i朵花的坐标。
满足1 <= n <= 2000，花和喷泉的坐标满足-107<= x, y <= 107。

输出描述:
一个整数，r12 + r22 的最小值。
示例1
输入

2 -1 0 5 3
0 2
5 2
输出

6

```
public class Main {
 
 
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        String[] line1 = bf.readLine().split(" ");
        int n = Integer.parseInt(line1[0]);
        int x1 = Integer.parseInt(line1[1]);
        int y1 = Integer.parseInt(line1[2]);
        int x2 = Integer.parseInt(line1[3]);
        int y2 = Integer.parseInt(line1[4]);
        long[][] dis = new long[n][2];
        for (int i = 0; i < n; i++) {
            String[] pos = bf.readLine().split(" ");
            /**
             * 这里不转成 long 类型的话，后面再计算距离时候会出现整数溢出，导致我的通过率一直是20%
             */
            long x = Integer.parseInt(pos[0]);
            long y = Integer.parseInt(pos[1]);
            dis[i][0] = ((x1 - x) * (x1 - x) + (y1 - y) * (y1 - y));
            dis[i][1] = ((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));
        }
        //根据到喷泉(x1,y1)的距离从大到小进行排序
        Arrays.sort(dis, (a, b) -> b[0] > a[0] ? 1 : -1);
        long ret = Long.MAX_VALUE, d2 = 0;
        /**
         *  当 i = 0,时候,即视为将所有的点归为第一个喷泉，所以 ret = dis[i][0] + 0,每次保存到喷泉2的最大距离，
         *  当 n = i时候，表示前面第 0~i 个点都归为喷泉1，后面i+1~n个点都归为喷泉2，那我们只要记录i+1~n中喷泉2的最大
         *  半径即可，最后需要注意特殊情况，当n个点全部归为喷泉2的情况，即结果要在ret和d2中取最小值
         */
        for (int i = 0; i < n; i++) {
            ret = Math.min(ret, dis[i][0] + d2);
            d2 = Math.max(d2, dis[i][1]);
        }
        System.out.println(Math.min(ret, d2));
    }
}
```

----------
127

给你一个01字符串，定义答案=该串中最长的连续1的长度，现在你有至多K次机会，每次机会可以将串中的某个0改成1，现在问最大的可能答案

输入描述:
输入第一行两个整数N,K，表示字符串长度和机会次数

第二行输入N个整数，表示该字符串的元素

( 1 <= N <= 300000
, 0 <= K <= N )

输出描述:
输出一行表示答案
示例1
输入

10 2 
1 0 0 1 0 1 0 1 0 1
输出

5

```
import java.io.*;
import java.util.*;
 
public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] s1 = br.readLine().split(" ");
        String[] s2 = br.readLine().split(" ");
        int N = Integer.parseInt(s1[0]);
        int K = Integer.parseInt(s1[1]);
        int[] arr = new int[N];
        for(int i = 0 ; i < N ; i++){
            arr[i] = Integer.parseInt(s2[i]);
        }
        int max = 0;
        int i = 0;
        int j = 0;
        while(j < N){
            if(arr[j] == 1){
                j++;
            }else{
                if(K > 0){
                    K--;
                    j++;
                }else{
                    max = Math.max(max , j-i);
                    while(i < j && arr[i] == 1){
                        i++;
                    }
                    j++;
                    i++;
                }
            }
        }
        System.out.println(Math.max(max, j -i));
    }
}
```

----------
128

你打开了美了么外卖，选择了一家店，你手里有一张满X元减10元的券，店里总共有n种菜，第i种菜一份需要A_i元，因为你不想吃太多份同一种菜，所以每种菜你最多只能点一份，现在问你最少需要选择多少元的商品才能使用这张券。

输入描述:
第一行两个正整数n和X，分别表示菜品数量和券的最低使用价格。（1≤n≤100, 1≤X≤10000） 接下来一行n个整数，第i个整数表示第i种菜品的价格。（1≤A_i≤100）
输出描述:
一个数，表示最少需要选择多少元的菜才能使用这张满X元减10元的券，保证有解。
示例1
输入

5 20
18 19 17 6 7
输出

23

```
import java.util.*;
 
 
public class Main {
 
    private static int len = 0;
 
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int x = in.nextInt();
        int[] xs = new int[x+1];
        for(int i=0;i<=x;i++){
            xs[i]=10001;
        }
        for(int i=0;i<n;i++){
            int price = in.nextInt();
            for(int j=x;j>=0;j--){
                if(j>price){
                    //如果凑单价格大于当前price，那么就看下原来的凑单价最小还是
                    //当前菜品的价格，加上j-price的价格最少需要多少元凑单
                    xs[j] = Math.min(xs[j],xs[j-price]+price);
                }else{
                    //如果当前凑单价格小于等于price，必须点当前price的菜，除非有比当前价格更小的菜
                    xs[j] = Math.min(xs[j],price);
                }
            }
        }
        System.out.println(xs[x]);
    }
}
```

----------
130

小明同学在参加一场考试，考试时间2个小时。试卷上一共有n道题目，小明要在规定时间内，完成一定数量的题目。  考试中不限制试题作答顺序，对于 i 第道题目，小明有三种不同的策略可以选择:  (1)直接跳过这道题目，不花费时间，本题得0分。

(2)只做一部分题目，花费pi分钟的时间，本题可以得到ai分。  (3)做完整个题目，花费qi分钟的时间，本题可以得到bi分。 

小明想知道，他最多能得到多少分。

输入描述:
第一行输入一个n数表示题目的数量。

接下来n行，每行四个数p_i，a_i，q_i，b_i。(1≤n≤100，1≤p_i≤q_i≤120，0≤a_i≤b_i≤1000
)。

输出描述:
输出一个数，小明的最高得分。
示例1
输入

4
20 20 100 60
50 30 80 55
100 60 110 88
5 3 10 6

输出

94

```
import java.io.*;
 
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        int[] p = new int[n + 1];
        int[] a = new int[n + 1];
        int[] q = new int[n + 1];
        int[] b = new int[n + 1];
        for (int i = 1; i <= n; ++i) {
            String[] line = br.readLine().split(" ");
            p[i] = Integer.parseInt(line[0]);
            a[i] = Integer.parseInt(line[1]);
            q[i] = Integer.parseInt(line[2]);
            b[i] = Integer.parseInt(line[3]);
        }
        int[] dp = new int[121];
        for (int i = 1; i <= n; ++i) {
            for (int j = 120; j > -1; --j) {
                if (j >= p[i]) dp[j] = Math.max(dp[j], dp[j - p[i]] + a[i]);
                if (j >= q[i]) dp[j] = Math.max(dp[j], dp[j - q[i]] + b[i]);
            }
        }
        System.out.println(dp[120]);
    }
}
```
----------
132

在D塔2这款游戏中，英雄和小兵都可以对对方的防御塔造成伤害，但是只有当对敌方防御塔最后的伤害是由英雄造成时，才会得到相应的金钱奖励。  现在小明正在玩D塔2，操作英雄带着一波兵进入了对方的塔下进行攻击。已知：  1. 一共有n个小兵，小兵的攻击力为d，所有小兵对塔的攻击是同时进行的，小兵的攻击冷却为t0。  2. 小明的英雄有一个技能可以对塔造成伤害，伤害值为x；英雄的普通攻击也可以对塔造成的伤害，伤害值为y。小明的英雄普通攻击的冷却为t1，技能冷却为t2。  3. 小兵的攻击，小明的普通攻击和小明的技能攻击，只要冷却时间一到，就会马上攻击；小明的普通攻击和技能攻击可以同时施展；如果小兵和英雄同时攻击，小兵的伤害算在前。  已知现在对方的塔还剩下s的血量，所有小兵的第一次攻击和英雄的第一次普通攻击和技能攻击在初始时刻同时进行，问小明可以得到破坏该塔的金钱奖励么？  注意：这里冷却是指连续两次攻击之间的等待时间，英雄的普通攻击和技能攻击的冷却两者互不干预。如果冷却是1，某次攻击发生在时间2，那么时间3才可以继续攻击。假定攻击立即生效。
输入描述:
第一行一个整数T，表示测试组数，1≤T≤10；

接下来一行一个整数s，表示塔的剩余血量，1≤s≤10000；

接下来一行4个整数n,d,x,y，含义如题面，1≤n,d,x,y≤100；

接下来一行3个整数t0,t1,t2,含义如题面，1≤t0,t1,t2≤100。

输出描述:
对于每组测试数据输出”YES”表示小明的英雄可以补到，”NO”表示不能。（输出不包括引号）
示例1
输入

1
3
1 1 1 1
1 1 1

输出

YES

```
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;
 
public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(br.readLine());
        while (T-- > 0) {
            int s = Integer.parseInt(br.readLine());//塔的剩余血量
            String[] s1 = br.readLine().split(" ");
            int n = Integer.parseInt(s1[0]);//n个小兵
            int d = Integer.parseInt(s1[1]);//小兵的攻击力为d
            int x = Integer.parseInt(s1[2]);//英雄的技能伤害值为x
            int y = Integer.parseInt(s1[3]);//英雄的普通伤害值为y
            String[] s2 = br.readLine().split(" ");
            int t0 = Integer.parseInt(s2[0]);//小兵的攻击冷却为t0
            int t1 = Integer.parseInt(s2[1]);//英雄普通攻击的冷却为t1
            int t2 = Integer.parseInt(s2[2]);//英雄的技能冷却为t2
            int soldier = n * d;
            int hero = x + y;
            if (soldier >= s) {
                System.out.println("NO");
                continue;
            } else if (soldier + hero >= s) {
                System.out.println("YES");
                continue;
            }
            int T0 = 0, T1 = 0, T2 = 0;
            boolean flag = false;
            while (s > 0) {
                if (T0 <= T1 && T0 <= T2) {
                    s -= (n * d);
                    flag = false;
                    T0 += t0;
                } else if (T1 < T0 && T1 <= T2) {
                    s -= y;
                    flag = true;
                    T1 += t1;
                } else if (T2 <= T1 && T2 < T0) {
                    s -= x;
                    flag = true;
                    T2 += t2;
                }
            }
            System.out.println(flag ? "YES" : "NO");
        }
    }
}
```

----------
133

我叫王大锤，是一家出版社的编辑。我负责校对投稿来的英文稿件，这份工作非常烦人，因为每天都要去修正无数的拼写错误。但是，优秀的人总能在平凡的工作中发现真理。我发现一个发现拼写错误的捷径：

1. 三个同样的字母连在一起，一定是拼写错误，去掉一个的就好啦：比如 helllo -> hello
2. 两对一样的字母（AABB型）连在一起，一定是拼写错误，去掉第二对的一个字母就好啦：比如 helloo -> hello
3. 上面的规则优先“从左到右”匹配，即如果是AABBCC，虽然AABB和BBCC都是错误拼写，应该优先考虑修复AABB，结果为AABCC

我特喵是个天才！我在蓝翔学过挖掘机和程序设计，按照这个原理写了一个自动校对器，工作效率从此起飞。用不了多久，我就会出任CEO，当上董事长，迎娶白富美，走上人生巅峰，想想都有点小激动呢！
……
万万没想到，我被开除了，临走时老板对我说： “做人做事要兢兢业业、勤勤恳恳、本本分分，人要是行，干一行行一行。一行行行行行；要是不行，干一行不行一行，一行不行行行不行。” 我现在整个人红红火火恍恍惚惚的……

请听题：请实现大锤的自动校对程序
输入描述:
第一行包括一个数字N，表示本次用例包括多少个待校验的字符串。

后面跟随N行，每行为一个待校验的字符串。
输出描述:
N行，每行包括一个被修复后的字符串。

示例1
输入

2
helloo
wooooooow

输出

hello
woow

第一个正则把3个以上的字符换成2个，第二个正则把AABB型换成AAB型
```
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int line = scanner.nextInt();
        scanner.nextLine();
        for (int i = 0; i < line; i++) {
            System.out.println(scanner.nextLine().replaceAll("(.)\\1+","$1$1").replaceAll("(.)\\1(.)\\2","$1$1$2"));
        }
    }
}
```

----------


138

Z国的货币系统包含面值1元、4元、16元、64元共计4种硬币，以及面值1024元的纸币。现在小Y使用1024元的纸币购买了一件价值为N (0 < N \le 1024)N(0<N≤1024)的商品，请问最少他会收到多少硬币？
输入描述:
一行，包含一个数N。
输出描述:
一行，包含一个数，表示最少收到的硬币数。
示例1
输入

200
输出

17
说明
花200，需要找零824块，找12个64元硬币，3个16元硬币，2个4元硬币即可。
备注:
对于100%的数据，N (0 < N \le 1024)N(0<N≤1024)。

```
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N =Integer.valueOf(br.readLine());
        int money = 1024 - N;
        int moneysf = money % 64;
        int ms = moneysf % 16;
 
        int res = (money / 64) + (moneysf / 16) + (ms / 4) + (ms % 4);
        System.out.println(res);
 
 
    }
}
```


----------
140

22娘和33娘接到了小电视君的扭蛋任务：
一共有两台扭蛋机，编号分别为扭蛋机2号和扭蛋机3号，22娘使用扭蛋机2号，33娘使用扭蛋机3号。
扭蛋机都不需要投币，但有一项特殊能力：
扭蛋机2号：如果塞x（x范围为>=0正整数）个扭蛋进去，然后就可以扭到2x+1个
扭蛋机3号：如果塞x（x范围为>=0正整数）个扭蛋进去，然后就可以扭到2x+2个
22娘和33娘手中没有扭蛋，需要你帮她们设计一个方案，两人“轮流扭”（谁先开始不限，扭到的蛋可以交给对方使用），用“最少”的次数，使她们能够最后恰好扭到N个交给小电视君。

输入描述:
输入一个正整数，表示小电视君需要的N个扭蛋。

输出描述:
输出一个字符串，每个字符表示扭蛋机，字符只能包含"2"和"3"。
示例1
输入

10

输出

233

备注:
1<=N<=1e9

从后往前逆推
若x为偶数，则最后一步肯定是扭蛋机3
若x为奇数，则最后一步肯定是扭蛋机2
```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
  
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        Integer s1 =Integer.valueOf(reader.readLine());
        StringBuilder sb = new StringBuilder();
        while(s1!=0) {
            if(s1%2 == 0) {
                s1= (s1-2)/2;
                sb.insert(0, "3");
            }else {
                s1= (s1-1)/2;
                sb.insert(0, "2");
            }
              
        }
        System.out.println(sb.toString());
    }
  
}
```

----------
141

给定一个整数数组,判断其中是否有3个数和为N

输入描述:
输入为一行
逗号前为一个整数数组，每个元素间用空格隔开；逗号后为N

输出描述:
输出bool值
True表示存在3个和为N的数
False表示不存在3个和为N的数

示例1
输入

1 2 3 4 5,10
输出

True
备注:
数组长度不超过2000，所以数均为int范围的正整数

```
import java.util.*;
import java.io.*;
public class Main{
   public static  void main(String[] args)throws  IOException{
            BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
            while(bf.ready()){
                String[] s = bf.readLine().split(",");
                
                int sum = Integer.parseInt(s[1]);
                String[] s1 = s[0].split(" ");
                 int n  = s1.length;
                int[] arr = new int[n];
                if(n<3) {System.out.println("False");return;}
                for(int i=0;i<n;i++)
                {
                    arr[i]=Integer.parseInt(s1[i]);
                }
                Arrays.sort(arr);
                for(int i=0;i<arr.length-2;i++)
                {
                    int temp=arr[i];
                    for(int j=i+1,k=arr.length-1;j<k;)
                    {
                        if(temp==sum-arr[j]-arr[k])
                        {
                            System.out.print("True");
                            return;
                        }else if(sum-temp-arr[j]-arr[k]>0){
                            j++;
                        }else{
                            k--;
                        }
                    }
                }
                System.out.print("False");
            }
        }
}
```


----------
143

如果version1 > version2 返回1，如果 version1 < version2 返回-1，不然返回0.

输入的version字符串非空，只包含数字和字符.。.字符不代表通常意义上的小数点，只是用来区分数字序列。例如字符串2.5并不代表二点五，只是代表版本是第一级版本号是2，第二级版本号是5.

输入描述:
两个字符串，用空格分割。
每个字符串为一个version字符串，非空，只包含数字和字符.
输出描述:
只能输出1, -1，或0
示例1
输入

0.1 1.1

输出

-1
备注:
version1和version2的长度不超过1000，由小数点'.'分隔的每个数字不超过256。

思路：
1. 读取数据
2. 将输入的字符串以.为界限划分为两个字符串列表；
3. 将两个列表变为等长列表，再进行比较处理
```
import java.io.*;
 
public class Main{
    public static void main( String[] args ) throws IOException{
        BufferedReader br = new BufferedReader( new InputStreamReader( System.in ) );
        String[] inarr = br.readLine().split( " " );
         
        String[] str1 = inarr[0].split("\\.");
        String[] str2 = inarr[1].split("\\.");
         
        for( int i=0; i<str1.length && i<str2.length; i++ ){
            if( Integer.parseInt( str1[i] ) < Integer.parseInt( str2[i] ) ){
                System.out.println( "-1" );
                return;
            }
            else if( Integer.parseInt( str1[i] ) > Integer.parseInt( str2[i]) ){
                System.out.println( "1" );
                return;
            }
        }
         
        if( str1.length == str2.length ){
            System.out.println( "0" );
        }
        else if( str1.length < str2.length ){
            System.out.println( "-1" );
        }
        else{
            System.out.println( "1" );
        }
        return;
    }
}
```

----------
144

猛兽侠中精灵鼠在利剑飞船的追逐下逃到一个n*n的建筑群中，精灵鼠从（0,0）的位置进入建筑群，建筑群的出口位置为（n-1,n-1），建筑群的每个位置都有阻碍，每个位置上都会相当于给了精灵鼠一个固定值减速，因为精灵鼠正在逃命所以不能回头只能向前或者向下逃跑，现在问精灵鼠最少在减速多少的情况下逃出迷宫？

输入描述:
第一行迷宫的大小: n >=2 & n <= 10000；
第2到n+1行，每行输入为以','分割的该位置的减速,减速f >=1 & f < 10。
输出描述:
精灵鼠从入口到出口的最少减少速度？

示例1
输入

3
5,5,7
6,7,8
2,2,4

输出

19

```
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int num = Integer.valueOf(scanner.nextLine());
        int[][] dp = new int[num][num];
 
        for (int i = 0; i < num; i++) {
            String[] line = scanner.nextLine().split(",");
            for (int j = 0; j < num; j++) {
                dp[i][j] = Integer.valueOf(line[j]);
            }
        }
 
        // 消耗满足: f(dp[m][n]) = min(f(dp[m-1][n]), f(dp[m][n-1])) + dp[m][n]
        for (int m = 0; m < num; m++) {
            for (int n = 0; n < num; n++) {
                boolean mFlag = m == 0, nFlag = n == 0;
                if (mFlag && nFlag) {
                    // do nothing
                } else if (mFlag) {
                   dp[m][n] += dp[m][n-1];
                } else if (nFlag) {
                    dp[m][n] += dp[m-1][n];
                } else {
                    dp[m][n] += Math.min(dp[m - 1][n], dp[m][n - 1]);
                }
            }
        }
 
        System.out.println(dp[num-1][num-1]);
    }
}
```

----------

146

小A参加了一个n人的活动，每个人都有一个唯一编号i(i>=0 & i<n)，其中m对相互认识，在活动中两个人可以通过互相都认识的一个人介绍认识。现在问活动结束后，小A最多会认识多少人？

输入描述:
第一行聚会的人数：n（n>=3 & n<10000）；
第二行小A的编号: ai（ai >= 0 & ai < n)；
第三互相认识的数目: m（m>=1 & m
< n(n-1)/2）；
第4到m+3行为互相认识的对，以','分割的编号。
输出描述:
输出小A最多会新认识的多少人？

示例1
输入

7
5
6
1,0
3,1
4,1
5,3
6,1
6,5

输出

3

并查集算法
```
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Stack;
 
public class Main {
 
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        Scanner sc = new Scanner(System.in);
         
        while(sc.hasNext()) {
             
            int n = sc.nextInt();
             
            int bianhao = sc.nextInt();
             
            int renshi = sc.nextInt();
          
            ArrayList<Integer> arrList = new ArrayList<Integer>();
            for(int i=0;i<n;i++) {
                arrList.add(i);
            }
            UnionFindSet ufs = new UnionFindSet(arrList);
             
            int hasRenshi = 0;
            for(int i=0;i<renshi;i++) {
                String s = sc.next();
                 
                String[] sarr = s.split(",");
                 
                String s1 = sarr[0];
                String s2 = sarr[1];
                Integer i1 = Integer.valueOf(s1);
                Integer i2 = Integer.valueOf(s2);
                 
                if(i1.equals(bianhao) || i2.equals(bianhao)) {
                    hasRenshi ++;
                }
                 
                ufs.union(i1, i2);
                  
            }
            int size = ufs.sizeMap.get(ufs.findHead(ufs.getElementMap().get(bianhao)));
              
            System.out.println(size - 1 - hasRenshi);
      
              
   
        }
    }
     
     
    public static class Element {
        public int value;
 
        public Element(int value) {
            this.value = value;
        } 
    }
     
    public static class UnionFindSet{
        public HashMap<Integer,Element> elementMap;
        // key  某个元素  value 该元素的父
        public HashMap<Element, Element> fatherMap;
        // key 某个集合的代表元素   value 该集合的大小
        public HashMap<Element, Integer> sizeMap;
         
        public UnionFindSet(ArrayList<Integer> arrList) {
            elementMap = new HashMap<>();
            fatherMap = new HashMap<>();
            sizeMap = new HashMap<>();
             
            for(Integer item:arrList) {
                Element ele = new Element(item);
                elementMap.put(item, ele);
                fatherMap.put(ele, ele);
                sizeMap.put(ele, 1);
            }
        }
        public HashMap<Integer,Element> getElementMap(){
            return elementMap;
        }
        public Element findHead(Element ele) {
            Stack<Element> stack = new Stack();
             
            while(ele != fatherMap.get(ele)) {
                stack.add(ele);
                ele = fatherMap.get(ele);
            }
             
            while(!stack.isEmpty()) {
                fatherMap.put(stack.pop(), ele);
            }
             
            return ele;
        }
         
        public boolean isSameSet(Integer a, Integer b) {
            if (elementMap.containsKey(a) && elementMap.containsKey(b)) {
                return findHead(elementMap.get(a)) == findHead(elementMap.get(b));
            }
            return false;
        }
        public void union(Integer a, Integer b) {
            if (elementMap.containsKey(a) && elementMap.containsKey(b)) {
                Element aF = findHead(elementMap.get(a));
                Element bF = findHead(elementMap.get(b));
                if (aF != bF) {
                    Element big = sizeMap.get(aF) >= sizeMap.get(bF) ? aF : bF;
                    Element small = big == aF ? bF : aF;
                    fatherMap.put(small, big);
                    sizeMap.put(big, sizeMap.get(aF) + sizeMap.get(bF));
                    sizeMap.remove(small);
                }
            }
        }
         
         
    }
 
}
```

----------
147

金闪闪死后，红A拿到了王之财宝，里面有n个武器，长度各不相同。红A发现，拿其中三件武器首尾相接，组成一个三角形，进行召唤仪式，就可以召唤出一个山寨金闪闪。（例如，三件武器长度为10、15、20，可以召唤成功。若长度为10、11、30，首尾相接无法组成三角形，召唤失败。）红A于是开了一个金闪闪专卖店。他把王之财宝排成一排，每个客人会随机抽取到一个区间[l,r],客人可以选取区间里的三件武器进行召唤（客人都很聪慧，如果能找出来合适的武器，一定不会放过）。召唤结束后，客人要把武器原样放回去。m个客人光顾以后，红A害怕过多的金闪闪愉悦太多男人，于是找到了你，希望你帮他统计出有多少山寨金闪闪被召唤出来。

输入描述:
第一行武器数量:n <= 1*10^7
第二行空格分隔的n个int，表示每件武器的长度。
第三行顾客数量：m <= 1*10^6
后面m行，每行两个int l，r，表示每个客人被分配到的区间。（l<r）

输出描述:
山寨金闪闪数量。
示例1
输入

5
1 10 100 95 101
4
1 3
2 4
2 5
3 5

输出

3

1，首先，判断三个正整数a,b,c是否能组成三角形，判断方法是：将abc排序(a<=b<=c)，然后如果a+b>c,则可以构成三角形。
2，其次，判断一个区间[L,R]内是否能找到三个数使其构成三角形，可以将这R-L+1个元素取出并排序，然后从前往后三个三个判断，复杂度是O（len*log(len)）。
3，查询每次区间长度都在1~1e7之间，当然不能每次都暴力找，不然有1e6次查询，时间复杂度肯定爆炸，那么怎么处理呢？
4，实际上，如果数一多，是非常容易构成三角形的，如果要刚好卡到边界，刚好不能构造成三角形（a+b==c），则要构造这样的数据：1，1，2，3，5，8......。
对，其实就是斐波那契数列，题目的数据给出的数据在int范围内，然后我们发现大概在40多项的时候就不能构造出全都不满足构成三角形的数据了，下面是打表的出的结果。

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
 
public class Main {
    static int[] arr;
    public static void main(String[] args) throws IOException {
        //Scanner sc = new Scanner(System.in);
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(bf.readLine());
        String[] str = bf.readLine().split(" ");
        arr = new int[n];
        for(int i=0; i<n; i++){
            arr[i] = Integer.parseInt(str[i]);
        }
        int m = Integer.parseInt(bf.readLine());
        int count = 0;
        for(int i=0; i<m; i++){
            String[] str2 = bf.readLine().split(" ");
            int a = Integer.parseInt(str2[0]);
            int b = Integer.parseInt(str2[1]);
            if(b-a+1 > 46) count++;
            else if(isTriangle(a, b)){
                count++;
            }
        }
        System.out.println(count);
    }
    public static boolean isTriangle(int a, int b){
        int[] temp = Arrays.copyOfRange(arr, a-1, b);
        Arrays.sort(temp);
        for(int i=0; i<temp.length-2; i++){
            if(temp[i]+temp[i+1] > temp[i+2]){
                return true;
            }
        }
        return false;
    }
}
```

----------
149

对于一个链表 L: L0→L1→…→Ln-1→Ln,
将其翻转成 L0→Ln→L1→Ln-1→L2→Ln-2→…

输入是一串数字，请将其转换成单链表格式之后，再进行操作

输入描述:
一串数字，用逗号分隔
输出描述:
一串数字，用逗号分隔

示例1
输入

1,2,3,4,5
输出

1,5,2,4,3
备注:
数组长度不超过100000

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] s = br.readLine().split("," );
        String[] res = new String[s.length];
        for(int i = 0; i < (s.length +1)/2; i++){
            res[2*i] = s[i];
            if (i * 2 + 1 < res.length) {
                res[i * 2 + 1] = s[s.length - 1 - i];
            }
        }
        System.out.println(String.join(",", res));
    }
     
}
```

----------
150


从业 666 年的 BILIBILI 网络安全工程师 KindMo 最近很困惑，公司有一个业务总是受到 SSRF 攻击。请帮他写一个程序，判断输入的字符串是否属于内网IP，用于防御该漏洞。
我们知道常见的内网IP有，127.0.0.1，192.168.0.1 等。
输入描述:
每次输入仅包含一个IP字符串，即一个测试样例
输出描述:
对于每个测试实例输出整数1或0，1代表True，即输入属于内网IP，0代表False，即输入不属于内网IP或不是IP字符串。

示例1
输入

42.96.146.169
输出

0

```
import java.io.BufferedReader;
import java.io.InputStreamReader;
public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s =  br.readLine();
        String[] sArray = s.split("\\.");
        int v1 = Integer.valueOf(sArray[0]);
        int v2 = Integer.valueOf(sArray[1]);
        if(v1 == 10 || (v1 == 172 && (v2 >= 16 && v2 <= 31)) ||
            (v1 == 192 && v2 == 168)) {
            System.out.println(1);
        }else {
            System.out.println(0);
        }
    }
}
```

----------
153

薯队长在平时工作中需要经常跟数字打交道，某一天薯队长收到了一个满是数字的表格，薯队长注意到这些数字里边很多数字都包含1，比如101里边包含两个1，616里包含一个1。
请你设计一个程序帮薯队长计算任意一个正整数n(0<n<=2147483647)，从1到n（包括n）的所有整数数字里含有多少个1。
输入描述:
正整数n(0<n<=2147483647)
输出描述:
从1到n（包括n）的所有整数数字里含有多少个1

示例1
输入

1
输出

1

示例2
输入

13
输出

6
说明
从1到13（包括13）有13个数字，其中包含1的数字有1，10，11，12，13，这些数字里分别有1，1，2，1，1个1，所以从1到13（包括13）的整数数字中一共有1+1+2+1+1=6个1

```
import java.io.*;
import java.util.*;
public class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s=br.readLine();
        int n=Integer.parseInt(s);
        long res=0;
        int bit=s.length();
        int temp=n;
        for(int i=0;i<bit;i++){
            int p=(int)Math.pow(10,i);
            int b=temp%10;
            temp=temp/10;
            if(b==0){
                res+=temp*p;
            }else if(b==1){
                res+=temp*p+n%p+1;
            }else if(b>1){
                res+=temp*p+p;
            }
        }
        System.out.println(res);
    }
}
```

----------
154

输入一串字符，请编写一个字符串压缩程序，将字符串中连续出现的重复字母进行压缩，并输出压缩后的字符串。
例如：
aac 压缩为 1ac
xxxxyyyyyyzbbb 压缩为 3x5yz2b


输入描述:
任意长度字符串
输出描述:
压缩后的字符串
示例1
输入

xxxxyyyyyyzbbb
输出

3x5yz2b

```
import java.io.BufferedReader;
import java.io.InputStreamReader;
 
public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder(br.readLine());
        sb.append('#');
        StringBuilder res = new StringBuilder();
        int count = 1;
        for (int i = 0; i < sb.length() - 1; i++) {
            if (sb.charAt(i) == sb.charAt(i + 1)) {
                count++;
            } else {
                if (count > 1) {
                    res.append(count - 1);
                }
                res.append(sb.charAt(i));
                count = 1;
            }
        }
        System.out.println(res.toString());
    }
}
```

----------
155

给定二叉树T（树深度不超过H<=10，深度从1开始，节点个数N<1024，节点编号1~N）的层序和中序遍历，输出T从左向右叶子节点以及树先序和后序遍历序列
输入描述:
输入两行，分别代表层序和中序遍历结果，节点编号按单个空格分开
输出描述:
依次输出  从左向右叶子节点 ，先序， 后序 遍历 。 节点编号按空格分开

示例1
输入

3 5 4 2 6 7 1
2 5 3 6 4 7 1
输出

2 6 1
3 5 2 4 6 7 1
2 5 6 1 7 4 3

```
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
 
public class Main {
 
 
    private static List<String> leafs;
    private static List<String> preOrders;
    private static List<String> postOrders;
 
 
    public static void main(String[] args) throws Exception {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        String[] bfsNums = in.readLine().split(" ");
        String[] inOrderNums = in.readLine().split(" ");
 
        leafs = new ArrayList<>(bfsNums.length);
        preOrders = new ArrayList<>(bfsNums.length);
        postOrders = new ArrayList<>(bfsNums.length);
 
        TreeNode root = create(Arrays.asList(bfsNums), inOrderNums, 0, bfsNums.length - 1);
        preOrder(root);
        postOrder(root);
 
        print(leafs);
        print(preOrders);
        print(postOrders);
    }
 
    private static void print(List<String> r) {
        for(int i=0;i<r.size()-1;i++) {
            System.out.print(r.get(i)+" ");
        }
        System.out.println(r.get(r.size()-1));
    }
 
    private static void preOrder(TreeNode root) {
        if (root != null) {
            preOrders.add(root.val);
            preOrder(root.left);
            preOrder(root.right);
        }
    }
 
    private static void postOrder(TreeNode root) {
        if (root != null) {
            postOrder(root.left);
            postOrder(root.right);
            postOrders.add(root.val);
        }
    }
 
 
    /**
     * @param bfsNums     以 root 为根节点的子树的层次遍历结果
     * @param inOrderNums
     * @param inLeft      以 root 为根节点的子树的中序遍历的左边界下标
     * @param inRight
     * @return
     */
    private static TreeNode create(List<String> bfsNums, String[] inOrderNums, int inLeft, int inRight) {
        if (bfsNums.size() <= 0) {
            return null;
        }
 
        // 这句和构建树的逻辑无关，只是获取所以叶子节点
        if (bfsNums.size() == 1) {
            leafs.add(bfsNums.get(0));
        }
 
 
        TreeNode root = new TreeNode(bfsNums.get(0));
        int index = indexOfInOrder(inOrderNums, bfsNums.get(0));
 
        // root 的左子树的层次遍历的结果
        List<String> leftBfsNums = new ArrayList<>();
        List<String> rightBfsNums = new ArrayList<>();
        // 注意 不包括 root 节点，所以 i = 1 而不是 0
        for (int i = 1; i < bfsNums.size(); i++) {
            String cur = bfsNums.get(i);
            // cur 是 root 左子树中的节点？
            boolean curOfLeft = false;
            for (int j = inLeft; j <= index; j++) {
                if (cur.equals(inOrderNums[j])) {
                    curOfLeft = true;
                    break;
                }
            }
            if (curOfLeft) {
                leftBfsNums.add(cur);
            } else {
                rightBfsNums.add(cur);
            }
        }
 
        root.left = create(leftBfsNums, inOrderNums, inLeft, index - 1);
        root.right = create(rightBfsNums, inOrderNums, index + 1, inRight);
        return root;
    }
 
 
    private static int indexOfInOrder(String[] inOrderNums, String k) {
        int index = 0;
        for (; index < inOrderNums.length; index++) {
            if (k.equals(inOrderNums[index])) {
                break;
            }
        }
        return index;
    }
 
    private static class TreeNode {
        String val;
        TreeNode left;
        TreeNode right;
 
        public TreeNode(String val) {
            this.val = val;
        }
    }
}
```

----------
156

携程客户下单的时候系统会发放一个优惠券码，用户在前端界面看到的展现形式如下：“1Ct3r4ip_ti4C6k9Et^”，包含数字、字母、和 [\]^_’ 6个特殊字符。

为了安全性，系统在使用的时候做解密操作，删除里面的数字部分，只验字母A~z以及[\]^_’ 6个特殊字符部分才是有效的，并且在解密后不会重新排序字母的顺序，按照之前的对应顺序排列。

如上所示，如果一个客户拿到的优惠券码是这个：1Ct3r4ip_ti4C6k9Et^  ， 请用java语言提取正确的优惠券码。

输入描述:
1Ct3r4ip_ti4C6k9Et^
输出描述:
Ctrip_tiCkEt^

示例1
输入

1Ct3r4ip_ti4C6k9Et^
输出

Ctrip_tiCkEt^

```
import java.util.Scanner;
public class Main{
    public static void main(String[] arg){
        String str="1Ct3r4ip_ti4C6k9Et^";
        //Scanner sc=new Scanner(System.in);
        //str=sc.next();
        char[] chars = str.toCharArray();
        StringBuffer stringBuffer = new StringBuffer("");
        for (int i = 0; i < chars.length; i++) {
            if (!Character.isDigit(chars[i])){
                stringBuffer.append(chars[i]);
            }
        }
        System.out.println(stringBuffer);
    }
}
```

----------
157

请使用random() 函数，生成 10个随机数，并对它进行降序排序 ，要求有效率。
注意：不允许使用代码库提供的 sort() 之类现成的排序函数。
输出描述:
1
2
2
4
5
5
6
6
8
10
示例1
输入

1
输出

1
说明
因为是random产生，所以只要排序对就行
备注:
因为是random产生，所以只要排序对就行

```
import java.util.*;
public class Main{
    public static void main(String[] args){
        Random random = new Random();
        int[] array = new int[10];
        for(int i=0;i<10;i++){
            int number = random.nextInt(10);
            for(int k=0;k<=i;k++){
                //如果新数字比当前数字大，则确定位置
                if(k==i){
                    array[i]=number;
                }else if(number<=array[k]){
                    int temp = array[k];
                    array[k]=number;
                    number = temp;
                }
            }
        }
        System.out.print(1);
         
    }
}
```

----------
158

有一批订单记录，数据有订单号，入店时间，离店时间；
输入一个时间值A，需要在这批记录中找到符合入离店时间范围（A大于等于入店时间，并且A小于等于离店时间）内的所有记录。 单次查询时间复杂度控制在O(logN)
※注意：订单号升序输出 

输入描述:
记录数：10
时间值A：20180602
订单号 入店时间 离店时间
1001 20180103 20180105
1002 20180202 20180203
1003 20180304 20180306
1004 20180401 20180408
1005 20180501 20180504
1006 20180601 20180604
1007 20180705 20180706
1008 20180801 20180804
1009 20180903 20180903
1010 20181003 20181003
以上输入都为整型
输出描述:
1006
示例1
输入

10
20180602
1001 20180103 20180105
1002 20180202 20180203
1003 20180304 20180306
1004 20180401 20180408
1005 20180501 20180504
1006 20180601 20180604
1007 20180705 20180706
1008 20180801 20180804
1009 20180903 20180903
1010 20181003 20181003
输出

1006

示例2
输入

5
20170103
1013 20180103 20180105
1022 20180102 20180103
1103 20180104 20180106
1034 20180101 20180102
1105 20180201 20180204
输出

null
说明
查不到时输出null字符串（小写）

示例3
输入

4
20180103
1013 20180103 20180105
1022 20180102 20180103
1026 20180103 20180103
1007 20180101 20180109
输出

1007
1013
1022
1026

```
import java.io.*;
import java.util.*;
public class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        int date = Integer.parseInt(br.readLine());
        //int[][] order = new int[n][3];
        int order = 0;
        int l = 0;
        int r = 0;
        ArrayList<Integer> ans = new ArrayList();
        for(int i = 0; i < n; i++){
            String[] s = br.readLine().split(" ");
            order = Integer.parseInt(s[0]);
            l = Integer.parseInt(s[1]);
            r = Integer.parseInt(s[2]);
            if(l <= date && date <= r){
                ans.add(order);
            }
        }
        if(ans.size() == 0){
            System.out.println("null");
        }else{
            Collections.sort(ans);
            for(Integer a : ans){
                System.out.println(a);
            }
        }
         
    }
}
```

----------
157

输入一个long类型的数值, 求该数值的二进制表示中的1的个数 .

输入描述:
long 类型的数值
输出描述:
该数值二进制表示中1的个数
示例1
输入

3
输出

2
说明
3的二进制表示: 11, 所以1个数为2
示例2
输入

65
输出

2
说明
65的二进制为:1000001，所以１的个数为：２

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
 
public class Main {
    public static void main(String[] args) throws IOException {
        //Scanner sc = new Scanner(System.in);
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        long n = Long.parseLong(bf.readLine());
        String str = Long.toBinaryString(n);
        int count = 0;
        for(int i=0; i<str.length(); i++){
            if(str.charAt(i) == '1'){
                count ++;
            }
        }
        System.out.println(count);
    }
}
```

----------

160

每个整数都希望可以整除很多数字，特别是它自身包含的数字，我们将整数分为三类：

1. 数字可以整除它包含的一部分数字，比如72，由，7和2两种数字组成，72可以整除2，我们称这个数字是开心的，用”H”表示。

2. 数字不能整除它包含的任何数字，比如73，由，7和3两种数字组成，73不能整除任何数，我们称这个数字是沮丧的，用”S”表示。

3. 数字可以整除它包含的所有数字，比如12，既可以整除1又可以整除2，我们称它是一个非常棒的数，用“G”表示。  (0可以被任何数整除。)

输入描述:
输入第一行包含一个整数T，表示数据组数(1<=T<=100). 接下来T行，每行包含一个正整数n(1<=n<=10^12)，表示需要你判断的数字。
输出描述:
对于每组测试数据输出一行，“H”，“S”或“G”。表示整数种类。
示例1
输入

3
72
73
12
输出

H
S
G

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;
 
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(br.readLine());
        while (t-- > 0) {
            String s = br.readLine();
            long n = Long.parseLong(s);
            long temp = n;
            int count = 0;
            while (temp > 0) {
                long x = temp % 10;
                if (x == 0) {
                    count++;
                } else if (n % x == 0) {
                    count++;
                }
                temp /= 10;
            }
            if (count == 0) {
                System.out.println("S");
            } else if (count == s.length()) {
                System.out.println("G");
            } else {
                System.out.println("H");
            }
        }
    }
}
```

----------
161

给定一个仅由小写字母x和y组成且长度不超过105的字符串，每次可以将字符串中的一个子串xy替换成字符串yyx，那么至少要替换多少次才能让字符串中不存在子串xy？

输入描述:
输入给定的字符串。
输出描述:
输出最少替换次数对109+7取模后的结果。
示例1
输入

xxy
输出

3


1.将“xy”变为“yyx”，本质就是将“x”向后移动，只有‘y’在增加，‘x’的数目从没变过。
2. 每次遇到一个“y”,统计一下这个“y”前面的“x”的数目num，移动次数就是2^(num)-1.
这里感谢大佬的思路 @写意自风流 ，幂次运算会超时，所以2^(num)-1可以优化为代码中的
X = (2*X+1) % (10 ** 9 + 7)
```
import java.io.*;
//字符串替换
public class Main{
    public static void main(String args[]) throws IOException{
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        String s=br.readLine();
        int ycnt=0;
        int ans=0;
        for(int i=s.length()-1;i>=0;i--){
            if(s.charAt(i)=='x'){
                ans+=ycnt;
                ans%=1000000007;
                ycnt*=2;
                ycnt%=1000000007;
            }
            else{
                ycnt++;
            }
        }
        System.out.println(ans);
        return ;
    }
}
```

----------
162

一组无序的自然数集合，由0,1,2... ...,n的数字和一个的数字X（X>=0 && X<=n）组成，请从集合中找出这个重复数字X。
输入描述:
空格分割的自然数集合
输出描述:
重复数字

示例1
输入

9 6 4 2 1 3 5 7 0 1 8
输出

1
说明
0,1,2,3,4,5,6,7,8,9 + 1

示例2
输入

3 0 2 2 1
输出

2
说明
0,1,2,3 + 2

```
import java.util.Map;
import java.util.HashMap;
import java.util.*;
import java.io.*;
public class Main {
     public static void getNumber(String number){
        String[] list = number.split(" ");
        Map<String,String> map = new HashMap<String,String>();
            for(int i = 0;i<list.length;i++){
                if(map.get(list[i])==null){
                    map.put(list[i], list[i]);
                } else
                if(map.get(list[i])!=null){
                    System.out.print(list[i]);
                } 
            }
    }
    public static void main(String[] args) throws Exception {
        InputStreamReader ir = new InputStreamReader(System.in);
        BufferedReader br = new BufferedReader(ir);
        getNumber(br.readLine());
    }
}
```

----------
163

已知一个正整数n，(3 <= n <= 15)，将所有n的乘方幂以及所有n的乘方幂（有限个且互不相等）之和组成一个递增序列。例如，当n为4时，该序列为：
1, 4, 5, 16, 17, 20, 21……
(4^0, 4^1, 4^0+4^1, 4^2, 4^0+4^2, 4^1+4^2, 4^0+4^1+4^2……)
请求出该序列的第K项(10进制)。
输入描述:
输入只有1行，为2个正整数，两数之间用一个空格隔开：
n K
(n, K的含义与上述描述一致, 且3<=n<=15, 10<=K<=1000)。
输出描述:
输出为计算结果，为一个正整数（注意在所有测试数据中，结果均不会超过2.1*10^9）。整数前不要有空格或其他任何符号。

示例1
输入

3 100
输出

981

就是将k转成2进制，比如k=6，n=4,k的2进制为110，然后以n进制输出来。即1*42+1*41+0*40
```
import java.io.*;
   
public class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] temp = br.readLine().split(" ");
        int n = Integer.parseInt(temp[0]), k = Integer.parseInt(temp[1]);
        int ans = 0, val = 1;
        while(k!=0){
            ans += (k&1)*val;
            k >>= 1;
            val *= n;
        }
        System.out.println(ans);
    }
}
```

----------
165

数学老师正在教授小畅和小游两人素数的概念。为了帮助巩固两人的知识，老师说出一个数，要求小游和小畅合作，每人说出一个素数，使得两人说出的素数的和刚好等于老师说出的数。请编写程序计算两人说出的素数对的个数。如，老师说10，小畅和小游可以说出两对素数，分别为（5,5）和（3,7）（不考虑顺序）。
输入描述:
输入包括一个整数n,(3 ≤ n < 1000)
输出描述:
输出符合条件的素数对的个数

示例1
输入

10
输出

2

```
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;
 
public class Main {
 
    static ArrayList<Integer> record =new ArrayList<>();
     
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        recordPrimes(n);
        int count=0;
         
        //对于有序数组的双指针的方法
        int i=0;
        int j=record.size()-1;
        while (i<=j){
            int sum=record.get(i)+record.get(j);
            if (sum==n){
                count++; i++; j--;
            }
            else if (sum<n) i++;
            else j--;
        }
        System.out.println(count);
    }
 
    //比较快的判断是否为素数的方法
    static void recordPrimes(int n) {
        boolean[] isPrim = new boolean[n];
        Arrays.fill(isPrim, true);
        for (int i = 2; i * i < n; i++)
            if (isPrim[i])
                for (int j = i * i; j < n; j += i)
                    isPrim[j] = false;
        for (int i = 2; i < n; i++)
            if (isPrim[i]) record.add(i);
    }
}

```

----------
166

幼儿园里有有M个小朋友在课件玩耍，每个人手中现有ni个玩具。为了公平起见，老师需要让每个小朋友手中有相同数量的玩具。假设老师每次只能从一个人手中拿走两个玩具并给另一个小朋友。求老师最少需要做多少次这样的玩具转移。如果不存在可行的方案则输出-1。
输入描述:
每个输入包含一个测试用例。每个测试用例的第一行包含一个整数M（1 <= M<= 100），接下来的一行包含M个整数ni（1 <= ni <= 100）。
输出描述:
输出一行表示最少需要移动多少次可以平分苹果，如果方案不存在则输出-1。
示例1
输入

4
7 15 9 5
输出

3
示例2
输入

2
3 6
输出

-1


1. 首先判断玩具总数sum能否被M整除，不能整除输出-1返回
2.计算出平均值average，如果能平均分，这是最后每个小朋友分到的数量，在此基础上，遍历每个小朋友的数量ni，ni减去average为diff
3.diff必须为偶数，diff大于0表示这个小朋友要分给其他小朋友i次2个玩具，diff小于0，表示这个小朋友要从别的小朋友那里拿到j次2个玩具，diff必须为偶数，因为每次分配拿或者给的数量是2，一个数加减2的奇偶性不变，无论怎么分配diff奇偶性不变， 最后的结果是每个小朋友的diff为0，而0是偶数，所以一旦发现某个小朋友的diff为奇数，直接输出-1返回
4.diff为偶负数的小朋友要从diff为偶正数的小朋友那里拿玩具，最小次数就是依次让每个diff为负数的小朋友diff变为0，总的次数就是所有正偶数相加除以2或者负偶数相加除以-2

```
import java.util.Scanner;
 
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] record = new int[n];
        int sum =0;
        for (int i = 0; i < n; i++) {
            record[i]=scanner.nextInt();
            sum+=record[i];
        }
        if (sum%n!=0){
            System.out.println(-1);
            return;
        }
        int average= sum/n;
        int count=0;
        for (int i = 0; i < n; i++) {
            int diff=record[i]-average;
            if (diff%2!=0){
                System.out.println(-1);
                return;
            }
            if (diff>0){
                count+=diff/2;
            }
        }
        System.out.println(count);
    }
}
```

----------

170

现在有红，绿两种颜色的石头，现在我们需要用这两种石头搭建一个塔，塔需要满足如下三个条件：  1． 第1层应该包含1块石头，第2层应该包含两块，第 i 层需要包含 i 块石头。  2． 同一层的石头应该是同一个颜色（红或绿）。  3． 塔的层数尽可能多。  问在满足上面三个条件的前提下，有多少种不同的建造塔的方案，当塔中任意一个对应位置的石头颜色不同，我们就认为这两个方案不相同。石头可以不用完。

输入描述:
输入仅包含两个正整数，分别表示红和绿砖块的数量a，b（0<=a,b<=2*10^5,a+b>=1）。
输出描述:
输出和仅包含一个正整数，表示不同的方案数对1000000007取模的结果。
示例1
输入

4 6
输出

2


 * array[i][j]表示前i层有j个绿色宝石的方案数
 * 那么可以得出递推式 array[i][j]=array[i-1][j-i]+array[i-1][j];
 * 针对第i层来说，如果第i层放置绿色宝石，那么前i-1层就只能放j-i个绿色宝石，所以为array[i-1][j-i]
 * 如果第i层不放置绿色宝石，而放红色宝石，那么前i-1层就放j个绿色宝石，为array[i-1][j]
 * 所以没有必要保存所有的状态，只需要保存上一层和当前层的状态即可
 
```
import java.util.*;
public class Main {
 
            public static void main(String[] args) {
                Scanner in = new Scanner(System.in);
                int G = in.nextInt();
                int R = in.nextInt();
                int min = Math.min(R, G);
                int max = Math.max(R, G);
                R = min;
                G = max;
                int level = 1, sum = 0;
                /**
                 * level 为最大层数
                 */
                while (sum <= R + G) {
                    level++;
                    sum += level;
                }
                /**
                 * array[i][j]表示前i层有j个绿色宝石的方案数
                 * 那么可以得出递推式 array[i][j]=array[i-1][j-i]+array[i-1][j];
                 * 针对第i层来说，如果第i层放置绿色宝石，那么前i-1层就只能放j-i个绿色宝石，所以为array[i-1][j-i]
                 * 如果第i层不放置绿色宝石，而放红色宝石，那么前i-1层就放j个绿色宝石，为array[i-1][j]
                 * 所以没有必要保存所有的状态，只需要保存上一层和当前层的状态即可
                 */
                int[][] array = new int[2][G + 1];
                int answer = 0;
                if (G > 0) {
                    array[1][1] = 1;
                    answer++;
                }
                if (R > 0) {
                    array[1][0] = 1;
                    answer++;
                }
                int total = 1;
                int result;
                /**
                 * total是前lev层所需要的石头总数量，不分颜***r />          */
                for (int lev = 2; lev < level; lev++) {
                    total += lev;
                    result = 0;
                    /**
                     * one代表当前层
                     * two代表上一层
                     */
                    int one = lev % 2;
                    int two = (lev - 1) % 2;
                    /**
                     * 遍历在当前层放置的绿色宝石的数量
                     */
                    for (int i = 0; i <= total && i <= G; i++) {
                        array[one][i] = 0;
                        /**
                         * 当放在第lev层是绿色宝石的时候，那么
                         * array[one][i]+=array[two][i-lev]
                         * 因为本来就只有i颗绿色宝石，你在lev层放置了lev颗之后，那么前lev-1层只能放置i-lev颗绿色宝石
                         * 而前lev-1层只能放置i-lev颗绿色宝石为array[two][i-lev]
                         */
                        if (i >= lev && R >= total - i) {
                            array[one][i] += array[two][i - lev];
                            if (array[one][i] >= 1000000007) {
                                array[one][i] %= 1000000007;
                            }
 
                        }
                        /**
                         * 当放在第lev层是红色宝石的时候，那么
                         * array[one][i]+=array[two][i]
                         * 因为本来就只有i颗绿色宝石，你在lev层没有放置绿色宝石，那么就是说在lev-1层放置了lev颗绿色宝石
                         * 而前lev-1层只能放置lev颗绿色宝石为array[two][lev]
                         */
                        if (total - i <= R) {
                            array[one][i] += array[two][i];
                            if (array[one][i] >= 1000000007) {
                                array[one][i] %= 1000000007;
                            }
                        }
                        /**
                         * 因为one代表的是当前层，所以把它累加起来即可得出最终结果
                         */
                        if (array[one][i] != 0) {
                            result += array[one][i];
                            if (result >= 1000000007) {
                                result %= 1000000007;
                            }
                        }
                    }
                    answer=result;
                }
                System.out.println(answer);
                in.close();
            }
        }

```

----------
171

拉齐有一个01序列，他可以对这个序列进行任意多次变换，每次变换都是把序列的最后若干个元素放到最前面，例如：010011，将最后3个元素011放到最前面，序列变为011010。所有变换结束后，拉齐需要挑出一个全为1的连续区间，要求最大化区间长度。

输入描述:
共一行，一个01串，仅包含0或1。序列长度不超过50000。
输出描述:
一个整数，表示最长区间的长度。
示例1
输入

11011
输出

4

```
import java.util.*;
import java.io.*;
public class Main{
    public static void main(String[]args) throws Exception{
        //Scanner sc = new Scanner(System.in);
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line = br.readLine();
        int begin = 0;
        int end = -1;
        for(int i=0;i<line.length();i++){
            if(line.charAt(i)=='0'){
                begin = i;
                break;//遇到0z字符跳出
            }
        }
         for(int i=line.length()-1;i>=0;i--){
            if(line.charAt(i)=='0'){
                end = i;
                break;//遇到0z字符跳出
            }
        }
        //目前遇到所有1
        int maxLength = line.length()-1-end+begin;
        for(int i =  begin+1;i<end;i++){
            if(line.charAt(i)=='0'){
               maxLength=Math.max(maxLength,i-begin-1);
               begin = i;
            }
        }
        System.out.println(maxLength);
    }
}
```

----------
173

已知一个奇怪的队列，这个队列中有n个数，初始状态时，顺序是1,2,3,4,…n，是1-n按顺序排列。这个队列只支持一种操作，就是把队列中的第i号元素提前到队首(1<i<=n)，如有4个元素，初始为1，2，3，4,可以将3提前到队首，得到3，1，2，4 。  现在给出一个经过若干次操作之后的序列，请你找出这个序列至少是由原序列操作了多少次得到的。

输入描述:
第一行是一个整数n(1<=n<=10^5)，表示序列中数字的数量。 接下来一行有n个数，是1-n的一个全排列。数字之间用空格隔开。

输出描述:
输出仅包含一个数字，表示至少操作了几次
示例1
输入

5
5 2 1 3 4
输出

2

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
 
/* 队列最小修改
*
* */
public class Main {
    //将某一个元素移动到最前端，剩下的队列仍是顺序的
   public static void main(String[] args) throws IOException
    {
        BufferedReader buf = new BufferedReader(new InputStreamReader(System.in));
        String line1 = new String();
        while((line1=buf.readLine())!=null){
            String line2 = new String();
            line2 = buf.readLine();
            String[] array = line2.split(" ");
             
                int[] arr = new int[array.length];
                for (int i = 0; i < arr.length; i++)
                    arr[i] = Integer.parseInt(array[i]);
                int point = 0;
                for (int i = arr.length - 1; i > 0; i--) {
                    if (arr[i - 1] > arr[i]) {
                        point = i;
                        break;
                    }
                }
                System.out.println(point);
             
        }
    }
}
```

----------
174

给定一个12小时制的时间，请将其转换成24小时制的时间。说明：12小时制的午夜12：00：00AM，对应的24小时制时间为00：00：00。12小时制的中午12：00：00PM，对应的24小时制时间为12：00：00。
输入描述:
一个描述12小时制时间的字符串。所有的输入都是合理的，不用考虑输入不合理的情况。
输出描述:
一个描述24小时制时间的字符串。

示例1
输入

08:03:45PM
输出

20:03:45

```
import java.io.BufferedReader;
import java.io.InputStreamReader;
public class Main {
    public static void main(String[] args) throws Exception{
        BufferedReader bf =new BufferedReader(new InputStreamReader(System.in));
        String line=bf.readLine();
        if(line.equals("12:00:00AM")) {
            System.out.println("00:00:00");        
        }else if(line.equals("12:00:00PM")) {
            System.out.println("12:00:00");        
        }else if(line.endsWith("AM")) {
            System.out.println(line.substring(0, line.length()-2));        
        }else {        
            line=(Integer.parseInt(line.substring(0, 2))+12)+line.substring(2, line.length()-2);
            System.out.println(line);
        }
    }
}
```

----------
175

给定一个仅由小写字母组成的字符串。现在请找出一个位置，删掉那个字母之后，字符串变成回文。请放心总会有一个合法的解。如果给定的字符串已经是一个回文串，那么输出-1。
输入描述:
第一行包含T，测试数据的组数。后面跟有T行，每行包含一个字符串。
输出描述:
如果可以删去一个字母使它变成回文串，则输出任意一个满足条件的删去字母的位置（下标从0开始）。例如：

bcc

我们可以删掉位置0的b字符。
示例1
输入

3
aaab
baa
aaa
输出

3
0
-1

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main{
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        String str = null;
        int l = 0,r = 0;
        while( N-- > 0) {
            str = br.readLine();
            l = 0;
            r = str.length()-1;
            while( l<= r ) {
                if( str.charAt(l) == str.charAt(r) ) {
                    l++;
                    r--;
                }
                else {
                    if( isValid(str,l+1,r)) {
                        System.out.println(l);
                    }
                    else {
                        System.out.println(r);
                    }
                    break;
                }
            }
            if(l>r)
                System.out.println(-1);
        }
        return;
    }
    public static boolean isValid(String str,int l,int r) {
        int a = l ,b = r;
        while(a<b) {
            if(str.charAt(a) != str.charAt(b)) return false;
                a ++;
                b --;
        }
        return true;
    }
}
```

----------


178
输入一个整形数组（可能有正数和负数），求数组中连续子数组（最少有一个元素）的最大和。要求时间复杂度为O(n)。

输入描述:
【重要】第一行为数组的长度N（N>=1）

接下来N行，每行一个数，代表数组的N个元素
输出描述:
最大和的结果

示例1
输入

8
1
-2
3
10
-4
7
2
-5
输出

18
说明
最大子数组为 3, 10, -4, 7, 2

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int num = Integer.parseInt(bf.readLine());
        int[] nums = new int[num];
        for(int i =0;i<num;i++){
            nums[i]=Integer.parseInt(bf.readLine());
        }
        if (nums==null || nums.length <=0){
            return ;
        }
        int currentSum = 0;//记录当前值
        int findMax = Integer.MIN_VALUE;//记录全场最佳值
        for (int i = 0; i < nums.length ; i++) {
            if (currentSum<=0){
                currentSum = nums[i];
            }else{
                currentSum+=nums[i];
            }
            if (currentSum>findMax){
                findMax = currentSum;
            }
        }
        System.out.println(findMax);
    }
}
```

----------
179

24

在vivo产线上，每位职工随着对手机加工流程认识的熟悉和经验的增加，日产量也会不断攀升。
假设第一天量产1台，接下来2天(即第二、三天)每天量产2件，接下来3天(即第四、五、六天)每天量产3件 ... ... 
以此类推，请编程计算出第n天总共可以量产的手机数量。

输入例子1:
11

输出例子1:
35

```
public class Solution {
    public int solution (int n) {
      
        int res=0;
        int day=0;
        
        for(int i=1;day<n;i++){
            for(int j=1;j<=i&&day<n;j++){
                day++;
                res+=i;
            }
        }
        return res;       
    }
}
```

----------
180

现给定任意正整数 n，请寻找并输出最小的正整数 m（m>9），使得 m 的各位（个位、十位、百位 ... ...）之乘积等于n，若不存在则输出 -1。

输入例子1:
36

输出例子1:
49

输入例子2:
100

输出例子2:
455

```
public class Solution {
    public int solution (int n) {
        // write code here
        int result=resolve(n);
        if(result>0)
            return result;
        return -1;
    }
    
    public int resolve(int n){
        if(n<10)
            return n;
        for(int i=9;i>1;i--){
            if(n%i==0)
                return resolve(n/i)*10+i;
        }
        return -1;
    }
}
```

----------

