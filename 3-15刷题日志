186

给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

示例 1:

输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
示例 2:

输入: 2->1->3->5->6->4->7->NULL 
输出: 2->3->6->7->1->5->4->NULL
说明:

应当保持奇数节点和偶数节点的相对顺序。
链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。

思路：

1、根据奇偶数原则，首先将odd指向head，even指向head.next，同时evenhead也指向head.next。

2、接下来，分别以odd开头“删除”偶数链表，以even 开头删除奇数链表。这样一来将整个链表拆分为两个链表。同时保留了三个节点，分别是odd（奇数链表的最后一个节点），even（偶数链表最后一个节点），evenhead（偶数链表第一个节点）。

3、最后只需将奇偶链表连接起来即可。odd.next=evenhead

```

class Solution 
{
    public ListNode oddEvenList(ListNode head) 
    {
        if(head==null)
            return null;
        if(head.next==null||head.next.next==null)
            return head;
        ListNode odd=head;
        ListNode even=head.next;
        ListNode evenhead=even;//此处的evenhead是链表奇偶化之后偶半链的第一个节点，在下面你的while循环中，evenhead一直处于无前驱节点状态
        while(odd.next!=null&&even.next!=null){
            odd.next=odd.next.next;
            even.next=even.next.next;
            odd=odd.next;
            even=even.next;
        }//经过while循环之后，实际上链表已经被切成两半了，一半是奇链表，一半是偶链表，其中保留了两个指针，一个是odd奇链表的最后一个元素，evenhead是偶链表的第一个节点。
        odd.next=evenhead;//将奇偶链表连接起来
        return head;
    }
}
```

----------
187

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

示例 1:

输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
示例 2:

输入: [3,4,5,1,3,null,1]

     3
    / \
   4   5
  / \   \ 
 1   3   1

输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.

思路：每一个节点都可以判断选择当前值是否比选择当前节点的儿子节点值的和哪一个较大

```
class Solution {
     public int rob(TreeNode root) {
        if (root == null) return 0;
        int val1 = root.val;
        //当该节点的左儿子不为空，那么就去找左儿子的儿子们返回的最大值
		//（不能在计算左儿子，因为要间隔）
        if (root.left != null) val1 += rob(root.left.left) + rob(root.left.right);
        if (root.right != null) val1 += rob(root.right.left) + rob(root.right.right);
        int val2 = rob(root.left) + rob(root.right);
        //返回两种情况的最大值，val1代表从当前节点开始找，val2代表从儿子节点开始找
        return Math.max(val1, val2);
    }
}
```

----------

189

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

示例 1:

输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
示例 2:

输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。



dp[i] 表示数字i拆分为至少两个正整数之和的最大乘积
j *（i-j）表示的是将i分成两份
j * dp[i-j]表示的是将i 分成 j 和i-j所取得最大乘积的分发。

于任意小于i的数字j，首先计算拆分为两个数字的乘积，即j乘以 i-j，然后是拆分为多个数字的情况，这里就要用到 dp[i-j] 了，这个值表示数字 i-j 任意拆分可得到的最大乘积，再乘以j就是数字i可拆分得到的乘积，取二者的较大值来更新 dp[i]
```
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n + 1];
        dp[1] = dp[2]=1;
        for (int i = 3; i <= n; i++) {
            // 求解dp[i]
            for (int j = 1; j <= i - 1; j++) {
                dp[i] = max3(dp[i], j * (i - j), j * dp[i - j]);
            }
        }
        return dp[n];
    }
    private int max3(int a, int b, int c) {
        return Math.max(a, Math.max(b, c));
    }
}
```

----------
190

编写一个函数，以字符串作为输入，反转该字符串中的元音字母。

示例 1:

输入: "hello"
输出: "holle"
示例 2:

输入: "leetcode"
输出: "leotcede"

双指针法

```
class Solution {
    public String reverseVowels(String s) {
         if(s==null) {
        	return null;
        }
        int len=s.length();
        char[] ch=s.toCharArray();
        int i=0,j=len-1;
       while(i<j) {
        	if(!isVowels(ch[i])) {
        		
        		i++;
        	}
        	if(!isVowels(ch[j])) {
        		j--;
        	}
        	if(isVowels(ch[i])&&isVowels(ch[j])) {
        		char temp=ch[i];
    			ch[i]=ch[j];
    			ch[j]=temp;
    			i++;
    			j--;
        	}
        }
        String str=new String(ch);
    	return str;
    }
    public  boolean isVowels(char c) {
    	if(c=='a'||c=='e'||c=='i'||c=='o'||c=='u') {
    		return true;
    	}
    	if(c=='A'||c=='E'||c=='I'||c=='O'||c=='U') {
    		return true;
    	}
    	return false;
    }
}
```

----------
191

给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

示例 1:

输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]

先用hashmap计数，然后minheap筛选，堆最大深度为k+1

```
class Solution {
    public List<Integer> topKFrequent(int[] nums, int k) {

        List<Integer> result = new LinkedList<>();
        Map<Integer, Integer> count = new HashMap<>();
        PriorityQueue<Map.Entry<Integer, Integer>> minHeap = new PriorityQueue<>((o1, o2) -> o1.getValue() - o2.getValue());

        for (int num : nums) {
            count.put(num, count.getOrDefault(num, 0) + 1);
        }
        for (Map.Entry entry : count.entrySet()) {
            minHeap.add(entry);
            if (minHeap.size() > k) {
                minHeap.poll();
            }
        }
        while (minHeap.size() > 0) {
            result.add(minHeap.poll().getKey());
        }
        Collections.reverse(result); // minheap出来是递增序的，反转成递减序

        return result;
    }
}
```

----------
192

给定两个数组，编写一个函数来计算它们的交集。

示例 1:

输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2]
示例 2:

输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [9,4]

```
//利用集合实现
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        TreeSet<Integer> set=new TreeSet<Integer>();
        for(Integer nums:nums1){	//将nums1的元素放入数组中
            set.add(nums);
        }
        ArrayList<Integer> list=new ArrayList<Integer>();	//将交集元素放入链表存储
        for(Integer nums:nums2){
            if(set.contains(nums)){	//如果这个元素是交集元素
                list.add(nums);	//将这个元素放入链表中
                set.remove(nums);	//将集合中的这个元素删除 以防有重复元素
            }
        }
        int[] res=new int[list.size()];
        for(int i=0;i<list.size();i++){	//将链表用数组存储
            res[i]=list.get(i);
        }
        return res;
    }
}
```

----------
193

给定两个数组，编写一个函数来计算它们的交集。

示例 1:

输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2,2]
示例 2:

输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [4,9]
说明：

输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。
我们可以不考虑输出结果的顺序。


思路是先进行排序，两个都是从小到大排序后，维护两个指针，每个数组的指针对应的元素相互比较，如果相等，证明这就是要返回的结果，保存后两个指针同时向后移动，如果不想等，那移动较小的那个，期望移动较小的数组指针找到能和另一个数组指针相等的元素。这个过程直到其中一个数组达到数组尾部结束。

```
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        if(nums1==null||nums2==null||nums1.length<=0||nums2.length<=0){
            return new int[0];
        }

        Arrays.sort(nums1);
        Arrays.sort(nums2);

        List<Integer> list = new ArrayList<>();
        for (int i = 0, j = 0; i < nums1.length&&j<nums2.length;) {
            if (nums1[i] < nums2[j]) {
                ++i;
            }else if(nums2[j]< nums1[i]){
                ++j;
            }else{
                list.add(nums1[i]);
                ++i;
                ++j;
            }
        }

        int[] target = new int[list.size()];
        for(int i = 0;i < target.length;i++){
            target[i] = list.get(i);
        }
        return target;
    }
}
```

----------
194
给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

说明:
不允许旋转信封。

示例:

输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出: 3 
解释: 最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。

对所有信封排序之后，原题相当于是二维的最长上升子序列。
相当于是一个01背包问题。建立dp数组，dp[i]代表包括第i+1封信，当前信封的最大嵌套数量。
每次第i封信的最大嵌套数量需要遍历信件j=[0,i]保留最大值，动态转移方程为
dp[i] = Math.max(dp[i], dp[j] + 1);

![](TY/65.PNG)
```
class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        Arrays.sort(envelopes, (a, b)->a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);
        int[] dp = new int[envelopes.length];
        Arrays.fill(dp, 1);
        int result = 0;
        for(int i = 0; i < envelopes.length; i++) {
            for(int j = 0; j < i; j++) {
                if(envelopes[i][0] > envelopes[j][0] && envelopes[i][1] > envelopes[j][1]){
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            result = Math.max(dp[i], result);
        }
        return result;
    }
}
```

----------
195

给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x < 10n 。

示例:

输入: 2
输出: 91 
解释: 答案应为除去 11,22,33,44,55,66,77,88,99 外，在 [0,100) 区间内的所有数字。

思路：
dp[i]=dp[i-1]+(dp[i-1]-dp[i-2])*(10-(i-1));加上dp[i-1]没什么可说的，加上之前的数字
dp[i-1]-dp[i-2]的意思是我们上一次较上上一次多出来的各位不重复的数字。以n=3为例，n=2已经计算了0-99之间不重复的数字了，我们需要判断的是100-999之间不重复的数字，那也就只能用10-99之间的不重复的数去组成三位数，而不能使用0-9之间的不重复的数，因为他们也组成不了3位数。而10-99之间不重复的数等于dp[2]-dp[1]。
当i=2时，说明之前选取的数字只有1位，那么我们只要与这一位不重复即可，所以其实有9(10-1)种情况（比如1，后面可以跟0,2,3,4,5,6,7,8,9。 当i=3时，说明之前选取的数字有2位，那么我们需要与2位不重复，所以剩余的
有8（10-2）种（比如12，后面可以跟0,3,4,5,6,7,8,9）


```
class Solution {
      public int countNumbersWithUniqueDigits(int n) {
      
        if(n==0)
            return 1;
        int []dp=new int [n+1];
        dp[0]=1;
         dp[1]=10;
        for(int i=2;i<=n;i++)
        {
            dp[i]=dp[i-1]+(dp[i-1]-dp[i-2])*(10-(i-1));
        }
        return dp[n];
    }
}
```

----------
196

有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？

如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。

你允许：

装满任意一个水壶
清空任意一个水壶
从一个水壶向另外一个水壶倒水，直到装满或者倒空
示例 1: (From the famous "Die Hard" example)

输入: x = 3, y = 5, z = 4
输出: True
示例 2:

输入: x = 2, y = 6, z = 5
输出: False

如果z=ax+by（a，b均整），x与y最大公约数为g，那么z一定是g的整数倍，即z%g=0！！

```
class Solution {
    public boolean canMeasureWater(int x, int y, int z) {
   return z == 0 || (x + y >= z && z % gcd(x, y) == 0);
    }
    int gcd(int x, int y) {
        return y == 0 ? x : gcd(y, x % y);
    }
}
```

----------
197

给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。

说明：不要使用任何内置的库函数，如  sqrt。

示例 1：

输入：16
输出：True
示例 2：

输入：14
输出：False

```
//二分法
class Solution {
    public boolean isPerfectSquare(int num) {
        if(num == 1) return true;
        long s = 2;
        long e = num/2;
        while(s <= e){
            long m = s+(e-s)/2;
            long n = m*m;
            if(n>num) e = m-1;
            else if(n<num) s = m+1;
            else return true;
        }
        return false;
    }
}
```


----------
204

给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。

示例:

nums = [1, 2, 3]
target = 4

所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

请注意，顺序不同的序列被视作不同的组合。

因此输出为 7。

dp[i]是target为i的组成总数
当target是0，即i是0的时候，理解上dp[0]应该是0，但是这里要设置成1，是因为要把这个1想象成空集去组合其他的数

因为dp[i-nums[j]]里面存的是形成i-nums[j]这个target的组合数，多一个nums[j]从而使target变成i并不会使得组合数增加。
即随着nums[j]不同，dp[i]的值应该是考虑所有nums[j]后的总和。
```
class Solution {
    public int combinationSum4(int[] nums, int target) {
        if (nums == null || nums.length == 0 || target <= 0) return 0;
        int[] dp = new int[target + 1];
        dp[0] = 1;
        for (int i = 1; i <= target; i++) 
            for (int j = 0; j < nums.length; j++) 
                if (i >= nums[j]) dp[i] += dp[i - nums[j]];
        return dp[target];
    }
}
```

----------
205
给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。
请注意，它是排序后的第k小元素，而不是第k个元素。

示例:

matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。

未获一个大小为k的优先队列，采用大顶堆。

大顶堆获取最小的k个数，因为每次都出去最大的。

小顶堆获取最大的k个数，因为每次都是出去最小的

compare（int o1, int o2）方法 return o1 - o2 是升序，return o2 - o1 是降序。
```
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        PriorityQueue<Integer> queue=new PriorityQueue<>(new Comparator<Integer>(){
            public int compare(Integer a,Integer b)
            {
                return b-a;
            }
        });
        for(int i=0;i<matrix.length;i++)
        {
            for(int j=0;j<matrix[0].length;j++)
            {
                queue.add(matrix[i][j]);
                if(queue.size()>k)
                {
                    queue.poll();
                }
            }
        }
        return queue.poll();
    }
}
```

----------
206

给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成。如果可以构成，返回 true ；否则返回 false。

(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。)

注意：

你可以假设两个字符串均只含有小写字母。

canConstruct("a", "b") -> false
canConstruct("aa", "ab") -> false
canConstruct("aa", "aab") -> true


```
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        if(ransomNote.length() > magazine.length()) return false;
        char[] str1 = ransomNote.toCharArray();
        char[] str2 = magazine.toCharArray();
        Arrays.sort(str1);
        Arrays.sort(str2);
        int i = 0, j = 0;
        while(i < str1.length && j < str2.length){
            if(str1[i] == str2[j]) {
                i++;
                j++;
            }else if(str1[i] > str2[j]){
                j++;
            }else if(str1[i] < str2[j]){
                return false;
            }
        }
        if(i == str1.length) return true;
        else return false;
    }
}

```
----------
209

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

案例:

s = "leetcode"
返回 0.

s = "loveleetcode",
返回 2.

```
//用一个LinkedHashMap实现，key为字母，value如果第一次插入存入索引，再次插入存-1，然后遍历HashMap，找到第一个不是-1的value（LinkedHashMap保证了插入顺序，所以找到的一定是第一个唯一字符）。

class Solution {
    public int firstUniqChar(String s) {
        Map<Character, Integer> sCount = new LinkedHashMap<Character, Integer>();
        for (int i = 0; i < s.length(); i++) {
            char letter = s.charAt(i);
            if (sCount.containsKey(letter)) {
                sCount.put(letter, -1);
            }
            else {
                sCount.put(letter, i);
            }
        }
        Iterator iter = sCount.entrySet().iterator();
        while (iter.hasNext()) {
            Map.Entry<Character, Integer> entry = (Map.Entry)iter.next();
            if (entry.getValue() == -1) {
                continue;
            }
            return entry.getValue();
        }
        return -1;
    }
}
```
----------
212

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

示例 1:
s = "abc", t = "ahbgdc"

返回 true.

示例 2:
s = "axc", t = "ahbgdc"

返回 false.


贪心，两个指针a和i，分别遍历s和t，遇到一样的就a++，不管怎么样，i一直++。如果a和s.length()相等，return true。
```
class Solution {
    public boolean isSubsequence(String s, String t) {
        if(s.length()==0) return true;
        int tLen=t.length();
        int a=0;
        for(int i=0;i<tLen;i++){
            if(s.charAt(a)==t.charAt(i)){
                a++;
            }
            if(a==s.length())                 //此语句要放在循环内部
                return true;
        }
        return false;
    }
}
```

----------
214

输入:
s = "aaabb", k = 3

输出:
3

最长子串为 "aaa" ，其中 'a' 重复了 3 次。

示例 2:

输入:
s = "ababbc", k = 2

输出:
5

最长子串为 "ababb" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。

要找s[i,j]的最大子串，先统计频数，然后遍历一遍频数，找出第一个频数小于k且大于0的字符，然后找出这个字符的位置，接下来的分析很重要，这个字符一定不能出现在任何的子串中，因为i,j是整个的子串，在ij里面频数都没有达到k，那么在ij的任何子串中，这个字符也不可能达到频数k。所以不能有这个字符，那么就在这个位置做一个分治，返回前半部分和后半部分的最大值。

```
//indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。str - 要搜索的子字符串。
fromIndex - 开始搜索的索引位置。 
 public class Solution{
     public int longestSubstring(String s, int k) {
         return longestSubstringSub(s, k, 0, s.length() - 1);
     }
 
    private int longestSubstringSub(String s, int k, int start, int end){
         if(start > end) return 0;
         int[] count = new int[26];
         for(int i = start; i <= end; i++){
             count[s.charAt(i) - 'a']++;
         }
         for(int i = 0; i < 26; i++){
             if(count[i] > 0 && count[i] < k){
                 int pos = s.indexOf((char)(i + 'a'), start);
                 return Math.max(longestSubstringSub(s, k, start, pos - 1), longestSubstringSub(s, k, pos + 1, end));
             }
         }
         return end - start + 1;
     }
 }
```

----------
217

给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。

注意:

num 的长度小于 10002 且 ≥ k。
num 不会包含任何前导零。
示例 1 :

输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。


思路，从左到右，找第一个比后面大的字符，删除，清零，k次扫描。
```
class Solution {
    public String removeKdigits(String num, int k) {
        if (num.length() == k) return "0";
        StringBuilder s = new StringBuilder(num);
        for (int i = 0; i < k; i++) {
            int idx = 0;
            for (int j = 1; j < s.length() && s.charAt(j) >= s.charAt(j - 1); j++) idx = j;
            s.delete(idx, idx + 1);
            while (s.length() > 1 && s.charAt(0) == '0') s.delete(0, 1);
        }
        return s.toString();
    }
}

```
----------
220

给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

在构造过程中，请注意区分大小写。比如 "Aa" 不能当做一个回文字符串。

注意:
假设字符串的长度不会超过 1010。

示例 1:

输入:
"abccccdd"

输出:
7

解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。


基本上就是哈希表的思想就好，就看你的代码写的是否够简洁了，这里需要注意的是，所有字母的构造的最长的回文串，那么就是要把所有的字母都要用上的，也就是说当某个字母的字符的个数是奇数个时，也可以组成回文字符串的一部分，只要剔除一个字符就可以了。

先定义一个大小52的数字，用来存放小写26个字母和大写26个字母的遍历结果
如果有那个字母出现，那么就在对应位置上加一
遍历每个字母出现的次数，如果是奇数个，那么就减一加到最终结果中，因为回文中间可以是有一个单独的字母的，所以，中间，如果有奇数个字母的出现的话，那么就最后结果加一就行了。

```
class Solution {
    public int longestPalindrome(String s) {
        int[] resArray = new int[52];
        char[] chars = s.toCharArray();
        int res = 0;
        for (int i = 0, len = chars.length; i < len; ++i) {
            if (chars[i] >= 'a' && chars[i] <= 'z') {
                resArray[chars[i] - 'a'] ++;
            } else {
                resArray[(chars[i] - 'A') + 26] ++;
            }
        }
//遍历每个字母出现的次数，如果是奇数个，那么就减一加到最终结果中，因为回文中间可以是有一个单独的字母的，
//所以，中间，如果有奇数个字母的出现的话，那么就最后结果加一就行了。
        boolean hasOdd = false;
        for (int i = 0; i < 52; ++i) {
            if (resArray[i] % 2 == 1 ) {
                res += (resArray[i] - 1);
                hasOdd = true;
            } else if (resArray[i] % 2 == 0) {
                res += resArray[i];
            }
        }
        return hasOdd ? res + 1 : res;
    }
}
```

----------
221

给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。

示例 1:

输入: [3, 2, 1]

输出: 1

解释: 第三大的数是 1.

```
class Solution {
    public int thirdMax(int[] nums) {
        if(nums.length == 1) return nums[0];
        if(nums.length == 2) return Math.max(nums[0],nums[1]);
        Arrays.sort(nums);
        int count = 1;
        for(int i = nums.length-1; i > 0; i--){
            if(nums[i] != nums[i-1]) count++;                            
            if(count == 3) return nums[i-1];
        }
        return nums[nums.length-1];
    }
}
```

----------
223

给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意:

每个数组中的元素不会超过 100
数组的大小不会超过 200
示例 1:

输入: [1, 5, 11, 5]

输出: true

解释: 数组可以分割成 [1, 5, 5] 和 [11].
 

示例 2:

输入: [1, 2, 3, 5]

输出: false

解释: 数组不能分割成两个元素和相等的子集.

这是0-1背包问题


状态定义：dp[i][j]表示从数组的 [0, i] 这个子区间内挑选一些正整数，每个数只能用一次，使得这些数的和恰好等于 j。
状态转移方程：很多时候，状态转移方程思考的角度是“分类讨论”，对于“0-1 背包问题”而言就是“当前考虑到的数字选与不选”。

1、不选择 nums[i]，如果在 [0, i - 1] 这个子区间内已经有一部分元素，使得它们的和为 j ，那么 dp[i][j] = true；

2、选择 nums[i]，如果在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i]。

```
class Solution {
    public boolean canPartition(int[] nums) {
        //动态规划，背包问题，从nums中选择一部分数字组合，填满容量为sum/2的背包 
        int n=nums.length;
        if(n == 0){
            return false;
        }
        
        //确定背包c的大小
        int sum = 0;
        for(int i=0; i<n; i++){
            sum+=nums[i];
        }
        int c = sum/2; 
        
        //两个相等的整数的和一定为偶数
        if(sum%2==1){
            return false;
        }
        //明确状态：dp[m][n] 考虑是否将第m个数字放入容量为n的背包 
        boolean[][] dp = new  boolean[n][c+1];
        
        //状态初始化
        for(int i=0; i<=c; i++){
            if(i!=nums[0]){
                dp[0][i] = false;
            }else{
                dp[0][i] = true;
            }
        }
   
        for(int i=1; i<n; i++){
            for(int j=0; j<=c; j++){
                dp[i][j] = dp[i-1][j];
                if(nums[i]<=j){
                    dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]];                    
                }
                
            }
        }
        
        return dp[n-1][c];       
    }
}

```
----------
227

统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。

请注意，你可以假定字符串里不包括任何不可打印的字符。

示例:

输入: "Hello, my name is John"
输出: 5

（1）准备一个数组，用来存储单词

（2）准备一个String类型的临时变量str，用来拼接字符串

（3）遍历原字符串，如果非空，则在str的尾部添加当前字符；如果为空或者遍历到最后一个字符，则说明一个单词的结束，把当前拼接到的一个单词存到数组中，同时str置空

```
class Solution {
    public int countSegments(String s) {
        if(s.length()<1){
            return 0;
        }
        List<String> list=new ArrayList<>();
        int len=s.length();
        String str="";
        for(int i=0;i<len;++i){
            if(s.charAt(i)!=' '){
                str+=s.charAt(i);
                if(i==len-1||s.charAt(i+1)==' '){
                    list.add(str);
                    str="";
                }
            }
        }
        return list.size();
    }
}
```

----------
228

给定一个二叉树，它的每个结点都存放着一个整数值。

找出路径和等于给定数值的路径总数。

路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。

示例：

root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1.  5 -> 3
2.  5 -> 2 -> 1
3.  -3 -> 11



关于树的题目，就要考虑利用递归。
这里，就考虑根 + 左子树 + 右子树 = sum即可。
那么这里只需要用sum是否为0作为递归结束的条件即可。

```

class Solution {
    public int pathSum(TreeNode root, int sum) {
        if(root == null)
            return 0;
        return dfs(root, sum) + pathSum(root.left, sum)+pathSum(root.right, sum);
    }
    
    public int dfs(TreeNode root,int sum){
        if(root == null)
            return 0;
        int count = 0;
        if(root.val == sum)
            count ++;
        count += dfs(root.left, sum - root.val);
        count += dfs(root.right, sum - root.val);
        return count;
    }
}
```

----------
229

给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。

找到所有出现两次的元素。

你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？

示例：

输入:
[4,3,2,7,8,2,3,1]

输出:
[2,3]


![](TY/51.png)

/*
 0 1 2 3 4 5 6 //数组序号
 7 7 4 2 4 1 1 //初始序列
            -1 //i=0, nums[abs(nums[0])-1] *= -1;
            +1 //i=1, nums[abs(nums[1])-1] *= -1;//7成对出现了。
      -2       //i=2, nums[abs(nums[2])-1] *= -1;
   -7          //i=3, nums[abs(nums[3])-1] *= -1;
      +2       //i=4, nums[abs(nums[4])-1] *= -1;//4成对出现了。
-7             //i=5, nums[abs(nums[5])-1] *= -1;
+7             //i=6, nums[abs(nums[6])-1] *= -1;//1成对出现了。
*/
```
class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> rs = new ArrayList<>();
        for(int i = 0; i < nums.length; i ++){
           if(nums[Math.abs(nums[i])-1] < 0){
               rs.add(Math.abs(nums[i]));
           }else{
               nums[Math.abs(nums[i])-1] *= -1;
           }
        }
        return rs;   
    }
}
```

----------
230

给定一组字符，使用原地算法将其压缩。

示例 1：

输入：
["a","a","b","b","c","c","c"]

输出：
返回6，输入数组的前6个字符应该是：["a","2","b","2","c","3"]

说明：
"aa"被"a2"替代。"bb"被"b2"替代。"ccc"被"c3"替代。
示例 2：

输入：
["a"]

输出：
返回1，输入数组的前1个字符应该是：["a"]

说明：
没有任何字符串被替代。
示例 3：

输入：
["a","b","b","b","b","b","b","b","b","b","b","b","b"]

输出：
返回4，输入数组的前4个字符应该是：["a","b","1","2"]。

说明：
由于字符"a"不重复，所以不会被压缩。"bbbbbbbbbbbb"被“b12”替代。
注意每个数字在数组中都有它自己的位置。

```
public int compress(char[] chars) {
        int index = 0; //用来更新chars
        int i = 0; //用来遍历chars
        while (i < chars.length) {
            int sum = 1;
            for (int j = i + 1; j < chars.length; j++) { //找到有几个相等的字符
                if (chars[j] != chars[i]) {
                    break;
                }
                sum++;
            }
            chars[index++] = chars[i];
            if (sum > 1) {
                String s = String.valueOf(sum);
                for (int k = 0; k < s.length(); k++) {
                    chars[index++] = s.charAt(k);
                }
            }
            i += sum;
        }
        return index;
    }
```
----------
233

给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。

找到所有在 [1, n] 范围之间没有出现在数组中的数字。

您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

示例:

输入:
[4,3,2,7,8,2,3,1]

输出:
[5,6]


```
/**
     *
     * 找出 1 - n 中没有出现的数字。不能使用额外的空间，两次循环时间复杂度为 2O(n)，即为 O(n)。
     *
     * 解题思路：使用数组的下标来标记数字的出现于否，通过一遍遍历即可标记出全部已经出现的数组
     *
     * [4,3,2,7,8,2,3,1] 初始数据
     *
     * [4,3,2,-7,8,2,3,1] 第一个数据 4 出现，将数组的第四个也就是下标 3 的数据修改为负数。-7 计算时，通过绝对值处理一下即可不影响数据的计算
     * [4,3,-2,-7,8,2,3,1]
     * [4,-3,-2,-7,8,2,3,1]
     * [4,-3,-2,-7,8,2,-3,1]
     * [4,-3,-2,-7,8,2,-3,-1]
     * [4,-3,-2,-7,8,2,-3,-1]
     * [4,-3,-2,-7,8,2,-3,-1]
     * [-4,-3,-2,-7,8,2,-3,-1]
     *
     * 计算结束，数组的第五个，第六个依然为整数，证明 5,6 没有出现
     *
     * @param nums
     * @return
     */
    public List<Integer> findDisappearedNumbers(int[] nums) {
        List<Integer> results = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
            if (nums[Math.abs(nums[i]) - 1] > 0) {
                nums[Math.abs(nums[i]) - 1] = - nums[Math.abs(nums[i]) - 1];
            }
        }
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > 0) {
                results.add(i + 1);
            }
        }
        return results;
    }
```

----------

236

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

注意：

你可以假设胃口值为正。
一个小朋友最多只能拥有一块饼干。

示例 1:

输入: [1,2,3], [1,1]

输出: 1

解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
示例 2:

输入: [1,2], [1,2,3]

输出: 2

解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.

最大的饼干给最难满足的小朋友，如果满足不了就把饼干给第二个难满足的
```
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int cnt = 0;
        for(int j= 0,i=0;j<g.length&&i<s.length; ){
            if(g[j]<=s[i]){
                j++;
                i++;
                cnt+=1;
            }else{
                i++;
            }
        }
        return cnt;
    }
}
```

----------
237

给定一个整数序列：a1, a2, ..., an，一个132模式的子序列 ai, aj, ak 被定义为：当 i < j < k 时，ai < ak < aj。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。

注意：n 的值小于15000。

示例1:

输入: [1, 2, 3, 4]

输出: False

解释: 序列中不存在132模式的子序列。
示例 2:

输入: [3, 1, 4, 2]

输出: True

解释: 序列中有 1 个132模式的子序列： [1, 4, 2].

先指定第一个数字，然后往后遍历，比较出当前最大的数字，用max暂时存放，不断更新max的同时，判断当前遍历的数字nums[j]是否是大于第一个数字小于max，max是否大于第一个数字，符合条件返回true
```
class Solution {
    public boolean find132pattern(int[] nums) {
        if (nums.length<3)
            return false;
 
        for (int i = 0; i < nums.length - 1; i++) {
            int max = Integer.MIN_VALUE;
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] > max){
                    max = nums[j];
                }
                if (nums[j] < max && nums[j] > nums[i] && nums[i] < max){
                    return true;
                }
            }
        }
 
        return false;
    }
}
```

----------
238

重复的子字符串

给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。

示例 1:

输入: "abab"

输出: True

解释: 可由子字符串 "ab" 重复两次构成。
示例 2:

输入: "aba"

输出: False


思路：将给定的字符串与自身相加，形成新的字符串，然后判断在截取开头和结尾后的新的字符串中是否包含给定的字符串。

过程：

输入："abc"

转换："abc"  > "abcabc"

截取："abcabc" > "bcab"

判断："abc" not in "bcab"

输入："abcabc"

转换："abcabcabcabc"

截取："bcabcabcab"

判断："abcabc" in "bcabcabcab"

```
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        return (s+s).substring(1,s.length()*2-1).contains(s);
    }
}
```

----------
239

最少移动次数使数组元素相等 II(直觉是找中位数)

给定一个非空整数数组，找到使所有数组元素相等所需的最小移动数，其中每次移动可将选定的一个元素加1或减1。 您可以假设数组的长度最多为10000。

例如:

输入:
[1,2,3]

输出:
2

说明：
只有两个动作是必要的（记得每一步仅可使其中一个元素加1或减1）： 

[1,2,3]  =>  [2,2,3]  =>  [2,2,2]

此题的思路就是找数组的中位数，首先对数组进行排序，如果数组长度n是奇数，则中位数取下标为(n-1)/2的数;如果数组长度是偶数，则中位数取下标为n/2-1和下标为n/2之间的数（包含此两数任意数），然后遍历整个数组与此数的距离并且计算距离之和

```
import java.util.Arrays;

class Solution {
    public int minMoves2(int[] nums) {
    	int res=0,i=0,j=nums.length-1;
    	Arrays.sort(nums);
    	while (i < j) {
            res += nums[j--] - nums[i++];
        }
        return res;
    }
}
```
----------

243

输入：S = "5F3Z-2e-9-w", K = 4

输出："5F3Z-2E9W"

解释：字符串 S 被分成了两个部分，每部分 4 个字符；
     注意，两个额外的破折号需要删掉。

```
class Solution {
     public String licenseKeyFormatting(String S, int K) {

         S = S.toUpperCase().replace("-", "");
         StringBuilder sb = new StringBuilder(S);
         int len = sb.length();
         for (int i = K; i < len; i += K)
            sb.insert(len - i, '-');
        return sb.toString();
     }
 }
```

----------
246
给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

示例 1:

输入: nums: [1, 1, 1, 1, 1], S: 3
输出: 5
解释: 

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。

```
//递归
class Solution {
    int res = 0;
    public int findTargetSumWays(int[] nums, int S) {
        helper(nums, S, 0);  //递归
        return res;
    }
    public void helper(int[] nums, int S, int p){
        if(p >= nums.length)
        {
            if(S == 0) res++;
            return ;
        }
        helper(nums, S - nums[p], p + 1);
        helper(nums, S + nums[p], p + 1);
    }
}
```

----------
247

输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:
    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。
    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。
    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。
示例 2:

输入: nums1 = [2,4], nums2 = [1,2,3,4].
输出: [3,-1]
解释:
    对于num1中的数字2，第二个数组中的下一个较大数字是3。
    对于num1中的数字4，第二个数组中没有下一个更大的数字，因此输出 -1。

----------
248

键盘行

示例：

输入: ["Hello", "Alaska", "Dad", "Peace"]
输出: ["Alaska", "Dad"]

题目给了我们一个words array，让我们判断每一个word 中的 chars 是否都来自于键盘上的同一行。

利用HashMap 把键盘上的3行 chars 保存：char 当作 key；行数 当作 value。

接着遍历words，检查每一个word。

```
class Solution {
    public String[] findWords(String[] words) {
        String[] find={"qwertyuiop","asdfghjkl","zxcvbnm"};
        Map<Character,Integer> mp=new HashMap<>();
        for(int i=0;i<3;i++){
            for(char c:find[i].toCharArray()){
                mp.put(c,i);
            } 
        }
        List<String> list=new ArrayList<>();
        for(String word:words){
            int index=mp.get(word.toLowerCase().charAt(0));
            for(char c:word.toLowerCase().toCharArray()){
                if(mp.get(c)!=index){
                    index=-1;
                    break;
                }
            }
            if(index!=-1){
                list.add(word);
            }
        }
        return list.toArray(new String[list.size()]);
    }
}
```
----------

251

您需要在二叉树的每一行中找到最大的值。

示例：

输入: 

          1
         / \
        3   2
       / \   \  
      5   3   9 

输出: [1, 3, 9]

按层次遍历二叉树，计算每层的最大值即可。

```
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if (root == null) { return list; }
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            int size = queue.size();
            int max = Integer.MIN_VALUE;
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (node.val > max) { max = node.val; }
                if (node.left != null) { queue.offer(node.left); }
                if (node.right != null) { queue.offer(node.right); }
            }
            list.add(max);
        }
        return list;
    }
}
```

----------
252
优美的数列

假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 <= i <= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：

第 i 位的数字能被 i 整除
i 能被第 i 位上的数字整除
现在给定一个整数 N，请问可以构造多少个优美的排列？

示例1:

输入: 2
输出: 2
解释: 

第 1 个优美的排列是 [1, 2]:
  第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除
  第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除

第 2 个优美的排列是 [2, 1]:
  第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除
  第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除



我们使用函数 calculate，它将从 1 到 N 所有还没有被使用过的数字放到当前位置 pospos，并检查是否满足可除性。如果 ii 放到当前位置 pospos 是满足要求的，我们就把 ii 放在当前位置 pospos 并继续考虑下一个位置 pos + 1pos+1，否则我们需要换一个数字放在当前位置。

```
class Solution {
	
	private int ans;
	
    public int countArrangement(int N) {
        
    	ans=0;
    	boolean[] visited=new boolean[N+1];
    	calculate(N,1,visited);
    	return ans;
    }
    
    private void calculate(int N,int pos,boolean[] visited) {
    	if(pos>N) ans++;
    	for(int i=1;i<=N;i++) {
    		if(!visited[i] && (pos%i==0 || i%pos==0)) {
    			visited[i]=true;
    			calculate(N,pos+1,visited);
    			visited[i]=false;
    		}
    	}
    }
}
```

----------
254

给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。

示例 1:
输入:

"bbbab"
输出:

4
一个可能的最长回文子序列为 "bbbb"。

示例 2:
输入:

"cbbd"
输出:

2
一个可能的最长回文子序列为 "bb"。

这样定义：如果已知区间 i - j 中最长的回文子序列长度为 dp[i] [j]，那么区间 [i - 1，j + 1]有两种情况

如果s[i - 1] == s[j + 1] ，那么dp[i - 1] [j + 1] = dp[i] [j] + 2

如果s[i - 1] ！= s[j + 1] ，那么最长的回文子序列可能是dp[i - 1] [j]，也可能是dp[i] [j + 1]，取二者最大的

如果要求dp[i] [j]，那么需要知道dp[i - 1] [j]，dp[i] [j - 1]，dp[i - 1] [j - 1]，因为s[i]和s[j]之间的关系不确定，可能相等，也可能不等。

初始化：

for (int i = 0; i < length; i++) 
    dp[i][i] = 1;	//一个字符也算是回文串
1
2
由上述分析，可以看出如果我们要求的就是dp[0] [s.length - 1]，但是我们应该怎么遍历呢？

一开始，我们知道了dp矩阵的主对角线，并且下三角形矩阵是没有意义的，比如dp[3] [1]没有实际意义，要求dp矩阵最右上角的元素，比较方便的就是倒着遍历（外层循环向上，内层循环向右）

```
class Solution {
    public int longestPalindromeSubseq(String s) {
        if(s.length() == 0)
        	return 0;
        int length = s.length();
        int[][] dp = new int[length][length];
        for (int i = 0; i < length; i++) {
        	dp[i][i] = 1;
        }
        for (int i = length - 1; i >= 0; i--) {
			for (int j = i+1; j < s.length(); j++) {
				if(s.charAt(i) == s.charAt(j)) 
					dp[i][j] = dp[i+1][j-1] + 2;
				else 
					dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);
			}
		}
        return dp[0][length-1];
    }
}
```

----------
255
给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k.

示例 1:

输入: [3, 1, 4, 1, 5], k = 2
输出: 2
解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。
尽管数组中有两个1，但我们只应返回不同的数对的数量。
示例 2:

输入:[1, 2, 3, 4, 5], k = 1
输出: 4
解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。


主要思路是先对数组排序，然后使用滑动窗口(滑动窗口详细介绍)遍历数组，也算一种双指针。因为数组排序之后差是可以连续移动两个指针得到的，这种方法同样要对相同的数字进行排除

```
class Solution {
    public int findPairs(int[] nums, int k) {
        if(k<0)  return 0;
        Arrays.sort(nums);
        int count=0;
        int pre=0;
        int post=1;
        int prenum=Integer.MIN_VALUE;
        while(post<nums.length)
        {  
            if(nums[post]-nums[pre]==k)
            {
                if(nums[pre]!=prenum)
                {
                    count++;
                 prenum=nums[pre];
                }  
                 post++;
                 pre++;
            }
            else if(nums[post]-nums[pre]>k)
            {
                if(pre==post-1)
                {
                    pre++;
                    post++;
                }else 
                    pre++;   
            }
               
            else 
                post++;   
        }
        return count;
    }
}
```
----------

258

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。

示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

注意：两结点之间的路径长度是以它们之间边的数目表示。


递归，对，没错，还是递归。
还是将这棵树看作一个整体，我们要求的是左子树的最大深度 + 右子树的最大深度。
那么，就先将左子树进行递归，再将右子树进行递归，将它们相加，求所有左子树深度 + 右子树深度的最大值即可。
```

class Solution {
    int max = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        depth(root);
        return max;
    }
    private int depth(TreeNode root){
        if(root == null){
            return 0;
        }
        int leftDepth = depth(root.left);
        int rightDepth = depth(root.right);
        max = Math.max(leftDepth + rightDepth, max);
        return Math.max(leftDepth, rightDepth) + 1;
    }
}
```

----------
261

给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。

示例 1 :

输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。


1、建立 map 表用于存储每个连续子数组 sum 求和出现的次数，初始化为（0,1），表示和为 0 的连续子数组出现 1 次；

2、sum 的值是在对 nums 数组的循环中不断累加当前元素的，res 的值则需要查找 map 中是否已存在和为 sum - k 的连续数组，也就是在查找此前所有从 0 项开始累加的连续子项和中有没有 sum - k。

3、如果有的话，则说明从该项到当前项的连续子数组和必定为 k，那么 res 则可以和这个 sum 的对应值，即这个 sum 出现的次数，相加得到新的 res。

4、对于当前 sum 如果已存在与 map 中则其对应值 +1，不存在则添加新项，初始值为 1。


map 中的 key 存的是前缀为 x，value存的是前缀为x的连续子数组的个数，pi = a[0] + a[1] + ... + a[i]，pj =  a[0] + a[1] + ... + a[j]。当 pj - pi = a[i + 1] + a[i + 2] + ... + a[ j ] = K，只需要知道前面有几个 sum - k 的个数，就是所求的结果。

```
class Solution {	 
    public static int subArraySum(int[] nums, int k){
        int sum = 0;
        int res = 0;
        Map<Integer, Integer> preSum = new HashMap<>();
        preSum.put(0, 1);
        for(int i = 0; i < nums.length; i++){
            sum += nums[i];
            // 判断是否存在和为sum - k的连续式数组，如果存在，那么一定存在和为k的连续数组
            // 每次都是从数组起始位置累加的
            if(preSum.containsKey(sum - k)){
                res += preSum.get(sum - k);
            }
            // 如果不存在sum-k的连续子数组，则将sum的连续子数组存进preSum里
            preSum.put(sum, preSum.getOrDefault(sum, 0) + 1);
        }
        return res;
    }
}
```

----------
262

给定一个二叉树，计算整个树的坡度。

一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。

整个树的坡度就是其所有节点的坡度之和。

示例:

输入: 
         1
       /   \
      2     3
输出: 1
解释: 
结点的坡度 2 : 0
结点的坡度 3 : 0
结点的坡度 1 : |2-3| = 1
树的坡度 : 0 + 0 + 1 = 1

每个节点的坡度为左子树所有节点值之和 与 右子树所有节点值之和的差（绝对值）
调用dfs()
若当前节点为空，返回0
获取当前节点的 左子树之和 left ，获取右子树之和 right，并向左右子树递归
将每个节点的坡度增入 treeTilt\
返回当前节点与左右子树节点之和给父节点
```
class Solution {
    int treeTilt = 0;
    public int findTilt(TreeNode root) {
        dfs(root);
        return treeTilt;
    
    }
    public int dfs(TreeNode node){
        if(node == null)
            return 0;
        int left = dfs(node.left);
        int right = dfs(node.right);
        treeTilt += Math.abs(left-right);
        return left + right + node.val;
    }
}
```

----------
263

在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。

给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。

重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。

如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。

示例 1:

输入: 
nums = 
[[1,2],
 [3,4]]
r = 1, c = 4
输出: 
[[1,2,3,4]]
解释:
行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。

没有简便算法，只能将原矩阵中元素依次填入新矩阵中。对于新矩阵的行和列设置两层 for 循环，对于原矩阵，填入时通过索引判断是否需要换行。
```
public int[][] matrixReshape(int[][] nums, int r, int c) {
        int n = nums.length;
        int m = nums[0].length; 
        if(n * m != r * c) return nums;
        n = 0; m = 0;
        int[][] ans = new int[r][c];
       for(int i = 0; i < r; i++){
           for(int j = 0; j < c; j++){
               ans[i][j] = nums[n][m];
               m++;
               if(m == nums[0].length){
                    m = 0;
                    n++;
               }
           }
       }
       return ans;
    }
```

----------

265

给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。

示例 1:
给定的树 s:

     3
    / \
   4   5
  / \
 1   2
给定的树 t：

   4 
  / \
 1   2
返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。

```
class Solution {
    StringBuilder s1 = new StringBuilder();
    StringBuilder s2 = new StringBuilder();

    public boolean isSubtree(TreeNode s, TreeNode t) {
        if (s == null) return false;
        dfs(s,s1);
        dfs(t,s2);
        return s1.toString().contains(s2.toString());
    }

    private void dfs(TreeNode root, StringBuilder s){
        if (root == null) {
            s.append("#,");
            return;
        }
        dfs(root.left,s);
        dfs(root.right,s);
        s.append(root.val).append(",");
    }
   
}
```

----------


